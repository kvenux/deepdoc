================================================================================
项目结构 (基于过滤规则):
src
├── common
│   └── types.ts
├── extension
│   ├── agents
│   │   ├── executors
│   │   │   ├── MapReduceExecutor.ts
│   │   │   └── ToolChainExecutor.ts
│   │   ├── orchestrators
│   │   │   └── ProjectDocumentationOrchestrator.ts
│   │   ├── AgentContext.ts
│   │   └── CustomAgentExecutor.ts
│   ├── config
│   │   └── fileFilters.ts
│   ├── services
│   │   ├── AgentService.ts
│   │   ├── LLMService.ts
│   │   ├── StatsTracker.ts
│   │   ├── ToolRegistry.ts
│   │   └── logging.ts
│   ├── tools
│   │   ├── fileSystemTools.ts
│   │   └── llmTools.ts
│   ├── CodeWikiViewProvider.ts
│   ├── StateManager.ts
│   └── extension.ts
├── test
│   └── suite
│       └── index.ts
└── webview
    ├── components
    │   ├── AgentRunBlock.ts
    │   ├── AtCommandMenu.ts
    │   └── MessageBlock.ts
    ├── css
    │   └── main.css
    ├── views
    │   ├── App.ts
    │   ├── ChatHistoryView.ts
    │   ├── ChatView.ts
    │   ├── FocusEditorView.ts
    │   ├── PerformanceSettingsView.ts
    │   ├── PromptEditorView.ts
    │   ├── PromptManagerView.ts
    │   ├── SettingsView.ts
    │   └── WelcomeView.ts
    ├── main.ts
    └── vscode.ts
================================================================================

--- file_path: common/types.ts ---
// --- file_path: common/types.ts ---
/**
 * Defines the structure for messages posted between the Webview and the Extension Host.
 */
export interface PostMessage {
    command: string;
    payload?: any;
}

/**
 * Represents the configuration for a single language model.
 */
export interface ModelConfig {
    id: string;
    name: string;
    baseUrl: string;
    apiKey: string;
    modelId: string;
    isDefault?: boolean;
}

/**
 * 新增：代表性能和限制相关的配置。
 */
export interface PerformanceConfig {
    concurrencyLimit: number; // LLM 并发请求数
    minInterval: number;      // LLM 请求最小间隔 (ms)
    maxTokensPerBatch: number; // Map-Reduce 每批最大 Token 数
    maxTokensForDirectAnalysis: number; // 直接分析的最大 Token 阈值
}

/**
 * 新增：代表一个已完成并被持久化的 Agent 运行记录中单个步骤的状态。
 * 注意：这不包含 runId 或 isCollapsed 等瞬态/UI状态。
 */
export interface SavedStepState {
    stepName: string;
    taskId?: string;
    status: 'running' | 'completed' | 'failed' | 'waiting';
    logs: { type: 'input' | 'output' | 'llm-request', data: any, metadata?: Record<string, any> }[];
    streamedContent: string;
    error?: string;
}


/**
 * 新增：代表一个已完成并被持久化的 Agent 运行记录。
 */
export interface AgentRunRecord {
    plan: AgentPlan;
    // 注意：executionState 的 key 是 stepKey (taskId 或 stepName)
    executionState: Record<string, SavedStepState>;
    result: AgentResult;
}

/**
 * 代表一个标准的文本消息。
 */
export interface TextChatMessage {
    type: 'text';
    role: 'user' | 'assistant';
    content: string;
}

/**

 * 代表一个已完成的 Agent 运行消息。
 */
export interface AgentRunChatMessage {
    type: 'agent_run';
    role: 'assistant'; // Agent 运行总是被视为 'assistant' 的一部分
    run: AgentRunRecord;
}

/**
 * 代表一个完整的消息，可以是文本或 Agent 运行。
 */
export type ChatMessage = TextChatMessage | AgentRunChatMessage;


/**
 * Represents a full conversation, including its ID, title, and all messages.
 */
export interface Conversation {
    id: string;
    title: string;
    messages: ChatMessage[];
    createdAt: string; // ISO 8601 date string
}

/**
 * Represents a reusable prompt template.
 */
export interface Prompt {
    id: string;
    title: string;
    content: string;
    createdAt: string; // ISO 8601 date string
    updatedAt: string; // ISO 8601 date string
}

/**
 * =======================================================================
 * Agent Execution Event & Plan Types
 * =======================================================================
 */

/**
 * 定义了一个Agent执行计划中的单个步骤。
 */
export interface AgentPlanStep {
    name: string;
    description: string;
    promptFiles?: string[]; // 使用的YML文件名
}

/**
 * 描述了Agent的完整执行计划。
 */
export interface AgentPlan {
    agentName: string;
    agentId: string;
    steps: AgentPlanStep[];
    parameters: { // 需要用户输入的参数
        name: string;
        description: string;
        type: 'path' | 'string';
        value?: any; // 解析后的或用户输入的值
        isValid?: boolean;
        error?: string;
    }[];
}

/**
 * 代表一个正在执行的步骤或子任务。
 */
export interface StepExecution {
    runId: string; // 整个Agent运行的唯一ID
    stepName: string; //
    taskId?: string; // 并行任务中，子任务的唯一ID
    status: 'running' | 'completed' | 'failed' | 'waiting';
}

/**
 * 用于更新一个正在执行的步骤的信息。
 */
export interface StepUpdate {
    runId: string;
    taskId?: string;
    type: 'input' | 'output' | 'llm-request' | 'status';
    data: any;
    metadata?: Record<string, any>; // 例如 { type: 'file', path: '...' }
}

/**
 * 代表一个步骤或子任务的最终结果。
 */
export interface StepResult {
    runId: string;
    stepName: string; // <-- 新增: 确保步骤名称被传递
    taskId?: string; //
    status: 'completed' | 'failed';
    output?: any;
    error?: string;
}

/**
 * 代表一个LLM流式响应的数据块。
 */
export interface StreamChunk {
    runId: string;
    taskId?: string;
    content: string;
}

/**
 * 代表整个Agent运行的最终结果。
 */
export interface AgentResult {
    runId: string;
    status: 'completed' | 'failed' | 'cancelled';
    finalOutput?: any;
    error?: string;
    stats?: {
        duration: string;
        totalTokens: number;
        promptTokens: number;
        completionTokens: number;
    };
}

--------------------------------------------------------------------------------

--- file_path: extension/CodeWikiViewProvider.ts ---
// src/extension/CodeWikiViewProvider.ts (修改后完整文件)

import * as vscode from 'vscode';
import { PostMessage, Conversation, ChatMessage, Prompt, ModelConfig, AgentPlan, TextChatMessage, PerformanceConfig } from '../common/types';
import { StateManager } from './StateManager';
import { LLMService } from './services/LLMService';
import { AgentService } from './services/AgentService';
import { v4 as uuidv4 } from 'uuid';
import * as yaml from 'js-yaml';
import { WebviewLogger } from './services/logging';
import * as path from 'path';

export class CodeWikiViewProvider implements vscode.WebviewViewProvider {

    public static readonly viewType = 'codewiki.mainView';

    private _view?: vscode.WebviewView;
    private _focusEditorView?: vscode.WebviewPanel;
    private _stateManager: StateManager;
    private _llmService: LLMService;
    private _agentService: AgentService; // <-- 新增 AgentService 成员
    private _activeConversation: Conversation | null = null;

    constructor(
        private readonly _extensionUri: vscode.Uri,
        private readonly _context: vscode.ExtensionContext,
        agentService: AgentService // <-- 注入 AgentService
    ) {
        this._stateManager = new StateManager(this._context.globalState);
        this._llmService = new LLMService();
        this._agentService = agentService; // <-- 保存注入的实例
    }

    // initializeTools 方法被移除，其功能已移至 AgentService 和 ToolRegistry

    public resolveWebviewView(
        webviewView: vscode.WebviewView,
        context: vscode.WebviewViewResolveContext,
        _token: vscode.CancellationToken,
    ) {
        this._view = webviewView;

        webviewView.webview.options = {
            // Allow scripts in the webview
            enableScripts: true,

            localResourceRoots: [
                this._extensionUri
            ]
        };

        webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

        webviewView.webview.onDidReceiveMessage((data: PostMessage) => {
            this.handleMessage(data, 'sidebar');
        });
    }

    private async handleMessage(data: PostMessage, source: 'sidebar' | 'focus-editor' = 'sidebar') {
        const webview = (source === 'sidebar' && data.command.startsWith('agent:'))
            ? this._view?.webview
            : (source === 'focus-editor')
                ? this._focusEditorView?.webview
                : this._view?.webview; // 默认或非 agent 命令使用主视图

        // 对于 Agent 命令，我们强制它必须来自主视图，并检查 webview 是否存在
        if (data.command.startsWith('agent:')) {
            if (!this._view?.webview) {
                console.error("Agent command received but main webview is not available.");
                return;
            }
        }
        const sourceWebview = (source === 'focus-editor') ? this._focusEditorView?.webview : this._view?.webview;

        switch (data.command) {
            case 'ready':
                {
                    const sourceWebview = (source === 'focus-editor') ? this._focusEditorView?.webview : this._view?.webview;
                    if (!sourceWebview) break;

                    const conversations = await this._stateManager.getConversations();
                    // --- highlight-start ---
                    // console.log("--- All Conversations on Ready ---", JSON.stringify(conversations, null, 2));
                    // --- highlight-end ---
                    const modelConfigs = await this._stateManager.getModelConfigs();
                    const prompts = await this._stateManager.getPrompts();
                    const performanceConfig = await this._stateManager.getPerformanceConfig();

                    // If there are conversations, set the most recent one as active.
                    if (source === 'sidebar' && conversations.length > 0) {
                        if (!this._activeConversation) { // 避免覆盖已激活的对话
                            this._activeConversation = conversations[conversations.length - 1];
                        }
                    }

                    sourceWebview.postMessage({
                        command: 'initialize',
                        payload: {
                            conversations,
                            modelConfigs,
                            prompts,
                            performanceConfig // 发送新配置到前端
                        }
                    });
                    break;
                }
            case 'openFocusEditor':
                {
                    const { content, modelId, promptId } = data.payload;
                    if (this._focusEditorView) {
                        this._focusEditorView.reveal(vscode.ViewColumn.One);
                    } else {
                        this._focusEditorView = vscode.window.createWebviewPanel(
                            'codewiki.focusEditor',
                            'Focus Editor',
                            vscode.ViewColumn.One,
                            {
                                enableScripts: true,
                                localResourceRoots: [this._extensionUri]
                            }
                        );

                        this._focusEditorView.webview.html = this._getHtmlForWebview(this._focusEditorView.webview);

                        this._focusEditorView.onDidDispose(() => {
                            this._focusEditorView = undefined;
                            this._view?.webview.postMessage({ command: 'focusEditorClosed' });
                        }, null, this._context.subscriptions);

                        this._focusEditorView.webview.onDidReceiveMessage((msg) => this.handleMessage(msg, 'focus-editor'));
                    }

                    const modelConfigs = await this._stateManager.getModelConfigs();
                    const prompts = await this._stateManager.getPrompts();

                    // 将所有需要的数据一次性发送过去
                    this._focusEditorView.webview.postMessage({
                        command: 'showFocusEditor',
                        payload: {
                            content,
                            modelId,
                            promptId,
                            modelConfigs, // 捆绑模型数据
                            prompts       // 捆绑提示词数据
                        }
                    });
                    break;
                }
            case 'closeFocusEditor':
                {
                    this._focusEditorView?.dispose();
                    break;
                }
            case 'updateWebviewContent':
                {
                    const { content } = data.payload;
                    if (source === 'sidebar') {
                        this._focusEditorView?.webview.postMessage({ command: 'updateContent', payload: { content } });
                    } else { // source === 'focus-editor'
                        this._view?.webview.postMessage({ command: 'updateContent', payload: { content } });
                    }
                    break;
                }
            case 'syncStateChange':
                {
                    if (source === 'sidebar') {
                        this._focusEditorView?.webview.postMessage({ command: 'updateState', payload: data.payload });
                    } else { // source === 'focus-editor'
                        this._view?.webview.postMessage({ command: 'updateState', payload: data.payload });
                    }
                    break;
                }
            case 'newChat':
                {
                    this._activeConversation = null;
                    // Potentially clear the webview chat here if needed
                    break;
                }
            case 'info':
                {
                    vscode.window.showInformationMessage(data.payload);
                    break;
                }
            case 'error':
                {
                    vscode.window.showErrorMessage(data.payload);
                    break;
                }
            
            case 'saveConversation': // 新增 case 处理来自 webview 的保存请求
                {
                    const { id, messages } = data.payload;
                    // --- DEBUG START ---
                    // console.log("--- Saving Conversation ---");
                    // console.log("Conversation ID:", id);
                    // console.log("Messages being saved:", JSON.stringify(messages, null, 2));
                    // --- DEBUG END ---
                    const allConversations = await this._stateManager.getConversations();
                    const conversationToUpdate = allConversations.find(c => c.id === id);
                    if (conversationToUpdate) {
                        conversationToUpdate.messages = messages;
                        await this._stateManager.saveConversation(conversationToUpdate);
                        // 更新内存中的活动对话
                        if (this._activeConversation && this._activeConversation.id === id) {
                            this._activeConversation = conversationToUpdate;
                        }
                    }
                    break;
                }
            
            case 'sendMessage':
                {
                    // When a message is sent from either view, clear the input in the other.
                    if (source === 'sidebar') {
                        this._focusEditorView?.webview.postMessage({ command: 'clearInput' });
                    } else {
                        this._view?.webview.postMessage({ command: 'clearInput' });
                    }

                    const { prompt, config } = data.payload;
                    
                    const userMessage: TextChatMessage = { type: 'text', role: 'user', content: prompt };
                    let modelMessage: TextChatMessage = { type: 'text', role: 'assistant', content: '' };
                    

                    // Ensure there is an active conversation
                    if (!this._activeConversation) {
                        this._activeConversation = {
                            id: uuidv4(),
                            title: prompt.substring(0, 50), // Add title
                            messages: [],
                            createdAt: new Date().toISOString(),
                        };
                         
                        // 首次消息，需要将整个新对话保存起来
                        this._activeConversation.messages.push(userMessage);
                        await this._stateManager.saveConversation(this._activeConversation);
                         
                    } else {
                        this._activeConversation.messages.push(userMessage);
                    }


                    // Tell the webviews to enter streaming state
                    this._view?.webview.postMessage({ command: 'startStreaming' });
                    this._focusEditorView?.webview.postMessage({ command: 'startStreaming' });


                    let fullReply = '';
                    this._llmService.getCompletion(
                        this._activeConversation.messages,
                        config,
                        (chunk: string) => { 
                            fullReply += chunk;
                            this._view?.webview.postMessage({ command: 'streamData', payload: chunk });
                            this._focusEditorView?.webview.postMessage({ command: 'streamData', payload: chunk });
                        },
                        async () => {
                            modelMessage.content = fullReply;
                            // Ensure we have an active conversation before proceeding
                            if (this._activeConversation) {
                                this._activeConversation.messages.push(modelMessage);
                                await this._stateManager.saveConversation(this._activeConversation);
                            }
                            
                            // Tell both webviews to end streaming state
                            this._view?.webview.postMessage({ command: 'streamEnd' });
                            this._focusEditorView?.webview.postMessage({ command: 'streamEnd' });
                        
                            // Update history view in case a new conversation was created
                            const conversations = await this._stateManager.getConversations();
                            this._view?.webview.postMessage({ command: 'updateHistory', payload: conversations });
                        },
                        (error: any) => { 
                            const errorPayload = { error: error.message };
                            this._view?.webview.postMessage({ command: 'requestFailed', payload: errorPayload });
                            this._focusEditorView?.webview.postMessage({ command: 'requestFailed', payload: errorPayload });
                        }
                    );
                    break;
                }
            case 'stopMessage':
                {
                    this._llmService.abortRequest();
                    break;
                }
            case 'executeActionPrompt':
                {
                    const webview = this._view?.webview;
                    if (!webview) return;

                    const { yamlContent, userInputs, modelConfig } = data.payload;

                    // 启动流式处理的UI状态
                    webview.postMessage({ command: 'startStreaming' });

                    // 将所有复杂性委托给 AgentService
                    // AgentService 内部会创建 WebviewLogger 来发送状态更新、流式数据和错误
                    await this._agentService.runActionFromWebview(
                        yamlContent,
                        userInputs,
                        modelConfig,
                        webview
                    );

                    // AgentService 完成后，结束流式UI状态
                    webview.postMessage({ command: 'streamEnd' });

                    break;
                }
            case 'regenerate':
            case 'editMessage':
                {
                    if (!this._activeConversation) break;

                    const { messageIndex, content } = data.payload;

                    // Truncate the history to the point of regeneration/edit
                    this._activeConversation.messages.splice(messageIndex);

                    if (data.command === 'editMessage') {
                        
                        const userMessage: TextChatMessage = { type: 'text', role: 'user', content: content };
                        
                        this._activeConversation.messages.push(userMessage);
                    }

                    // Find the last valid model config from the conversation
                    const modelConfigs = await this._stateManager.getModelConfigs();
                    const defaultConfig = modelConfigs.find(c => c.isDefault) || modelConfigs[0];

                    if (!defaultConfig) {
                        vscode.window.showErrorMessage('No model configured.');
                        break;
                    }

                    
                    let modelMessage: TextChatMessage = { type: 'text', role: 'assistant', content: '' };
                    
                    let fullReply = '';

                    // Post a message to clear the old response and show a loading state
                    this._view?.webview.postMessage({ command: 'setActiveConversation', payload: this._activeConversation });
                    // Tell the webview to enter streaming state
                    this._view?.webview.postMessage({ command: 'startStreaming' });

                    this._llmService.getCompletion(
                        this._activeConversation.messages,
                        defaultConfig,
                        (chunk: string) => { 
                            fullReply += chunk;
                            this._view?.webview.postMessage({ command: 'streamData', payload: chunk });
                        },
                        async () => {
                            modelMessage.content = fullReply;
                            if (this._activeConversation) {
                                this._activeConversation.messages.push(modelMessage);
                                await this._stateManager.saveConversation(this._activeConversation);
                            }
                        
                            // Tell the main webview to end streaming state
                            this._view?.webview.postMessage({ command: 'streamEnd' });
                        
                            // Update history view
                            const conversations = await this._stateManager.getConversations();
                            this._view?.webview.postMessage({ command: 'updateHistory', payload: conversations });
                        },
                        (error: any) => { 
                            this._view?.webview.postMessage({ command: 'requestFailed', payload: { error: error.message } });
                        }
                    );
                    break;
                }
            case 'loadConversation':
                {
                    const { id } = data.payload;
                    const conversations = await this._stateManager.getConversations();
                    // --- highlight-start ---
                    // console.log("--- All Conversations on Load ---", JSON.stringify(conversations, null, 2));
                    // --- highlight-end ---
                    const conversation = conversations.find(c => c.id === id);
                    if (conversation) {
                        // --- DEBUG START ---
                        // console.log("--- Loading Specific Conversation ---");
                        // console.log("Conversation ID:", conversation.id);
                        // console.log("Messages being loaded:", conversation.messages);
                        // console.log("conversations:", conversations);
                        // --- DEBUG END ---
                        this._activeConversation = conversation;
                        this._view?.webview.postMessage({ command: 'setActiveConversation', payload: conversation });
                    }
                    break;
                }
            case 'deleteConversation':
                {
                    const { id } = data.payload;
                    await this._stateManager.deleteConversation(id);
                    const conversations = await this._stateManager.getConversations();
                    this._view?.webview.postMessage({ command: 'updateHistory', payload: conversations });
                    // If the deleted conversation was active, clear the chat view
                    if (this._activeConversation && this._activeConversation.id === id) {
                        this._activeConversation = null;
                        this._view?.webview.postMessage({ command: 'setActiveConversation', payload: null });
                    }
                    break;
                }
            case 'saveModelConfigs':
                {
                    await this._stateManager.saveModelConfigs(data.payload);
                    vscode.window.showInformationMessage('Model configurations saved.');

                    // 广播模型配置更新到所有视图
                    const updateMessage = {
                        command: 'updateModelConfigs',
                        payload: data.payload
                    };
                    this._view?.webview.postMessage(updateMessage);
                    this._focusEditorView?.webview.postMessage(updateMessage);

                    // Re-initialize agent service with the new default model
                    const defaultConfig = data.payload.find((c: ModelConfig) => c.isDefault) || (data.payload.length > 0 ? data.payload[0] : null);
                    if (defaultConfig) {
                        await this._agentService.initialize(defaultConfig);
                        console.log("AgentService re-initialized with new default model.");
                    } else {
                        console.warn("No default model config found after saving. Agent Service might not function correctly.");
                    }
                    break;
                }
            //== Prompt Management ==//
            case 'newPrompt':
                {
                    this._view?.webview.postMessage({ command: 'showPromptEditor' });
                    break;
                }
            case 'editPrompt':
                {
                    const { id } = data.payload;
                    const prompts = await this._stateManager.getPrompts();
                    const prompt = prompts.find(p => p.id === id);
                    if (prompt) {
                        this._view?.webview.postMessage({ command: 'showPromptEditor', payload: { prompt } });
                    }
                    break;
                }
            case 'savePrompt':
                {
                    const prompt: Prompt = data.payload;
                    await this._stateManager.savePrompt(prompt);
                    vscode.window.showInformationMessage(`Prompt "${prompt.title}" saved.`);
                    // First, update the prompts list in the webview
                    await this._updatePrompts();
                    // Then, tell the webview to navigate back to the manager
                    this._view?.webview.postMessage({ command: 'showPromptManager' });
                    break;
                }
            case 'cancelPromptEdit':
                {
                    this._view?.webview.postMessage({ command: 'showPromptManager' });
                    break;
                }
            case 'deletePrompt':
                {
                    const { id } = data.payload;
                    // Optional: Add a confirmation dialog
                    const confirmation = await vscode.window.showWarningMessage(
                        'Are you sure you want to delete this prompt?',
                        { modal: true },
                        'Delete'
                    );
                    if (confirmation === 'Delete') {
                        await this._stateManager.deletePrompt(id);
                        await this._updatePrompts();
                        vscode.window.showInformationMessage('Prompt deleted.');
                    }
                    break;
                }
            case 'agent:getPlan': {
                // 确保 webview 存在，agent 命令只在主视图处理
                const mainWebview = this._view?.webview;
                if (!mainWebview) break;

                const { agentId } = data.payload;
                const plan = this._agentService.getAgentPlan(agentId);
                if (plan) {
                    const logger = new WebviewLogger(mainWebview);
                    logger.onPlanGenerated(plan);
                } else {
                    vscode.window.showErrorMessage(`Agent with ID "${agentId}" could not be found.`);
                }
                break;
            }

            case 'agent:execute': {
                // 确保 webview 存在
                const mainWebview = this._view?.webview;
                if (!mainWebview) break;

                const { agentId, parameters } = data.payload;

                const modelConfigs = await this._stateManager.getModelConfigs();
                const defaultConfig = modelConfigs.find(c => c.isDefault) || modelConfigs[0];
                if (!defaultConfig) {
                    const errorMsg = 'No default model configured. Please set one in the settings.';
                    vscode.window.showErrorMessage(errorMsg);
                    const logger = new WebviewLogger(mainWebview);
                    logger.onAgentEnd({ runId: 'init-fail', status: 'failed', error: errorMsg });
                    return;
                }
                
                // 如果当前没有激活的对话，则创建一个新的
                if (!this._activeConversation) {
                    const agentPlan = this._agentService.getAgentPlan(agentId);
                    this._activeConversation = {
                        id: uuidv4(),
                        title: `Agent Run: ${agentPlan?.agentName || agentId}`,
                        messages: [],
                        createdAt: new Date().toISOString(),
                    };
                    await this._stateManager.saveConversation(this._activeConversation);
                    // 通知 webview 更新历史记录
                    const conversations = await this._stateManager.getConversations();
                    this._view?.webview.postMessage({ command: 'updateHistory', payload: conversations });
                    this._view?.webview.postMessage({ command: 'setActiveConversation', payload: this._activeConversation });
                }
                

                const logger = new WebviewLogger(mainWebview);

                // 异步执行 Agent
                this._agentService.prepareAndRunAgent(
                    agentId,
                    parameters,
                    defaultConfig,
                    logger
                );
                break;
            }

            case 'agent:cancel': {
                const { runId } = data.payload;
                if (runId) {
                    await this._agentService.cancelAgentRun(runId);
                }
                break;
            }

            case 'viewFile': {
                const filePathPayload = data.payload?.path;
                if (typeof filePathPayload === 'string') {
                    const workspaceFolders = vscode.workspace.workspaceFolders;
                    if (workspaceFolders && workspaceFolders.length > 0) {
                        const workspaceRootUri = workspaceFolders[0].uri;
                        let fileToOpenUri: vscode.Uri;

                        // 检查 filePathPayload 是否已经是绝对路径 (虽然通常 webview 发送的是相对路径或特殊标记的路径)
                        // 或者是否是相对于 .codewiki/runs/... 的路径
                        if (path.isAbsolute(filePathPayload)) {
                            fileToOpenUri = vscode.Uri.file(filePathPayload);
                        } else if (filePathPayload.startsWith('.codewiki/') || filePathPayload.startsWith('.vscode/')) {
                            // 假设路径是相对于工作区根目录的，例如从 .codewiki 目录
                            fileToOpenUri = vscode.Uri.joinPath(workspaceRootUri, filePathPayload);
                        } else {
                            // 默认行为：如果不是 .codewiki/runs/... 下的，尝试把它作为相对于 .codewiki 目录下的提示文件
                            // (这可能需要调整，取决于 fileCard 的 filePath 具体是什么)
                            // 假设它可能是 .codewiki 目录下的 yml 文件
                            // 如果是 Agent 运行产生的 markdown 文件，路径可能需要特别处理
                            // 例如，AgentResult 的 finalOutput 可能是 "项目总体设计文档.md"
                            // 这时需要结合 Agent 运行的 runDir 来构造完整路径

                            // 对于 AgentPlan 中的 promptFiles (e.g., 'project_planner.yml')
                            // 它们是相对于 .codewiki 目录的
                            if (filePathPayload.endsWith('.yml') || filePathPayload.endsWith('.yaml')) {
                                fileToOpenUri = vscode.Uri.joinPath(workspaceRootUri, '.codewiki', filePathPayload);
                            } else if (filePathPayload.endsWith('.md') && this._agentService && (this._agentService as any).getLastRunDir) {
                                // 这是一个假设：AgentService 能提供上次运行的目录
                                // 这个逻辑比较复杂，因为 CodeWikiViewProvider 通常不知道 runDir
                                // 更好的做法是让 AgentRunBlock 发送更明确的路径类型或完整路径
                                // 或者，AgentResult.finalOutput 如果是文件，应该是相对于工作区的路径
                                const lastRunDir = await (this._agentService as any).getLastRunDir(); // 需要 AgentService 支持
                                if (lastRunDir) {
                                    fileToOpenUri = vscode.Uri.joinPath(lastRunDir, filePathPayload);
                                } else {
                                    vscode.window.showErrorMessage(`无法确定文件 ${filePathPayload} 的完整路径。`);
                                    return;
                                }
                            }
                            else {
                                // 默认尝试作为项目根路径下的文件
                                fileToOpenUri = vscode.Uri.joinPath(workspaceRootUri, filePathPayload);
                            }
                        }

                        try {
                            // 检查文件是否存在
                            await vscode.workspace.fs.stat(fileToOpenUri);
                            vscode.window.showTextDocument(fileToOpenUri);
                        } catch (error) {
                            console.error(`Error opening file ${fileToOpenUri.fsPath}:`, error);
                            // 如果 .codewiki/xxx.yml 不存在，尝试作为项目根目录下的文件
                            if ((filePathPayload.endsWith('.yml') || filePathPayload.endsWith('.yaml')) && !filePathPayload.includes('/')) {
                                try {
                                    const rootFileUri = vscode.Uri.joinPath(workspaceRootUri, filePathPayload);
                                    await vscode.workspace.fs.stat(rootFileUri);
                                    vscode.window.showTextDocument(rootFileUri);
                                    return;
                                } catch (rootError) {
                                    vscode.window.showErrorMessage(`文件 "${filePathPayload}" 未在 .codewiki/ 或项目根目录中找到。`);
                                }
                            } else {
                                vscode.window.showErrorMessage(`无法打开文件: ${filePathPayload}. 文件可能不存在或路径不正确。`);
                            }
                        }
                    } else {
                        vscode.window.showWarningMessage('请先打开一个工作区以查看文件。');
                    }
                } else {
                    vscode.window.showErrorMessage('无效的文件路径。');
                }
                break;
            }

            case 'savePerformanceConfig':
                {
                    await this._stateManager.savePerformanceConfig(data.payload as PerformanceConfig);
                    // 将新配置应用到 LLMService
                    const perfConfig = await this._stateManager.getPerformanceConfig();
                    this._llmService.concurrencyLimit = perfConfig.concurrencyLimit;
                    this._llmService.minInterval = perfConfig.minInterval;
                    console.log(`Performance settings updated: Concurrency=${perfConfig.concurrencyLimit}, Interval=${perfConfig.minInterval}ms`);
                    break;
                }

        }
    }

    private async _updatePrompts() {
        const prompts = await this._stateManager.getPrompts();
        const updateMessage = { command: 'updatePrompts', payload: prompts };
        this._view?.webview.postMessage(updateMessage);
        this._focusEditorView?.webview.postMessage(updateMessage);
    }

    private _getHtmlForWebview(webview: vscode.Webview): string {
        const scriptUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'dist', 'webview.js'));
        const styleUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'src', 'webview', 'css', 'main.css'));
        const codiconsUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'node_modules', '@vscode/codicons', 'dist', 'codicon.css'));

        const nonce = getNonce();

        return `<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta http-equiv="Content-Security-Policy" content="default-src 'none'; font-src ${webview.cspSource}; style-src ${webview.cspSource}; script-src 'nonce-${nonce}';">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                
                <link href="${codiconsUri}" rel="stylesheet" />
                <link href="${styleUri}" rel="stylesheet" />
                
                <title>CodeWiki</title>
            </head>
            <body>
                <div id="root"></div>
                <script nonce="${nonce}" type="module" src="${scriptUri}"></script>
            </body>
            </html>`;
    }
}

function getNonce() {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}

--------------------------------------------------------------------------------

--- file_path: extension/StateManager.ts ---
import * as vscode from 'vscode';
import { Conversation, ModelConfig, Prompt, PerformanceConfig } from '../common/types';

const CONVERSATIONS_KEY = 'codewiki_conversations';
const PROMPTS_KEY = 'codewiki_prompts';
const MODEL_CONFIGS_KEY = 'codewiki_model_configs';
const PERFORMANCE_CONFIG_KEY = 'codewiki_performance_config'; // 新增 Key

/**
 * 默认的性能配置
 */
const DEFAULT_PERFORMANCE_CONFIG: PerformanceConfig = {
    concurrencyLimit: 5,   // 默认并发数
    minInterval: 10000,     // 默认请求间隔 1 秒
    maxTokensPerBatch: 64000, // 默认 Map-Reduce 批处理大小
    maxTokensForDirectAnalysis: 64000 // 默认直接分析阈值
};


/**
 * Manages the state of the extension, persisting data in VS Code's global state.
 * This class acts as the single source of truth for all persistent data.
 */
export class StateManager {
    constructor(private readonly globalState: vscode.Memento) {}

    //== Conversation Management ==//

    public async getConversations(): Promise<Conversation[]> {
        return this.globalState.get<Conversation[]>(CONVERSATIONS_KEY, []);
    }

    public async saveConversation(conversation: Conversation): Promise<void> {
        const conversations = await this.getConversations();
        const index = conversations.findIndex(c => c.id === conversation.id);
        if (index !== -1) {
            conversations[index] = conversation;
        } else {
            conversations.push(conversation);
        }
        await this.globalState.update(CONVERSATIONS_KEY, conversations);
    }

    public async deleteConversation(id: string): Promise<void> {
        const conversations = await this.getConversations();
        const filteredConversations = conversations.filter(c => c.id !== id);
        await this.globalState.update(CONVERSATIONS_KEY, filteredConversations);
    }

    //== Prompt Management ==//

    public async getPrompts(): Promise<Prompt[]> {
        return this.globalState.get<Prompt[]>(PROMPTS_KEY, []);
    }

    public async savePrompt(prompt: Prompt): Promise<void> {
        const prompts = await this.getPrompts();
        const index = prompts.findIndex(p => p.id === prompt.id);
        if (index !== -1) {
            prompts[index] = prompt;
        } else {
            prompts.push(prompt);
        }
        await this.globalState.update(PROMPTS_KEY, prompts);
    }

    public async deletePrompt(id: string): Promise<void> {
        const prompts = await this.getPrompts();
        const filteredPrompts = prompts.filter(p => p.id !== id);
        await this.globalState.update(PROMPTS_KEY, filteredPrompts);
    }

    //== Model Config Management ==//

   public async getModelConfigs(): Promise<ModelConfig[]> {
        // 直接从 globalState 获取配置，如果不存在，则返回一个空数组。
        return this.globalState.get<ModelConfig[]>(MODEL_CONFIGS_KEY, []);
    }

    public async saveModelConfigs(configs: ModelConfig[]): Promise<void> {
        // Ensure only one model is default
        let defaultFound = false;
        configs.forEach(config => {
            if (config.isDefault) {
                if (defaultFound) {
                    config.isDefault = false; // Unset other defaults
                } else {
                    defaultFound = true;
                }
            }
        });

        // If no default is set, make the first one default
        if (!defaultFound && configs.length > 0) {
            configs[0].isDefault = true;
        }

        await this.globalState.update(MODEL_CONFIGS_KEY, configs);
    }

     //== Performance Config Management ==//

    public async getPerformanceConfig(): Promise<PerformanceConfig> {
        const savedConfig = this.globalState.get<Partial<PerformanceConfig>>(PERFORMANCE_CONFIG_KEY, {});
        // 合并已保存的配置和默认配置，确保所有字段都有值
        return { ...DEFAULT_PERFORMANCE_CONFIG, ...savedConfig };
    }

    public async savePerformanceConfig(config: PerformanceConfig): Promise<void> {
        await this.globalState.update(PERFORMANCE_CONFIG_KEY, config);
    }
}


--------------------------------------------------------------------------------

--- file_path: extension/agents/AgentContext.ts ---
// src/extension/agents/AgentContext.ts (修改后完整文件)

import * as vscode from 'vscode';
import { ModelConfig, PerformanceConfig } from '../../common/types';
import { LLMService } from '../services/LLMService';
import { AgentLogger } from '../services/logging';
import { StatsTracker } from '../services/StatsTracker'; // <-- 新增 import
import { ToolRegistry } from '../services/ToolRegistry';

/**
 * 定义了Agent执行时所需的完整上下文。
 * 这个对象会作为依赖注入容器，在Agent的各个组件之间传递。
 */
export interface AgentContext {
    llmService: LLMService;
    toolRegistry: ToolRegistry;
    logger: AgentLogger;
    modelConfig: ModelConfig;
    statsTracker: StatsTracker; // <-- 新增
    performanceConfig: PerformanceConfig; // 新增

    // 可选的运行目录，用于记录详细的过程文件。
    // 如果提供了这个目录，执行器等组件可以将其中间产物写入文件。
    runDir?: vscode.Uri; 
}

--------------------------------------------------------------------------------

--- file_path: extension/agents/CustomAgentExecutor.ts ---
// src/extension/agents/CustomAgentExecutor.ts (修改后完整文件)

import { BaseLanguageModel } from '@langchain/core/language_models/base';
import { StructuredTool } from '@langchain/core/tools';
import { ChatPromptTemplate } from '@langchain/core/prompts';
import { AIMessage, BaseMessage, HumanMessage, SystemMessage } from '@langchain/core/messages';
import { StringOutputParser } from '@langchain/core/output_parsers';

export interface ToolChainStep {
    tool: string;
    input: string | Record<string, any>;
    output_variable: string;
}
export interface LlmPromptTemplate {
    system: string;
    human: string;
}
export interface AgentExecutorCallbacks {
    onToolStart?: (toolName: string, input: any) => void;
    onToolEnd?: (toolName:string, output: string) => void;
    onLlmStart?: (finalSystemPrompt: string, finalHumanPrompt: string) => void;
    onLlmStream?: (chunk: string) => void;
    onLlmEnd?: (finalResult: string) => void;
    onError?: (error: Error) => void;
}


export class CustomAgentExecutor {
    private tools: Map<string, StructuredTool>;
    private finalLlm: BaseLanguageModel;

    constructor(tools: StructuredTool[], finalLlm: BaseLanguageModel) {
        this.tools = new Map(tools.map(tool => [tool.name, tool]));
        this.finalLlm = finalLlm;
    }

    // --- 修改点：run 方法现在返回 Promise<string> ---
    public async run(
        tool_chain: ToolChainStep[],
        initialInputs: Record<string, string>,
        llm_prompt_template: LlmPromptTemplate,
        callbacks: AgentExecutorCallbacks
    ): Promise<string> { // <-- 返回类型修改
        return new Promise(async (resolve, reject) => {
            const context: Record<string, any> = { ...initialInputs };
        
            try {
                for (const step of tool_chain) {
                    const tool = this.tools.get(step.tool);
                    if (!tool) {
                        throw new Error(`Tool "${step.tool}" not found.`);
                    }
                    
                    const toolInput = this.resolveInput(step.input, context);
                    callbacks.onToolStart?.(tool.name, toolInput);

                    const toolOutputString = await tool.call(toolInput);
                    const toolOutputParsed = this.parseToolOutput(toolOutputString);
                    context[step.output_variable] = toolOutputParsed;

                    const outputSummary = toolOutputString.length > 500 ? `${toolOutputString.substring(0, 500)}...` : toolOutputString;
                    callbacks.onToolEnd?.(tool.name, outputSummary);
                }
                
                const systemMessageContent = this.resolveInput(llm_prompt_template.system, context) as string;
                const humanMessageContent = this.resolveInput(llm_prompt_template.human, context) as string;

                callbacks.onLlmStart?.(systemMessageContent, humanMessageContent);

                const finalPrompt = ChatPromptTemplate.fromMessages([
                    new SystemMessage(systemMessageContent),
                    new HumanMessage(humanMessageContent)
                ]);

                const finalChain = finalPrompt.pipe(this.finalLlm).pipe(new StringOutputParser());

                const stream = await finalChain.stream({});
                let fullReply = '';
                for await (const chunk of stream) {
                    fullReply += chunk;
                    callbacks.onLlmStream?.(chunk);
                }
                callbacks.onLlmEnd?.(fullReply);
                
                resolve(fullReply); // --- 修改点：用最终结果 resolve Promise ---

            } catch (error: any) {
                const err = error instanceof Error ? error : new Error(String(error));
                callbacks.onError?.(err);
                reject(err); // --- 修改点：用错误 reject Promise ---
            }
        });
    }

    private resolveInput(inputTemplate: string | Record<string, any>, context: Record<string, any>): any {
        // ... 此方法实现保持不变 ...
        if (typeof inputTemplate === 'string') {
            const match = inputTemplate.match(/^\{(\w+)\}$/);
            if (match && context[match[1]] !== undefined) {
                return context[match[1]];
            }
            return inputTemplate.replace(/\{(\w+)\}/g, (m, key) => {
                return context[key] !== undefined ? String(context[key]) : m;
            });
        }
        const resolvedObject: Record<string, any> = {};
        for (const key in inputTemplate) {
            const value = inputTemplate[key];
            resolvedObject[key] = this.resolveInput(value, context);
        }
        return resolvedObject;
    }

    private parseToolOutput(outputString: string): any {
        // ... 此方法实现保持不变 ...
        try {
            if ((outputString.startsWith('[') && outputString.endsWith(']')) || (outputString.startsWith('{') && outputString.endsWith('}'))) {
                return JSON.parse(outputString);
            }
        } catch (e) {}
        return outputString;
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/agents/executors/MapReduceExecutor.ts ---
// file_path: extension/agents/executors/MapReduceExecutor.ts
import * as vscode from 'vscode';
import * as path from 'path';
import * as yaml from 'js-yaml';
import { get_encoding, Tiktoken } from 'tiktoken';
import { v4 as uuidv4 } from 'uuid'; // 修正: 添加 import
import { HumanMessage, SystemMessage } from '@langchain/core/messages';
import { AgentContext } from '../AgentContext';
import { StringOutputParser } from '@langchain/core/output_parsers'; // 修正: 添加 import
<<<<<<< HEAD

// 定义执行器的统一返回类型
=======
import { ToolChainStep } from '../CustomAgentExecutor';

>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b
export interface ExecutorResult {
    finalContent: string;
    intermediateFiles?: { name: string; path: string }[];
}

<<<<<<< HEAD
// 接口定义
=======
// 为新的、更复杂的提示词结构定义接口
>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b
interface MapReducePrompt {
    title?: string;
    description?: string;
    input_variables: { name: string; description: string; type: string; default?: string }[];
<<<<<<< HEAD
=======
    tool_chain?: ToolChainStep[]; // 新增：预处理工具链
>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b
    map_prompt_template: { system: string; human: string };
    reduce_prompt_template: { system: string; human: string };
    max_tokens_per_batch?: number;
}

<<<<<<< HEAD
=======
// 定义文件数据结构，增加一个可选的 'type' 字段用于分类
>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b
interface FileData {
    path: string;
    content: string;
    tokenCount: number;
<<<<<<< HEAD
}

=======
    type?: 'simple' | 'complex';
}

// 定义一个阈值，用于区分简单文件和复杂文件
const COMPLEX_FILE_LINE_THRESHOLD = 100; // 行数超过150行的文件被认为是复杂的

>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b
// 辅助函数
async function getAllFilePaths(dirUri: vscode.Uri): Promise<vscode.Uri[]> {
    let files: vscode.Uri[] = [];
    const entries = await vscode.workspace.fs.readDirectory(dirUri);
    for (const [name, type] of entries) {
        const entryUri = vscode.Uri.joinPath(dirUri, name);
        if (type === vscode.FileType.File) {
            if (!name.startsWith('.') && !['node_modules', 'dist', 'out'].some(part => entryUri.path.includes(`/${part}/`))) {
                files.push(entryUri);
            }
        } else if (type === vscode.FileType.Directory) {
            if (!name.startsWith('.') && !['node_modules', 'dist', 'out'].includes(name)) {
                files = files.concat(await getAllFilePaths(entryUri));
            }
        }
    }
    return files;
}

export class MapReduceExecutor {
    constructor(private readonly context: AgentContext) { }

    public async run(runId: string, yamlContent: string, userInputs: Record<string, any>): Promise<ExecutorResult> {
<<<<<<< HEAD
        const { logger, llmService, modelConfig, runDir, statsTracker, performanceConfig } = this.context;
=======
        const { logger, llmService, toolRegistry, modelConfig, runDir, statsTracker, performanceConfig } = this.context;
>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b
        let tokenizer: Tiktoken | null = null;

        try {
            const prepTaskId = uuidv4();
            const prepStepName = "解析与准备";
            logger.onStepStart({ runId, taskId: prepTaskId, stepName: prepStepName, status: 'running' });

            const actionPrompt = yaml.load(yamlContent) as MapReducePrompt;
            const modulePath = userInputs['module_path'];
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders) throw new Error("未打开工作区文件夹。");

            const workspaceRoot = workspaceFolders[0].uri;
            const absoluteModulePath = vscode.Uri.joinPath(workspaceRoot, modulePath);
<<<<<<< HEAD
=======

            // 新增：执行预处理工具链
            const executionContext: Record<string, any> = { ...userInputs };
            if (actionPrompt.tool_chain) {
                const toolChainStepName = "预处理: 执行工具";
                const toolChainTaskId = uuidv4();
                logger.onStepStart({ runId, taskId: toolChainTaskId, stepName: toolChainStepName, status: 'running' });
                for (const step of actionPrompt.tool_chain) {
                    const tool = toolRegistry.getTool(step.tool);
                    if (!tool) throw new Error(`工具 "${step.tool}" 未找到。`);

                    const toolInput = this.resolveInput(step.input, executionContext);
                    logger.onStepUpdate({ runId, taskId: toolChainTaskId, type: 'input', data: { name: `工具输入: ${step.tool}`, content: toolInput } });
                    
                    const toolOutputString = await tool.call(toolInput) as string;
                    executionContext[step.output_variable] = toolOutputString;
                    
                    logger.onStepUpdate({ runId, taskId: toolChainTaskId, type: 'output', data: { name: `工具输出: ${step.tool}`, content: toolOutputString } });
                }
                logger.onStepEnd({ runId, taskId: toolChainTaskId, stepName: toolChainStepName, status: 'completed' });
            }

>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b
            const fileUris = await getAllFilePaths(absoluteModulePath);
            tokenizer = get_encoding("cl100k_base");

            const fileDataPromises = fileUris.map(async (uri): Promise<FileData> => {
                if (!tokenizer) throw new Error("Tokenizer not initialized.");
                const contentBytes = await vscode.workspace.fs.readFile(uri);
                const content = Buffer.from(contentBytes).toString('utf-8');
                return { path: path.relative(workspaceRoot.fsPath, uri.fsPath).replace(/\\/g, '/'), content, tokenCount: tokenizer.encode(content).length };
            });
            const allFiles = await Promise.all(fileDataPromises);
            const totalTokensInModule = allFiles.reduce((sum, file) => sum + file.tokenCount, 0);

<<<<<<< HEAD
=======
            const simpleFileCount = allFiles.filter(f => f.type === 'simple').length;
            const complexFileCount = allFiles.filter(f => f.type === 'complex').length;
            logger.onStepUpdate({ runId, taskId: prepTaskId, type: 'output', data: { name: "文件分类统计", content: `共 ${allFiles.length} 个文件。简单型: ${simpleFileCount}, 复杂型: ${complexFileCount} (阈值: ${COMPLEX_FILE_LINE_THRESHOLD} 行)` } });

>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b
            const MAX_TOKENS_PER_BATCH = actionPrompt.max_tokens_per_batch || performanceConfig.maxTokensPerBatch;
            const batches: { files: FileData[], tokenCount: number }[] = [];
            let currentBatch: FileData[] = [];
            let currentBatchTokens = 0;
            for (const file of allFiles) {
                if (file.tokenCount > MAX_TOKENS_PER_BATCH) { continue; }
                if (currentBatchTokens + file.tokenCount > MAX_TOKENS_PER_BATCH) {
                    batches.push({ files: currentBatch, tokenCount: currentBatchTokens });
                    currentBatch = [];
                    currentBatchTokens = 0;
                }
                currentBatch.push(file);
                currentBatchTokens += file.tokenCount;
            }
            if (currentBatch.length > 0) {
                batches.push({ files: currentBatch, tokenCount: currentBatchTokens });
            }
            logger.onStepUpdate({ runId, taskId: prepTaskId, type: 'output', data: { name: "文件清单Token分析", content: `当前模块包含 ${allFiles.length} 个文件 ${totalTokensInModule} 个token，超过阈值 ${MAX_TOKENS_PER_BATCH}，创建 ${batches.length} 个批次迭代分析` } });
            logger.onStepEnd({ runId, taskId: prepTaskId, stepName: prepStepName, status: 'completed' }); // 修正: 添加 stepName

            const mapAllTaskId = uuidv4();
            const mapStepName = "Map阶段: 并行分析";
            logger.onStepStart({ runId, taskId: mapAllTaskId, stepName: mapStepName, status: 'running' });


<<<<<<< HEAD
            const llm = await llmService.createModel({ modelConfig, temperature: 0.1, streaming: false });
=======
            const llm = await llmService.createModel({ modelConfig, temperature: 0.1, streaming: true });
>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b
            const mapAnalysisPromises = batches.map(async (batchInfo, i) => {
                const mapTaskName = `分析批次 ${i + 1}/${batches.length}`;
                // 现在可以访问每个批次的token数，并在日志中显示
                logger.onStepUpdate({ runId, taskId: mapAllTaskId, type: 'input', data: { name: `${mapTaskName} `, content: `包含 ${batchInfo.files.length} 个文件，共 ${batchInfo.tokenCount} tokens.` } });

                try {
<<<<<<< HEAD
                    const batchContent = batchInfo.files.map(f => `--- FILE: ${f.path} ---\n${f.content}`).join('\n\n');
                    const humanPrompt = actionPrompt.map_prompt_template.human.replace('{code_files_collection}', batchContent);
                    // logger.onStepUpdate({ runId, taskId: mapTaskId, type: 'llm-request', data: { system: actionPrompt.map_prompt_template.system, human: humanPrompt } });

                    const response = await llmService.scheduleLlmCall(() => llm.invoke([new SystemMessage(actionPrompt.map_prompt_template.system), new HumanMessage(humanPrompt)]));
                    const responseContent = response.content as string;
=======
                    // 在批次内再次分类，并为新的提示模板准备内容
                    const batchSimpleFiles = batchInfo.files.filter(f => f.type === 'simple');
                    const batchComplexFiles = batchInfo.files.filter(f => f.type === 'complex');

                    const simpleCollectionContent = batchSimpleFiles.map(f => `--- FILE: ${f.path} ---\n${f.content}`).join('\n\n');
                    const complexCollectionContent = batchComplexFiles.map(f => `--- FILE: ${f.path} ---\n${f.content}`).join('\n\n');

                    let humanPrompt = actionPrompt.map_prompt_template.human
                        .replace('{simple_files_collection}', simpleCollectionContent || '无')
                        .replace('{complex_files_collection}', complexCollectionContent || '无');
                    
                    const systemPrompt = actionPrompt.map_prompt_template.system;
                    
                    const responseContent = await llmService.scheduleLlmCall(async () => {
                        const stream = await llm.stream([new SystemMessage(systemPrompt), new HumanMessage(humanPrompt)]);
                        let fullReply = '';
                        for await (const chunk of stream) {
                            fullReply += chunk.content;
                        }
                        return fullReply;
                    });
>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b

                    // 在 Map 阶段的 LLM 调用后记录 Token
                    const fullMapPrompt = actionPrompt.map_prompt_template.system + "\n" + humanPrompt; // 估算，或者从 Langchain 内部获取更准确的
                    statsTracker.add(fullMapPrompt, responseContent);

                    logger.onStepUpdate({ runId, taskId: mapAllTaskId, type: 'output', data: { name: `${mapTaskName} 摘要结果`, content: responseContent } });
<<<<<<< HEAD
                    // logger.onStepEnd({ runId, taskId: mapTaskId, stepName: mapTaskName, status: 'completed' }); // 修正: 添加 stepName
                    return responseContent;
                } catch (e: any) {
                    // logger.onStepEnd({ runId, taskId: mapTaskId, stepName: mapTaskName, status: 'failed', error: e.message }); // 修正: 添加 stepName
=======
                    return responseContent;
                } catch (e: any) {
>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b
                    throw e;
                }
            });
            const mapResults = await Promise.all(mapAnalysisPromises);
            logger.onStepEnd({ runId, taskId: mapAllTaskId, stepName: mapStepName, status: 'completed' });

            const reduceTaskId = uuidv4();
            const reduceStepName = "Reduce阶段: 综合摘要";
            logger.onStepStart({ runId, taskId: reduceTaskId, stepName: reduceStepName, status: 'running' });

            const combinedMarkdownSummaries = mapResults.join("\n\n");

            const intermediateFiles: { name: string; path: string }[] = [];

            // 检查 runDir 是否存在。如果存在，说明是由 Orchestrator 调用的，需要保存中间文件。
            if (runDir) {
                const summaryFileName = 'map_phase_combined_summary.md';
                const summaryFilePath = vscode.Uri.joinPath(runDir, summaryFileName);
                await vscode.workspace.fs.writeFile(summaryFilePath, Buffer.from(combinedMarkdownSummaries, 'utf8'));

                // 将文件信息存入数组
                intermediateFiles.push({ name: 'Map阶段综合摘要', path: summaryFilePath.fsPath });
            }

            logger.onStepUpdate({
                runId,
                taskId: reduceTaskId,
                type: 'input',
                data: {
                    name: "Reduce阶段输入",
                    content: `摘要已合并 (长度: ${combinedMarkdownSummaries.length.toLocaleString()})，准备进行最终综合。`
                }
            });

            logger.onStepUpdate({ runId, taskId: reduceTaskId, type: 'input', data: { name: "所有摘要", content: combinedMarkdownSummaries } });

<<<<<<< HEAD
            const reduceLlm = await llmService.createModel({ modelConfig, temperature: 0.5, streaming: false });
            let humanReducePrompt = actionPrompt.reduce_prompt_template.human;
            for (const key in userInputs) {
                humanReducePrompt = humanReducePrompt.replace(new RegExp(`\\{${key}\\}`, 'g'), userInputs[key]);
            }
            humanReducePrompt = humanReducePrompt.replace('{combined_markdown_summaries}', combinedMarkdownSummaries);

            logger.onStepUpdate({ runId, taskId: reduceTaskId, type: 'llm-request', data: { system: actionPrompt.reduce_prompt_template.system, human: humanReducePrompt } });

            const reduceChain = reduceLlm.pipe(new StringOutputParser());
            const finalContent = await llmService.scheduleLlmCall(() =>
                reduceChain.invoke([new SystemMessage(actionPrompt.reduce_prompt_template.system), new HumanMessage(humanReducePrompt)])
            );
=======
            const reduceLlm = await llmService.createModel({ modelConfig, temperature: 0.5, streaming: true });
            // 更新 Reduce 阶段的提示填充逻辑，以包含所有需要的变量
            let humanReducePrompt = actionPrompt.reduce_prompt_template.human;
            for (const key in executionContext) {
                humanReducePrompt = humanReducePrompt.replace(new RegExp(`\\{${key}\\}`, 'g'), String(executionContext[key]));
            }
            humanReducePrompt = humanReducePrompt.replace('{combined_markdown_summaries}', combinedMarkdownSummaries);
            
            const systemReducePrompt = actionPrompt.reduce_prompt_template.system;
            logger.onStepUpdate({ runId, taskId: reduceTaskId, type: 'llm-request', data: { system: systemReducePrompt, human: humanReducePrompt } });

            const reduceChain = reduceLlm.pipe(new StringOutputParser());
            const finalContent = await llmService.scheduleLlmCall(async () => {
                const stream = await reduceChain.stream([new SystemMessage(systemReducePrompt), new HumanMessage(humanReducePrompt)]);
                let fullReply = '';
                for await (const chunk of stream) {
                    fullReply += chunk;
                }
                return fullReply;
            });
>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b

            const fullReducePrompt = actionPrompt.reduce_prompt_template.system + "\n" + humanReducePrompt; // 估算
            statsTracker.add(fullReducePrompt, finalContent);

            logger.onStepUpdate({ runId, taskId: reduceTaskId, type: 'output', data: { name: "最终文档", content: finalContent }, metadata: { type: 'markdown' } });
            logger.onStepEnd({ runId, taskId: reduceTaskId, stepName: reduceStepName, status: 'completed' }); // 修正: 添加 stepName

            return {
                finalContent,
                intermediateFiles
            };

        } catch (error: any) {
            const err = error instanceof Error ? error : new Error(String(error));
            throw err;
        } finally {
            if (tokenizer) {
                tokenizer.free();
            }
        }
    }
<<<<<<< HEAD
=======

    private resolveInput(inputTemplate: any, context: Record<string, any>): any {
        if (typeof inputTemplate === 'string') {
            const match = inputTemplate.match(/^\{(\w+)\}$/);
            if (match && context[match[1]] !== undefined) {
                return context[match[1]];
            }
            return inputTemplate.replace(/\{(\w+)\}/g, (m, key) => {
                return context[key] !== undefined ? String(context[key]) : m;
            });
        }
        if (typeof inputTemplate !== 'object' || inputTemplate === null) {
            return inputTemplate;
        }
        const resolvedObject: Record<string, any> = {};
        for (const key in inputTemplate) {
            const value = inputTemplate[key];
            resolvedObject[key] = this.resolveInput(value, context);
        }
        return resolvedObject;
    }
>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b
}

--------------------------------------------------------------------------------

--- file_path: extension/agents/executors/ToolChainExecutor.ts ---
// file_path: extension/agents/executors/ToolChainExecutor.ts
import * as vscode from 'vscode';
import * as yaml from 'js-yaml';
import { v4 as uuidv4 } from 'uuid';
import { ToolChainStep, LlmPromptTemplate } from '../CustomAgentExecutor';
import { AgentContext } from '../AgentContext';
import { SystemMessage, HumanMessage } from '@langchain/core/messages';
import { StringOutputParser } from '@langchain/core/output_parsers';
import { ExecutorResult } from './MapReduceExecutor'; // 导入统一的返回类型


interface ActionPrompt {
    tool_chain: ToolChainStep[];
    llm_prompt_template: LlmPromptTemplate;
}

export class ToolChainExecutor {
    constructor(private readonly context: AgentContext) { }

    public async run(runId: string, yamlContent: string, userInputs: Record<string, any>): Promise<ExecutorResult> {
        const { logger, llmService, toolRegistry, modelConfig, runDir, statsTracker } = this.context;
        let finalResult = '';

        try {
            const parseTaskId = uuidv4();
            const actionPrompt = yaml.load(yamlContent) as ActionPrompt;
            if (!actionPrompt.tool_chain || !actionPrompt.llm_prompt_template) {
                throw new Error("无效的Action Prompt YAML格式。缺少 'tool_chain' 或 'llm_prompt_template'。");
            }
            const executionContext: Record<string, any> = { ...userInputs };

            for (const step of actionPrompt.tool_chain) {
                const toolTaskId = uuidv4();
                const toolStepName = `执行工具`; // 使用这个作为 stepName
                logger.onStepStart({ runId, taskId: toolTaskId, stepName: toolStepName, status: 'running' });

                const tool = toolRegistry.getTool(step.tool);
                if (!tool) {
                    throw new Error(`工具 "${step.tool}" 未找到。`);
                }

                const toolInput = this.resolveInput(step.input, executionContext);
                logger.onStepUpdate({ runId, taskId: toolTaskId, type: 'input', data: { name: `工具输入 ${step.tool} `, content: toolInput } });

                const toolOutputString = await tool.call(toolInput) as string;
                const toolOutputParsed = this.parseToolOutput(toolOutputString);
                executionContext[step.output_variable] = toolOutputParsed;

                logger.onStepUpdate({ runId, taskId: toolTaskId, type: 'output', data: { name: `工具输出 ${step.tool} `, content: toolOutputString } });
                logger.onStepEnd({ runId, taskId: toolTaskId, stepName: toolStepName, status: 'completed' }); // 修正: 添加 stepName
            }

            const llmTaskId = uuidv4();
            const llmStepName = "生成最终响应";
            logger.onStepStart({ runId, taskId: llmTaskId, stepName: llmStepName, status: 'running' });

            const systemMessageContent = this.resolveInput(actionPrompt.llm_prompt_template.system, executionContext);
            const humanMessageContent = this.resolveInput(actionPrompt.llm_prompt_template.human, executionContext);

            const llmRequest = { system: systemMessageContent, human: humanMessageContent };
            logger.onStepUpdate({ runId, taskId: llmTaskId, type: 'llm-request', data: llmRequest });
            if (runDir) {
                await vscode.workspace.fs.writeFile(vscode.Uri.joinPath(runDir, 'llm_request.txt'), Buffer.from(`[SYSTEM]\n${systemMessageContent}\n\n[HUMAN]\n${humanMessageContent}`, 'utf8'));
            }

<<<<<<< HEAD
            const finalLlm = await llmService.createModel({ modelConfig, streaming: false, temperature: 0.7 });
            const finalChain = finalLlm.pipe(new StringOutputParser());

            // 修复：使用 llmService.scheduleLlmCall 来遵守速率限制
            finalResult = await llmService.scheduleLlmCall(() =>
                finalChain.invoke([new SystemMessage(systemMessageContent), new HumanMessage(humanMessageContent)])
            );
=======
            const finalLlm = await llmService.createModel({ modelConfig, streaming: true, temperature: 0.7 });
            const finalChain = finalLlm.pipe(new StringOutputParser());

            finalResult = await llmService.scheduleLlmCall(async () => {
                const stream = await finalChain.stream([new SystemMessage(systemMessageContent), new HumanMessage(humanMessageContent)]);
                let fullReply = '';
                for await (const chunk of stream) {
                    fullReply += chunk;
                }
                return fullReply;
            });
            
>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b
            console.log("finalResult", finalResult);
            // 修复：为 statsTracker 提供完整的 prompt
            statsTracker.add(systemMessageContent + "\n" + humanMessageContent, finalResult);

            logger.onStepUpdate({ runId, taskId: llmTaskId, type: 'output', data: { name: "LLM响应", content: finalResult }, metadata: { type: 'markdown' } });
            if (runDir) {
                await vscode.workspace.fs.writeFile(vscode.Uri.joinPath(runDir, 'llm_response.md'), Buffer.from(finalResult, 'utf8'));
            }
            logger.onStepEnd({ runId, taskId: llmTaskId, stepName: llmStepName, status: 'completed' }); // 修正: 添加 stepName

            return {
                finalContent: finalResult,
                intermediateFiles: [] // ToolChainExecutor 通常没有需要特别返回的中间文件
            };

        } catch (error: any) {
            const err = error instanceof Error ? error : new Error(String(error));
            // 如果错误发生在特定步骤，应该在该步骤的 catch 中记录 onStepEnd(failed)
            // 这里的 throw 会被 AgentService 捕获并调用 onAgentEnd(failed)
            throw err;
        }
    }

    private resolveInput(inputTemplate: any, context: Record<string, any>): any {
        if (typeof inputTemplate === 'string') {
            const match = inputTemplate.match(/^\{(\w+)\}$/);
            if (match && context[match[1]] !== undefined) {
                return context[match[1]];
            }
            return inputTemplate.replace(/\{(\w+)\}/g, (m, key) => {
                return context[key] !== undefined ? String(context[key]) : m;
            });
        }
        if (typeof inputTemplate !== 'object' || inputTemplate === null) {
            return inputTemplate;
        }
        const resolvedObject: Record<string, any> = {};
        for (const key in inputTemplate) {
            const value = inputTemplate[key];
            resolvedObject[key] = this.resolveInput(value, context);
        }
        return resolvedObject;
    }

    private parseToolOutput(outputString: string): any {
        try {
            if ((outputString.startsWith('[') && outputString.endsWith(']')) || (outputString.startsWith('{') && outputString.endsWith('}'))) {
                return JSON.parse(outputString);
            }
        } catch (e) { }
        return outputString;
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/agents/orchestrators/ProjectDocumentationOrchestrator.ts ---
// file_path: extension/agents/orchestrators/ProjectDocumentationOrchestrator.ts
import * as vscode from 'vscode';
import * as path from 'path';
import * as yaml from 'js-yaml';
import { get_encoding, Tiktoken } from 'tiktoken';
import { v4 as uuidv4 } from 'uuid';
import { BaseMessage, HumanMessage } from '@langchain/core/messages';
import { StringOutputParser } from '@langchain/core/output_parsers';
import { AgentContext } from '../AgentContext';
import { MapReduceExecutor, ExecutorResult } from '../executors/MapReduceExecutor';
import { ToolChainExecutor } from '../executors/ToolChainExecutor';

// 接口定义
interface Module {
    name: string;
    path: string;
    description: string;
    normalizedPath?: string;
}

interface PlannerOutput {
    projectName: string;
    language: string;
    modules: Module[];
}

// 为规划器YML文件定义一个更明确的接口
interface PlannerPromptFile {
    title: string;
    description: string;
    config?: {
        max_tokens_for_direct_analysis?: number;
    };
    llm_prompt_template: {
        system: string;
        human: string;
    };
}

interface ModuleDoc extends Module {
    content: string;
}

interface PromptsCollection {
    plannerPrompt: string;
    directAnalysisPrompt: string;
    mapReduceAnalysisPrompt: string;
    synthesisPrompt: string;
}

export class ProjectDocumentationOrchestrator {
    private maxTokensForDirectAnalysis!: number;
    private tokenizer!: Tiktoken;
    private runDir!: vscode.Uri;

    constructor(
        private readonly context: AgentContext,
        private readonly prompts: PromptsCollection
    ) {
        this.maxTokensForDirectAnalysis = this.context.performanceConfig.maxTokensForDirectAnalysis;
    }


    public async run(runId: string, sourcePath: string) {

        this.tokenizer = get_encoding("cl100k_base");

        const { logger } = this.context;
        logger.show(true);

        const workspaceRoot = vscode.workspace.workspaceFolders?.[0].uri;
        if (!workspaceRoot) {
            throw new Error("请先打开一个工作区文件夹。");
        }

        // 移除 try/catch, 让错误向上冒泡到 AgentService
        const runFolderName = `doc-gen_${new Date().toISOString().replace(/[:.]/g, '-')}`;
        this.runDir = vscode.Uri.joinPath(workspaceRoot, '.codewiki', 'runs', runFolderName);
        await vscode.workspace.fs.createDirectory(this.runDir);
        logger.info(`日志和结果将保存在: ${this.runDir.fsPath}`);

        logger.info(`开始分析项目文档，目标路径: '${sourcePath}'`);


        const plan = await this.runPlanningPhase(runId, sourcePath);
        const moduleDocs = await this.runModuleAnalysisPhase(runId, plan);
        const finalDoc = await this.runSynthesisPhase(runId, plan, moduleDocs);

        await this.saveFinalDocument(finalDoc);

        // 移除 onAgentEnd 调用。AgentService 将负责此事
        // logger.onAgentEnd({ runId, status: 'completed', finalOutput: "执行成功" });

        if (this.tokenizer) {
            this.tokenizer.free();
        }
    }


    private async runPlanningPhase(runId: string, sourcePath: string): Promise<PlannerOutput> {

        const { logger, toolRegistry, llmService, modelConfig, statsTracker } = this.context; // <-- 添加 statsTracker
        const taskId = uuidv4();
        const stepName = "规划: 分析项目结构"; // This is the stepName
        logger.onStepStart({ runId, taskId, stepName, status: 'running' });

        // 解析 YAML 文件并读取配置
        const plannerPromptFile = yaml.load(this.prompts.plannerPrompt) as PlannerPromptFile;
        if (plannerPromptFile.config?.max_tokens_for_direct_analysis) {
            this.maxTokensForDirectAnalysis = plannerPromptFile.config.max_tokens_for_direct_analysis;
            logger.info(`从 project_planner.yml 加载配置: max_tokens_for_direct_analysis = ${this.maxTokensForDirectAnalysis}`);
        }

        const treeTool = toolRegistry.getTool('get_directory_tree')!;

        const fileTree = await treeTool.call({ path: sourcePath, language: 'unknown' }) as string;

        logger.onStepUpdate({ runId, taskId, type: 'input', data: { name: "文件树", content: fileTree } });

<<<<<<< HEAD
        const plannerLlm = await llmService.createModel({ modelConfig, temperature: 0.1 });
=======
        const plannerLlm = await llmService.createModel({ modelConfig, temperature: 0.1, streaming: true });
>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b
        const plannerPromptTemplate = (yaml.load(this.prompts.plannerPrompt) as any).llm_prompt_template.human;
        const prompt = plannerPromptTemplate.replace('{file_tree}', fileTree);
        logger.onStepUpdate({ runId, taskId, type: 'llm-request', data: { system: "...", human: prompt } });

        await vscode.workspace.fs.writeFile(
            vscode.Uri.joinPath(this.runDir, '01_planning_request.txt'),
            Buffer.from(prompt, 'utf8')
        );

<<<<<<< HEAD
        const response = await llmService.scheduleLlmCall(() => plannerLlm.invoke([new HumanMessage(prompt)]));
        const responseContent = response.content as string;
=======
        const responseContent = await llmService.scheduleLlmCall(async () => {
            const stream = await plannerLlm.stream([new HumanMessage(prompt)]);
            let fullReply = '';
            for await (const chunk of stream) {
                fullReply += chunk.content;
            }
            return fullReply;
        });

>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b

        statsTracker.add(prompt, responseContent); // 记录 Token

        await vscode.workspace.fs.writeFile(
            vscode.Uri.joinPath(this.runDir, '01_planning_response.txt'),
            Buffer.from(responseContent, 'utf8')
        );

        try {
            const jsonString = responseContent.match(/\{[\s\S]*\}/)?.[0];
            if (!jsonString) throw new Error("大模型未能返回有效的JSON规划。");

            const plan = JSON.parse(jsonString) as PlannerOutput;

            logger.onStepUpdate({ runId, taskId, type: 'output', data: { name: "项目规划", content: plan } });

            logger.onStepEnd({ runId, taskId, stepName, status: 'completed' });

            return plan;
        } catch (e: any) {

            const errorMessage = e instanceof Error ? e.message : String(e);
            logger.onStepEnd({ runId, taskId, stepName, status: 'failed', error: errorMessage });

            throw new Error(`解析规划输出失败: ${e.message}`);
        }
    }


    private async runModuleAnalysisPhase(runId: string, plan: PlannerOutput): Promise<ModuleDoc[]> {
        const { logger, toolRegistry } = this.context;
        const workspaceRoot = vscode.workspace.workspaceFolders?.[0].uri;
        if (!workspaceRoot) {
            throw new Error("No workspace folder open.");
        }

        // 步骤 1: 路径验证和去重（和之前一样）
        const filterStepName = "过滤和验证模块";
        const filterTaskId = uuidv4();
        logger.onStepStart({ runId, taskId: filterTaskId, stepName: filterStepName, status: 'running' });
        // --- (这部分路径检查和去重逻辑保持不变) ---
        const pathCheckPromises = plan.modules.map(async (m) => {
            const modulePath = m.path.trim();
            if (modulePath === '.' || modulePath === './' || modulePath === '' || modulePath === '/') {
                logger.warn(`- 已跳过模块 '${m.name}' (路径: '${m.path}'), 因其指向根目录。`);
                return null;
            }
            try {
                const absoluteUri = vscode.Uri.joinPath(workspaceRoot, modulePath);
                const stat = await vscode.workspace.fs.stat(absoluteUri);
                if (stat.type !== vscode.FileType.Directory) {
                    logger.warn(`- 已跳过模块 '${m.name}' (路径: '${m.path}'), 因其指向单个文件而非目录。`);
                    return null;
                }
                return m;
            } catch (error) {
                logger.warn(`- 已跳过模块 '${m.name}' (路径: '${m.path}'), 因路径不存在。`);
                return null;
            }
        });
        const validDirectoryModules = (await Promise.all(pathCheckPromises)).filter((m): m is Module => m !== null);
        let modulesWithNormalizedPath = validDirectoryModules.map(m => ({
            ...m,
            normalizedPath: m.path.trim().replace(/^\.?[\\\/]/, '').replace(/[\\\/]$/, '')
        }));
        const finalModulesPreFilter: Module[] = [];
        const candidatePaths = new Set(modulesWithNormalizedPath.map(m => m.normalizedPath).filter((p): p is string => !!p));
        const pathsToRemove = new Set<string>();
        for (const path1 of candidatePaths) {
            for (const path2 of candidatePaths) {
                if (path1 !== path2 && path2.startsWith(path1 + '/')) {
                    pathsToRemove.add(path1);
                }
            }
        }
        const pathsToKeep = new Set([...candidatePaths].filter(p => !pathsToRemove.has(p)));
        for (const module of modulesWithNormalizedPath) {
            if (module.normalizedPath && pathsToKeep.has(module.normalizedPath)) {
                finalModulesPreFilter.push(module);
            } else if (module.normalizedPath) {
                 logger.warn(`- 跳过模块 '${module.name}' (路径: '${module.path}'), 因其是另一个更具体模块的父目录或路径无效。`);
            }
        }
        
        // 步骤 2: 对去重后的模块进行内容预计算和Token过滤
        const contentTool = this.context.toolRegistry.getTool('get_all_files_content') as any;
        const moduleDetailsPromises = finalModulesPreFilter.map(async (module) => {
            const content = await contentTool.call({ path: module.path, language: plan.language }) as string;
            const tokenCount = this.tokenizer.encode(content).length;
            return { ...module, content, tokenCount };
        });

        const allModuleDetails = await Promise.all(moduleDetailsPromises);

        const MIN_TOKEN_THRESHOLD = 1000;
        const analyzableModules = allModuleDetails.filter(details => {
            if (details.tokenCount < MIN_TOKEN_THRESHOLD) {
                logger.info(`- 已过滤模块 '${details.name}' (路径: '${details.path}'), 因其 Token 数 (${details.tokenCount}) 小于 ${MIN_TOKEN_THRESHOLD}。`);
                return false;
            }
            return true;
        });

        const finalPlan: PlannerOutput = {
            ...plan,
            // 只保留通过了所有过滤的模块
            modules: analyzableModules.map(({ content, tokenCount, normalizedPath, ...rest }) => rest)
        };

        // 步骤 3: 将最终确认的、过滤后的计划写入文件
        await vscode.workspace.fs.writeFile(
            vscode.Uri.joinPath(this.runDir, 'plan.json'),
            Buffer.from(JSON.stringify(finalPlan, null, 2), 'utf8')
        );

        const originalCount = plan.modules.length;
        const finalCount = analyzableModules.length;
        if (finalCount < originalCount) {
            const skippedCount = originalCount - finalCount;
            logger.info(`- 过滤完成，共跳过 ${skippedCount} 个无效、重叠或Token过少的模块。`);
        } else {
            logger.info(`- 所有模块均有效，将分析全部 ${finalCount} 个模块。`);
        }
        logger.onStepUpdate({ runId, taskId: filterTaskId, type: 'output', data: { name: "最终模块列表", content: `已过滤，将分析 ${finalCount} 个模块。` } });
        logger.onStepEnd({ runId, taskId: filterTaskId, stepName: filterStepName, status: 'completed' });
        
        // 如果所有模块都被过滤掉了，直接返回空数组
        if (analyzableModules.length === 0) {
            return [];
        }

        // 步骤 4: 对过滤后的模块列表进行并行分析
        const analysisStepName = "分析: 并行处理模块";
        logger.info(`[DEBUG] Attempting to start parent step: ${analysisStepName}`);
        logger.onStepStart({ runId, stepName: analysisStepName, status: 'running' });

        const analysisPromises = analyzableModules.map((moduleWithDetails, index) =>
            this.analyzeSingleModule(
                runId,
                moduleWithDetails, // 传递整个对象
                plan.language,
                index + 1,
                analyzableModules.length,
                moduleWithDetails.content,    // 传递预计算的内容
                moduleWithDetails.tokenCount  // 传递预计算的Token数
            )
        );
        const results = await Promise.all(analysisPromises);
        logger.onStepEnd({ runId, stepName: analysisStepName, status: 'completed' });
        return results;
    }

    private async analyzeSingleModule(
        runId: string,
        module: Module,
        language: string,
        index: number,
        total: number,
        allContent: string, // 新增参数
        tokenCount: number  // 新增参数
    ): Promise<ModuleDoc> {
<<<<<<< HEAD
    // --- highlight-end ---
=======
>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b
        const { logger } = this.context;
        const taskId = uuidv4();
        const stepName = `分析模块: '${module.name}' (${index}/${total})`;
        logger.info(`[DEBUG] Attempting to start sub-step: ${stepName} with taskId: ${taskId}`);
        logger.onStepStart({ runId, taskId, stepName, status: 'running' });

        const moduleAnalysisDir = vscode.Uri.joinPath(this.runDir, `module_${module.path.replace(/[\/\\]/g, '_')}`);
        await vscode.workspace.fs.createDirectory(moduleAnalysisDir);

        const moduleContext: AgentContext = { ...this.context, runDir: moduleAnalysisDir };

        // --- highlight-start ---
        // 移除内部的文件读取和Token计算，因为它们已经作为参数传入
        // const contentTool = this.context.toolRegistry.getTool('get_all_files_content') as any;
        // const allContent = await contentTool.call({ path: module.path, language }) as string;
        // const tokenCount = this.tokenizer.encode(allContent).length;
        // --- highlight-end ---

        let executor: ToolChainExecutor | MapReduceExecutor;
        let promptYaml: string;
        let strategy: string;

        let strategyLogContent = `模块路径: ${module.path}\n`;

        if (tokenCount <= this.maxTokensForDirectAnalysis) {
            strategy = "直接分析 (ToolChain)";
            executor = new ToolChainExecutor(moduleContext);
            promptYaml = this.prompts.directAnalysisPrompt;
            strategyLogContent += `Token总数: ${tokenCount.toLocaleString()} 未超出最大Token数 ${this.maxTokensForDirectAnalysis.toLocaleString()} 限制\n`;
            strategyLogContent += `采用全量分析策略，请稍后...`;
        } else {
            strategy = "Map-Reduce分析";
            executor = new MapReduceExecutor(moduleContext);
            const estimatedBatches = Math.ceil(tokenCount / this.maxTokensForDirectAnalysis);
            promptYaml = this.prompts.mapReduceAnalysisPrompt;
            strategyLogContent += `Token总数: ${tokenCount.toLocaleString()} 超出最大Token数 ${this.maxTokensForDirectAnalysis} 限制\n`;
            strategyLogContent += `采用Map-Reduce分析策略，预计分 ${estimatedBatches} 个批次，因涉及多个迭代，分析时间稍长，请稍后...`;
        }

        logger.onStepUpdate({
            runId,
            taskId,
            type: 'input',
            data: {
                name: "分析策略",
                content: strategyLogContent
            }
        });
        try {
            // 将完整的模块路径传递给执行器
            const result: ExecutorResult = await executor.run(runId, promptYaml, { module_path: module.path, language, task_description: module.description });
            const docContent = result.finalContent;
            const docPath = vscode.Uri.joinPath(this.runDir, `module_${module.name.replace(/[\s\/]/g, '_')}.md`);
            await vscode.workspace.fs.writeFile(docPath, Buffer.from(docContent, 'utf8'));

            if (result.intermediateFiles && result.intermediateFiles.length > 0) {
                for (const file of result.intermediateFiles) {
                    logger.onStepUpdate({
                        runId,
                        taskId,
                        type: 'output',
                        data: { name: file.name, content: `文件已生成: ${path.basename(file.path)}` },
                        metadata: { type: 'file', path: file.path }
                    });
                }
            }
            logger.onStepUpdate({
                runId,
                taskId,
                type: 'output',
                data: { name: "模块文档", content: `文档已生成: ${path.basename(docPath.fsPath)}` },
                metadata: { type: 'file', path: docPath.fsPath }
            });
            logger.onStepEnd({ runId, taskId, stepName, status: 'completed' });
            return { ...module, content: docContent };
        } catch (e: any) {

            const errorMessage = e instanceof Error ? e.message : String(e);
            logger.onStepEnd({ runId, taskId, stepName, status: 'failed', error: errorMessage });

            throw e;
        }
    }

    /**
     * 清洗并重编号单个模块的Markdown文档。
     * @param rawContent 原始Markdown内容。
     * @param newParentSectionNumber 新的父章节号，如 "3.3"。
     * @returns 处理后的Markdown内容。
     */
    private cleanAndRenumberModuleDoc(rawContent: string, newParentSectionNumber: string): string {
        // 1. 清洗：只保留第一个'#'标题之后的内容
        const firstHeadingIndex = rawContent.indexOf('#');
        if (firstHeadingIndex === -1) {
            return ''; // 如果没有标题，则视为空内容
        }
        const content = rawContent.substring(firstHeadingIndex);
        const lines = content.split('\n');

        // 2. 提取原始主标题，并创建新的、重编号的主标题
        const originalTitleLine = lines.shift() || '';
        const title = originalTitleLine.replace(/^#\s*/, '').trim();
        const newMainHeading = `# ${newParentSectionNumber}. ${title}`;

        // 3. 重编号所有子标题
        const body = lines.join('\n');
        const renumberedBody = body.replace(
            /^(#+)\s(\d[\d\.]*)/gm, // 匹配所有级别的标题，如 '## 1. ...' 或 '### 1.2. ...'
            (match, hashes, oldNumbering) => {
                // 将标题降一级（增加一个'#'），并用新的父章节号作为前缀
                return `#${hashes} ${newParentSectionNumber}.${oldNumbering}`;
            }
        );

        return `${newMainHeading}\n${renumberedBody}`;
    }

    private async runSynthesisPhase(runId: string, plan: PlannerOutput, moduleDocs: ModuleDoc[]): Promise<string> {
        const { logger, llmService, modelConfig, statsTracker } = this.context;
        const taskId = uuidv4();
        const stepName = "综合: 生成最终文档";
        logger.onStepStart({ runId, taskId, stepName, status: 'running' });

        // --- 步骤 1: 生成文档框架 ---
<<<<<<< HEAD
        const synthesisLlm = await llmService.createModel({ modelConfig, temperature: 0.4, streaming: false });
=======
        const synthesisLlm = await llmService.createModel({ modelConfig, temperature: 0.4, streaming: true });
>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b
        const synthesisPromptTemplate = (yaml.load(this.prompts.synthesisPrompt) as any).llm_prompt_template.human;
        const moduleOverviews = moduleDocs.map(m => `- **${m.name} (${m.path})**: ${m.description}`).join('\n');
        
        // 关键改动：不将详细文档传给LLM，让它只生成框架
        const prompt = synthesisPromptTemplate
            .replace('{projectName}', plan.projectName)
            .replace('{language}', plan.language)
            .replace('{module_overviews}', moduleOverviews)
            .replace('{detailed_module_docs}', '<!-- 模块详细设计将由程序自动拼接 -->');

        logger.onStepUpdate({ runId, taskId, type: 'llm-request', data: { system: "...", human: prompt }});
        await vscode.workspace.fs.writeFile(
            vscode.Uri.joinPath(this.runDir, '03_synthesis_request.txt'),
            Buffer.from(prompt, 'utf8')
        );

        const chain = synthesisLlm.pipe(new StringOutputParser());
<<<<<<< HEAD
        const wrapperDoc = await chain.invoke([new HumanMessage(prompt)]);
=======
        const wrapperDoc = await llmService.scheduleLlmCall(async () => {
            const stream = await chain.stream([new HumanMessage(prompt)]);
            let fullReply = '';
            for await (const chunk of stream) {
                fullReply += chunk;
            }
            return fullReply;
        });

>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b
        statsTracker.add(prompt, wrapperDoc);

         // 步骤 2: 准备拼接模块文档
        const processedModuleDocs = moduleDocs.map((doc, index) => {
            const parentSectionNumber = `3.${3 + index}`; // 生成 3.3, 3.4, ...
            return this.cleanAndRenumberModuleDoc(doc.content, parentSectionNumber);
        });
        const combinedModuleDocsString = processedModuleDocs.join('\n\n---\n\n');

        // 步骤 3: 找到插入点并拼接
        const splitMarker = '\n# 4. 接口设计';
        const splitIndex = wrapperDoc.indexOf(splitMarker);
        
        let finalDoc: string;

        if (splitIndex !== -1) {
            // 找到了插入点
            let docPart1 = wrapperDoc.substring(0, splitIndex);
            const docPart2 = wrapperDoc.substring(splitIndex);

            // 清理掉 part1 末尾可能存在的占位符
            docPart1 = docPart1.replace(/##\s*3\.3\s*模块详细设计[\s\S]*/, '').trim();

            finalDoc = [
                docPart1,
                combinedModuleDocsString,
                docPart2
            ].join('\n\n');
        } else {
            // 如果没找到第4节，作为回退，直接在末尾拼接
            logger.warn("在文档框架中未找到'# 4. 接口设计'，将模块文档追加到末尾。");
            finalDoc = [
                wrapperDoc,
                combinedModuleDocsString
            ].join('\n\n---\n\n');
        }
        
        await vscode.workspace.fs.writeFile(
            vscode.Uri.joinPath(this.runDir, '03_synthesis_response.txt'),
            Buffer.from(finalDoc, 'utf8')
        );

        const finalDocPath = await this.getFinalDocPath();
        logger.onStepUpdate({ 
            runId, 
            taskId, 
            type: 'output', 
            data: { name: "最终项目文档", content: `文档已生成: ${path.basename(finalDocPath.fsPath)}` },
            metadata: { type: 'file', path: finalDocPath.fsPath }
        });

        logger.onStepEnd({ runId, taskId, stepName, status: 'completed' });
        return finalDoc;
    }

    private async saveFinalDocument(content: string) {
        const finalDocPath = vscode.Uri.joinPath(this.runDir, '项目总体设计文档.md');
        await vscode.workspace.fs.writeFile(finalDocPath, Buffer.from(content, 'utf8'));

        vscode.window.showInformationMessage(`文档已保存至: ${finalDocPath.fsPath}`, '打开文件').then(selection => {
            if (selection === '打开文件') {
                vscode.window.showTextDocument(finalDocPath);
            }
        });
    }

    private async getFinalDocPath(): Promise<vscode.Uri> {
        return vscode.Uri.joinPath(this.runDir, '项目总体设计文档.md');
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/config/fileFilters.ts ---
// src/extension/config/fileFilters.ts

/**
 * Defines a language's file filtering rules.
 */
export interface LanguageFilter {
    // Included file extensions
    include: string[];
    // Specific files or patterns to explicitly exclude
    exclude: string[];
}

/**
 * Generic exclusion list, applicable to all languages and projects.
 */
export const GENERIC_EXCLUDE = [
    'node_modules',
    'dist',
    'out',
    'build',
    'target', // Common for Java (Maven/Gradle)
    'bin',
    'vendor',
    '.git',
    '.svn',
    '.hg',
    '__pycache__',
    '.vscode',
    '.idea',
    'package-lock.json',
    'yarn.lock',
    'pnpm-lock.yaml',
    'go.sum',
    '.DS_Store'
];

/**
 * Language-specific filtering rules.
 */
export const languageFilters: Record<string, LanguageFilter> = {
    typescript: {
        include: ['.ts', '.tsx'],
        exclude: ['.d.ts', '.spec.ts', '.test.ts'],
    },
    javascript: {
        include: ['.js', '.jsx'],
        exclude: ['.spec.js', '.test.js'],
    },
    python: {
        include: ['.py'],
        exclude: [],
    },
    go: {
        include: ['.go'],
        exclude: ['_test.go'],
    },
    
    java: {
        include: ['.java'],
        // Java testing is typically directory-based (src/test/java),
        // which is handled by module selection rather than file-level filtering.
        exclude: [], 
    },
    c: {
        // Headers (.h) are crucial for understanding interfaces and must be included.
        include: ['.c', '.h'],
        exclude: [],
    },
    cpp: { // Using 'cpp' as the key for C++
        // C++ has various extensions for source and header files.
        // Including the most common ones. Headers are critical.
        include: ['.cpp', '.hpp', '.cc', '.cxx', '.h'],
        exclude: [],
    },
    
    unknown: { // Default rule when language isn't identified
        include: [
            '.ts', '.tsx', '.js', '.jsx', '.py', '.go', 
            
            '.java', '.c', '.h', '.cpp', '.hpp', '.cc', '.cxx', 
            
            '.cs', '.rb', '.php', '.rs'
        ],
        exclude: ['.spec.ts', '.test.ts', '.spec.js', '.test.js', '_test.go'],
    }
};
<<<<<<< HEAD
=======

--------------------------------------------------------------------------------

--- file_path: extension/extension.ts ---
// src/extension/extension.ts (修改后完整文件)

import * as vscode from 'vscode';
import { CodeWikiViewProvider } from './CodeWikiViewProvider';
import { StateManager } from './StateManager';
import { LLMService } from './services/LLMService';
import { AgentService } from './services/AgentService';
import { init } from 'tiktoken/init';

/**
 * 检查并确保提示词文件已复制到用户工作区的 .codewiki 目录中。
 * 如果 .codewiki 目录或其中的提示词文件不存在，则会创建它们。
 * @param context 扩展上下文，用于获取插件的安装路径。
 */
async function ensurePromptsAreCopied(context: vscode.ExtensionContext): Promise<void> {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders || workspaceFolders.length === 0) {
        // 没有打开的工作区，无需执行任何操作
        return;
    }
    const workspaceRoot = workspaceFolders[0].uri;
    const codewikiDir = vscode.Uri.joinPath(workspaceRoot, '.codewiki');
    const sourcePromptsDir = vscode.Uri.joinPath(context.extensionUri, 'dist', 'prompts');

    try {
        // 检查 .codewiki 目录是否存在
        await vscode.workspace.fs.stat(codewikiDir);
    } catch (error) {
        // 如果目录不存在 (FileNotFound error)，则创建它
        if (error instanceof vscode.FileSystemError && error.code === 'FileNotFound') {
            console.log("'.codewiki' directory not found. Creating it and copying prompts...");
            await vscode.workspace.fs.createDirectory(codewikiDir);
        } else {
            // 对于其他错误，打印并重新抛出
            console.error("Error checking .codewiki directory:", error);
            throw error;
        }
    }

    // 无论目录是已存在还是刚创建，都检查并复制所有提示词文件
    try {
        const bundledPromptFiles = await vscode.workspace.fs.readDirectory(sourcePromptsDir);
        for (const [fileName, fileType] of bundledPromptFiles) {
            if (fileType === vscode.FileType.File) {
                const sourceUri = vscode.Uri.joinPath(sourcePromptsDir, fileName);
                const targetUri = vscode.Uri.joinPath(codewikiDir, fileName);

                try {
                    // 尝试访问目标文件，如果不存在则会抛出错误
                    await vscode.workspace.fs.stat(targetUri);
                } catch {
                    // 文件不存在，执行复制操作
                    console.log(`Prompt file '${fileName}' not found in .codewiki. Copying...`);
                    await vscode.workspace.fs.copy(sourceUri, targetUri);
                }
            }
        }
    } catch (e) {
        console.error("Failed to copy prompt files:", e);
        vscode.window.showErrorMessage("CodeWiki: Failed to initialize required prompt files. Please try reloading the window.");
    }
}

// --- 新增：tiktoken 初始化函数 ---
async function initializeTiktoken(context: vscode.ExtensionContext): Promise<void> {
    try {
        // 构建 WASM 文件在扩展安装目录中的绝对路径
        const wasmUri = vscode.Uri.joinPath(context.extensionUri, 'dist', 'tiktoken_bg.wasm');
        
        // 读取 WASM 文件的二进制内容
        const wasmBytes = await vscode.workspace.fs.readFile(wasmUri);

        // 初始化 tiktoken
        await init((imports) => WebAssembly.instantiate(wasmBytes, imports));
        console.log("tiktoken initialized successfully.");

    } catch (err) {
        console.error("Failed to initialize tiktoken:", err);
        // 这是一个严重错误，可以考虑向用户显示一个错误消息
        vscode.window.showErrorMessage("CodeWiki: Failed to load a critical component (tiktoken). Token counting will not work.");
        // 你可以选择在这里抛出错误，以阻止插件继续加载
        throw err;
    }
}


export async function activate(context: vscode.ExtensionContext) {
    // --- 新增：最先执行 tiktoken 初始化 ---
    await initializeTiktoken(context);

    // --- 新增：在所有服务初始化之前，确保提示词已就绪 ---
    await ensurePromptsAreCopied(context);
    // --------------------------------------------------

    // --- 服务初始化 ---
    const stateManager = new StateManager(context.globalState);
    const llmService = new LLMService();
    const agentService = new AgentService(llmService, stateManager); 

    // 获取默认模型并初始化服务
    const modelConfigs = await stateManager.getModelConfigs();
    const defaultConfig = modelConfigs.find(c => c.isDefault) || modelConfigs[0];
    if (defaultConfig) {
        await agentService.initialize(defaultConfig);
    } else {
        console.warn("No default model config found. Agent Service might not function correctly.");
    }
    // --- 结束服务初始化 ---

    // 首次激活时，也应用一次性能配置
    const perfConfig = await stateManager.getPerformanceConfig();
    llmService.concurrencyLimit = perfConfig.concurrencyLimit;
    llmService.minInterval = perfConfig.minInterval;

    const provider = new CodeWikiViewProvider(context.extensionUri, context, agentService); // <-- 注入 AgentService

    context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(CodeWikiViewProvider.viewType, provider)
    );

    // --- 命令注册 ---
    const generateProjectDocDisposable = vscode.commands.registerCommand('codewiki.generateProjectDocumentation', async () => {
        const modelConfigs = await stateManager.getModelConfigs();
        const defaultConfig = modelConfigs.find(c => c.isDefault) || modelConfigs[0];
            
        if (!defaultConfig) {
            vscode.window.showErrorMessage("No default model configuration found. Please configure a model in the CodeWiki settings.");
            return;
        }

        // 调用变得非常简单
        await agentService.runProjectDocumentation(defaultConfig);
    });
    
    context.subscriptions.push(generateProjectDocDisposable);

    // 移除了旧的 codewiki.runAgent 命令，因为它的逻辑已经被新的架构和Webview触发器所取代。
}

export function deactivate() {}

--------------------------------------------------------------------------------

--- file_path: extension/services/AgentService.ts ---
// src/extension/services/AgentService.ts (完整文件)

import * as vscode from 'vscode';
import { v4 as uuidv4 } from 'uuid';
import { ModelConfig, AgentPlan, PerformanceConfig } from '../../common/types';
import { StateManager } from '../StateManager';
import { AgentContext } from '../agents/AgentContext';
import { ProjectDocumentationOrchestrator } from '../agents/orchestrators/ProjectDocumentationOrchestrator';
import { ToolChainExecutor } from '../agents/executors/ToolChainExecutor';
import { MapReduceExecutor } from '../agents/executors/MapReduceExecutor';
import { AgentLogger, VscodeOutputChannelLogger, WebviewLogger } from './logging';
import { LLMService } from './LLMService';
import { ToolRegistry } from './ToolRegistry';
import { StatsTracker } from './StatsTracker';

// 在文件顶部或一个新文件中定义Agent元数据
/**
 * Agent元数据定义。
 * 这是所有可用Agent的“注册表”，定义了它们的ID、名称、步骤和所需参数。
 */
const AGENT_DEFINITIONS: Record<string, AgentPlan> = {
    'docgen-project': {
        agentId: 'docgen-project',
        agentName: '项目级文档生成',
        steps: [
            { name: "规划: 分析项目结构", description: "使用LLM分析文件树，识别核心模块。", promptFiles: ['project_planner.yml'] },
            { name: "分析: 并行处理模块", description: "对每个模块进行深入分析，可能使用直接或Map-Reduce策略。", promptFiles: ['module_analysis_direct.yml', 'module_analysis_mapreduce.yml'] },
            { name: "综合: 生成最终文档", description: "将所有模块的分析结果汇编成一篇完整的技术文档。", promptFiles: ['project_synthesis.yml'] }
        ],
        parameters: [
            { 
                name: 'source_path', 
                description: '要分析的源代码根目录（相对于工作区根目录）', 
                type: 'path',
                value: '.' // 默认值为项目根目录
            }
        ]
    },
    'docgen-module-direct': {
        agentId: 'docgen-module-direct',
        agentName: '模块级文档 (直接分析)',
        steps: [
            { name: "执行工具", description: "按顺序执行文件读取和分析工具。", promptFiles: ['module_analysis_direct.yml'] },
            { name: "生成最终响应", description: "使用LLM整合工具输出，生成模块文档。" }
        ],
        parameters: [
            { name: 'module_path', description: '需要分析的模块/文件夹路径', type: 'path' }
        ]
    },
    'docgen-module-mapreduce': {
        agentId: 'docgen-module-mapreduce',
        agentName: '模块级文档 (摘要总结)',
        steps: [
            { name: "解析与准备", description: "扫描指定路径下的所有文件并根据Token限制进行分批。" },
            { name: "Map阶段: 并行分析", description: "并行调用LLM为每个文件批次生成摘要。", promptFiles: ['module_analysis_mapreduce.yml'] },
            { name: "Reduce阶段: 综合摘要", description: "将所有批次的摘要合并，并由LLM生成最终的模块文档。" }
        ],
        parameters: [
            { name: 'module_path', description: '需要分析的模块/文件夹路径', type: 'path' }
        ]
    }
};

// 辅助函数：用于加载外部YAML文件
async function loadPromptFile(workspaceRoot: vscode.Uri, fileName: string): Promise<string> {
    const promptUri = vscode.Uri.joinPath(workspaceRoot, '.codewiki', fileName);
    try {
        const fileContent = await vscode.workspace.fs.readFile(promptUri);
        return Buffer.from(fileContent).toString('utf-8');
    } catch (e) {
        throw new Error(`无法加载提示词文件: ${fileName}。请确保它存在于 '.codewiki' 目录中。`);
    }
}


/**
 * AgentService 是UI层（如Commands, Webviews）与后台Agent执行逻辑之间的唯一接口。
 * 它负责组装Agent运行所需的一切，并启动它们。
 */
export class AgentService {
    private toolRegistry: ToolRegistry;
    private activeRuns = new Map<string, { logger: AgentLogger }>();

    // 注入 StateManager 以获取配置
    constructor(private llmService: LLMService, private stateManager: StateManager) {
        this.toolRegistry = new ToolRegistry(this.llmService);
    }

    public async initialize(defaultModelConfig: ModelConfig): Promise<void> {
        await this.toolRegistry.initialize(defaultModelConfig);
        console.log("AgentService initialized successfully.");
    }

    /**
     * 根据 Agent ID 获取其预定义的计划（元数据）。
     * @param agentId Agent的唯一标识符。
     * @returns 返回 AgentPlan 对象，如果未找到则返回 null。
     */
    public getAgentPlan(agentId: string): AgentPlan | null {
        const plan = AGENT_DEFINITIONS[agentId];
        return plan ? { ...plan } : null; // 返回一个副本以避免意外修改
    }

    /**
     * 取消一个正在运行的 Agent。
     * @param runId 要取消的运行的ID。
     */
    public async cancelAgentRun(runId: string) {
        const run = this.activeRuns.get(runId);
        if (run) {
            console.log(`Cancelling agent run ${runId}`);
            // 发送一个 "cancelled" 状态的最终事件
            run.logger.onAgentEnd({
                runId,
                status: 'cancelled',
                error: 'Agent run was cancelled by the user.'
            });
            // 从活动运行中移除，以防止后续的 'completed' 或 'failed' 事件被发送
            this.activeRuns.delete(runId);
        }
    }

    public async prepareAndRunAgent(
        agentId: string,
        userInputs: Record<string, any>,
        modelConfig: ModelConfig,
        logger: AgentLogger
    ) {
        const runId = uuidv4();
        const agentPlan = this.getAgentPlan(agentId);

        if (!agentPlan) {
            const errorMsg = `Agent with ID "${agentId}" not found.`;
            logger.onAgentEnd({ runId, status: 'failed', error: errorMsg });
            return;
        }

        // 填充从前端接收到的参数值
        agentPlan.parameters.forEach(param => {
            if (userInputs[param.name] !== undefined) {
                param.value = userInputs[param.name];
            }
        });

        // 从 StateManager 获取最新的性能配置
        const performanceConfig = await this.stateManager.getPerformanceConfig();

        // 在运行前更新 LLMService 的参数
        this.llmService.concurrencyLimit = performanceConfig.concurrencyLimit;
        this.llmService.minInterval = performanceConfig.minInterval;

        const statsTracker = new StatsTracker();

        const context: AgentContext = {
            logger,
            llmService: this.llmService,
            toolRegistry: this.toolRegistry,
            modelConfig,
            statsTracker,
            performanceConfig  // 注入到上下文中

        };

        const workspaceRoot = vscode.workspace.workspaceFolders?.[0].uri;
        if (!workspaceRoot) {
            logger.onAgentEnd({ runId, status: 'failed', error: 'No workspace folder open.' });
            return;
        }

        // --- 核心逻辑重构 ---
        let finalOutput: any = "执行成功"; // 默认成功消息

        try {
            this.activeRuns.set(runId, { logger }); // 注册运行

            switch (agentId) {
                case 'docgen-project': {
                    const projPrompts = {
                        plannerPrompt: await loadPromptFile(workspaceRoot, 'project_planner.yml'),
                        directAnalysisPrompt: await loadPromptFile(workspaceRoot, 'module_analysis_direct.yml'),
                        mapReduceAnalysisPrompt: await loadPromptFile(workspaceRoot, 'module_analysis_mapreduce.yml'),
                        synthesisPrompt: await loadPromptFile(workspaceRoot, 'project_synthesis.yml'),
                    };
                    const sourcePathParam = agentPlan.parameters.find(p => p.name === 'source_path');
                    const sourcePath = (sourcePathParam?.value as string) || '.'; // 如果未提供，则回退到默认值
                    const orchestrator = new ProjectDocumentationOrchestrator(context, projPrompts);
                    // Orchestrator 只负责执行，不负责上报最终状态
                    await orchestrator.run(runId, sourcePath);
                    break;
                }

                case 'docgen-module-direct': {
                    const directPromptYaml = await loadPromptFile(workspaceRoot, 'module_analysis_direct.yml');
                    const modulePathParam = agentPlan.parameters.find(p => p.name === 'module_path');
                    if (!modulePathParam || !modulePathParam.value) {
                        throw new Error("Missing required parameter: module_path");
                    }
                    const directInputs = { module_path: modulePathParam.value };

                    const toolchainExecutor = new ToolChainExecutor(context);
                    // 捕获执行器的结果作为 finalOutput
                    finalOutput = await toolchainExecutor.run(runId, directPromptYaml, directInputs);
                    break;
                }

                case 'docgen-module-mapreduce': {
                    const mapreducePromptYaml = await loadPromptFile(workspaceRoot, 'module_analysis_mapreduce.yml');
                    const modulePathParam = agentPlan.parameters.find(p => p.name === 'module_path');
                    if (!modulePathParam || !modulePathParam.value) {
                        throw new Error("Missing required parameter: module_path");
                    }
                    const mapreduceInputs = { module_path: modulePathParam.value };

                    const mapReduceExecutor = new MapReduceExecutor(context);
                    // 捕获执行器的结果作为 finalOutput
                    finalOutput = await mapReduceExecutor.run(runId, mapreducePromptYaml, mapreduceInputs);
                    break;
                }

                default:
                    throw new Error(`Execution for agent "${agentId}" is not yet implemented.`);
            }

            // 只有在运行没有被取消的情况下，才发送 'completed' 事件
            if (this.activeRuns.has(runId)) {
                const finalStats = statsTracker.getFinalStats();
                logger.onAgentEnd({ runId, status: 'completed', finalOutput, stats: finalStats });
            }

        } catch (error: any) {
            // 只有在运行没有被取消的情况下，才发送 'failed' 事件
            if (this.activeRuns.has(runId)) {
                const finalStats = statsTracker.getFinalStats();
                const errorMessage = error instanceof Error ? error.message : String(error);
                logger.onAgentEnd({ runId, status: 'failed', error: errorMessage, stats: finalStats });
            }
        } finally {
            this.activeRuns.delete(runId); // 确保在所有路径上都取消注册
        }
    }

    public async runProjectDocumentation(modelConfig: ModelConfig) {
        const logger = new VscodeOutputChannelLogger("CodeWiki Project Documentation");
        await this.prepareAndRunAgent('docgen-project', {}, modelConfig, logger);
    }

    public async runActionFromWebview(
        yamlContent: string,
        userInputs: Record<string, any>,
        modelConfig: ModelConfig,
        webview: vscode.Webview
    ) {
        const logger = new WebviewLogger(webview);
        const statsTracker = new StatsTracker(); // <-- 为 webview action 也创建 tracker
        const performanceConfig = await this.stateManager.getPerformanceConfig();

        // 在运行前更新 LLMService 的参数
        this.llmService.concurrencyLimit = performanceConfig.concurrencyLimit;
        this.llmService.minInterval = performanceConfig.minInterval;
        
        const context: AgentContext = {
            logger,
            llmService: this.llmService,
            toolRegistry: this.toolRegistry,
            modelConfig,
            statsTracker,
            performanceConfig, // <-- 将获取到的配置添加到上下文中
        };

        const runId = uuidv4();

        try {

            this.activeRuns.set(runId, { logger });

            const executor = new ToolChainExecutor(context);
            const result = await executor.run(runId, yamlContent, userInputs);


            if (this.activeRuns.has(runId)) {
                const finalStats = statsTracker.getFinalStats();
                logger.onAgentEnd({ runId, status: 'completed', finalOutput: result, stats: finalStats });
            }


        } catch (error: any) {

            if (this.activeRuns.has(runId)) {
                const finalStats = statsTracker.getFinalStats();
                const errorMessage = error instanceof Error ? error.message : String(error);
                logger.onAgentEnd({ runId, status: 'failed', error: errorMessage, stats: finalStats });
            }

        } finally {

            this.activeRuns.delete(runId);

        }
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/services/LLMService.ts ---
// src/extension/services/LLMService.ts (修改后完整文件)

import vscode from 'vscode';

import { ChatMessage, ModelConfig, TextChatMessage } from '../../common/types';

import { ChatOpenAI } from '@langchain/openai';
import { HumanMessage, AIMessage, BaseMessage } from '@langchain/core/messages';
import { BaseChatModel } from '@langchain/core/language_models/chat_models';
import { ChatGoogleGenerativeAI } from '@langchain/google-genai';

const USE_GEMINI = false;

export interface CreateModelOptions {
    modelConfig: ModelConfig;
    temperature?: number;
    streaming?: boolean;
}

/**
 * 定义一个可以放入队列的LLM任务。
 * 它包含一个返回Promise的函数，以及用于解决该Promise的resolver和rejecter。
 */
type LlmTask<T> = {
    task: () => Promise<T>;
    resolve: (value: T) => void;
    reject: (reason?: any) => void;
};

async function getGoogleApiKey(): Promise<string | undefined> {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) return undefined;
    const workspaceRoot = workspaceFolders[0].uri;
    const envPath = vscode.Uri.joinPath(workspaceRoot, '.codewiki', '.env');
    try {
        const contentBytes = await vscode.workspace.fs.readFile(envPath);
        const content = Buffer.from(contentBytes).toString('utf-8');
        const lines = content.split('\n');
        for (const line of lines) {
            const trimmedLine = line.trim();
            if (trimmedLine.startsWith('GOOGLE_API_KEY=')) {
                return trimmedLine.substring('GOOGLE_API_KEY='.length).trim();
            }
        }
    } catch (error) {
        if (!(error instanceof vscode.FileSystemError && error.code === 'FileNotFound')) {
            console.error("Error reading .codewiki/.env file:", error);
        }
    }
    return undefined;
}

export class LLMService {
    private _abortController: AbortController | null = null;

    // --- 新的并行速率限制器属性 ---
    private requestQueue: LlmTask<any>[] = [];
    private activeRequests = 0;
    private isProcessing = false;
    private lastRequestTime = 0;

    // --- 配置 ---
    public minInterval: number;
    public concurrencyLimit: number;

    constructor() {
        // 在构造函数中设置一个临时的默认值，它们将被 StateManager 的值覆盖
        this.minInterval = 10000;
        this.concurrencyLimit = 10;
    }


    public async createModel(options: CreateModelOptions): Promise<BaseChatModel> {
        const { modelConfig, temperature = 0.7, streaming = false } = options;
        if (USE_GEMINI) {
            console.log("[LLMService] Creating model using Google Gemini.");
            const apiKey = await getGoogleApiKey();
            if (!apiKey) throw new Error("Gemini execution failed: 'GOOGLE_API_KEY' not found in your .codewiki/.env file.");
            return new ChatGoogleGenerativeAI({ model: "gemini-1.5-flash-latest", apiKey, temperature });
        }

        const url = new URL(modelConfig.baseUrl);
        if (!url.pathname.includes('/v1')) {
            url.pathname = ('/v1' + url.pathname).replace(/\/+/g, '/');
        }
        const finalBaseUrl = url.toString().replace(/\/$/, '');

        return new ChatOpenAI({
            modelName: modelConfig.modelId,
            apiKey: modelConfig.apiKey,
            streaming,
            temperature,
            configuration: { baseURL: finalBaseUrl }
        });
    }

    /**
     * 新增：对LLM的响应进行后处理，移除思考过程标签。
     * @param content 从LLM收到的原始字符串内容。
     * @returns 清理后的字符串。
     */
    private _postProcessResponse(content: string): string {
        if (typeof content !== 'string') {
            return content;
        }
        // 查找最后一个 </think> 或 </thinking> 标签
        const thinkEndTagRegex = /<\/think(ing)?>/gi;
        let lastIndex = -1;
        let match;

        // 循环找到最后一个匹配项的索引
        while ((match = thinkEndTagRegex.exec(content)) !== null) {
            lastIndex = match.index + match[0].length;
        }

        // 如果找到了结束标签，则截取它之后的内容
        if (lastIndex !== -1) {
            return content.substring(lastIndex).trim();
        }

        // 如果没有找到结束标签，返回原始内容
        return content;
    }

    /**
     * 将一个非流式的LLM调用任务加入队列，并由并行的速率限制调度器执行。
     * @param task 一个返回LLM调用Promise的函数，例如 `() => llm.invoke(messages)`
     * @returns 一个在任务完成时解析的Promise
     */
    public scheduleLlmCall<T>(task: () => Promise<T>): Promise<T> {
        console.log(`[LLMService] ${new Date().toISOString()} A new call was scheduled. Queue size: ${this.requestQueue.length + 1}`);
        return new Promise<T>((resolve, reject) => {
            const resolvingPostProcessor = (result: T) => {
                if (typeof result === 'string') {
                    const processedResult = this._postProcessResponse(result);
                    resolve(processedResult as T);
                } else if (result instanceof BaseMessage) {
                    if (typeof result.content === 'string') {
                        const processedContent = this._postProcessResponse(result.content);
                        // --- highlight-start ---
                        // 修复：不再使用 .copy()，而是创建一个新的 AIMessage 实例。
                        // 这更明确，并且能解决 TypeScript 的类型推断问题。
                        // 我们将原始消息的其他属性（如 tool_calls）也传递过去。
                        const newResult = new AIMessage({
                            ...result, // 展开原始 result 的所有属性
                            content: processedContent, // 覆盖 content 属性
                        });
                        resolve(newResult as T);
                        // --- highlight-end ---
                    } else {
                        resolve(result);
                    }
                } else {
                    resolve(result);
                }
            };
            this.requestQueue.push({ task, resolve: resolvingPostProcessor, reject });
            this.processQueue();
        });
    }

    // 简化和修复 processQueue 逻辑
    private processQueue() {
        // 循环检查，直到无法再派发新任务
        while (this.requestQueue.length > 0 && this.activeRequests < this.concurrencyLimit) {
            const now = Date.now();
            const elapsed = now - this.lastRequestTime;
            const delay = Math.max(0, this.minInterval - elapsed);

            // 如果需要延迟，则设置一个定时器来重新触发 processQueue，然后退出循环
            if (delay > 0) {
                setTimeout(() => this.processQueue(), delay);
                return; // 退出当前循环，等待延迟结束
            }

            // 如果不需要延迟，立即派发一个任务
            const { task, resolve, reject } = this.requestQueue.shift()!;

            this.lastRequestTime = Date.now();
            this.activeRequests++;

            console.log(`[LLMService] ${new Date().toISOString()} Executing call. Active: ${this.activeRequests}, Queue: ${this.requestQueue.length}`);

            // 异步执行任务
            task()
                .then(resolve)
                .catch(reject)
                .finally(() => {
                    this.activeRequests--;
                    console.log(`[LLMService] ${new Date().toISOString()} Call finished. Active: ${this.activeRequests}, Queue: ${this.requestQueue.length}`);
                    // 任务完成后，再次尝试处理队列，以防有任务在等待
                    this.processQueue();
                });
        }
        // 如果循环结束（队列为空或达到并发上限），则函数自然返回。
    }

    public async getCompletion(
        messages: ChatMessage[],
        config: ModelConfig,
        onData: (chunk: string) => void,
        onEnd: () => void,
        onError: (error: any) => void
    ): Promise<void> {
        this._abortController = new AbortController();
        const signal = this._abortController.signal;
        let llm: BaseChatModel;

        try {
            llm = await this.createModel({ modelConfig: config, streaming: true, temperature: 0.7 });

            // Filter for text messages only and then map them
            const langchainMessages: BaseMessage[] = messages
                .filter((msg): msg is TextChatMessage => msg.type === 'text')
                .map(msg => msg.role === 'user' ? new HumanMessage(msg.content) : new AIMessage(msg.content));

            const stream = await llm.stream(langchainMessages, { signal });
            for await (const chunk of stream) {
                if (chunk.content) {
                    onData(chunk.content as string);
                }
            }
        } catch (error: any) {
            if (signal.aborted) {
                console.log('Request aborted by user.');
            } else {
                console.error("--- LANGCHAIN REQUEST FAILED ---");
                if (error instanceof Error) {
                    console.error("Full Error Object:", error);
                    onError(error);
                } else {
                    console.error("Unknown Error:", error);
                    onError(new Error(String(error)));
                }
                console.error("--- END OF ERROR ---");
            }
        } finally {
            onEnd();
            this._abortController = null;
        }
    }

    public abortRequest() {
        if (this._abortController) {
            this._abortController.abort();
        }
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/services/StatsTracker.ts ---
// src/extension/services/StatsTracker.ts
import { get_encoding, Tiktoken } from "tiktoken";

export interface AgentRunStats {
    duration: string;
    totalTokens: number;
    promptTokens: number;
    completionTokens: number;
}

/**
 * 在单次 Agent 运行期间跟踪和计算统计信息。
 */
export class StatsTracker {
    private startTime: number;
    private totalPromptTokens: number = 0;
    private totalCompletionTokens: number = 0;
    private tokenizer: Tiktoken;

    constructor() {
        this.startTime = Date.now();
        // 使用一个通用的编码器来估算，cl100k_base 适用于大多数现代 OpenAI 模型
        this.tokenizer = get_encoding("cl100k_base");
    }

    /**
     * 记录一次LLM调用的Token消耗。
     * @param prompt - 发送给模型的完整提示文本。
     * @param completion - 从模型接收到的完整响应文本。
     */
    public add(prompt: string, completion: string): void {
        try {
            const promptTokens = this.tokenizer.encode(prompt).length;
            const completionTokens = this.tokenizer.encode(completion).length;
            
            this.totalPromptTokens += promptTokens;
            this.totalCompletionTokens += completionTokens;
        } catch (e) {
            console.error("Token counting failed:", e);
        }
    }

    /**
     * 计算并返回最终的统计数据。
     * @returns {AgentRunStats} 最终的统计对象。
     */
    public getFinalStats(): AgentRunStats {
        const endTime = Date.now();
        const durationMs = endTime - this.startTime;
        const durationSec = (durationMs / 1000).toFixed(2);
        
        // 释放 tokenizer 资源
        this.tokenizer.free();

        return {
            duration: `${durationSec}s`,
            promptTokens: this.totalPromptTokens,
            completionTokens: this.totalCompletionTokens,
            totalTokens: this.totalPromptTokens + this.totalCompletionTokens,
        };
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/services/ToolRegistry.ts ---
// src/extension/services/ToolRegistry.ts (完整文件)

import { StructuredTool } from '@langchain/core/tools';
import { ModelConfig } from '../../common/types';
import { GetFileSummariesTool, GetFilesContentByListTool, GetAllFilesContentTool, GetDirectoryTreeTool } from '../tools/fileSystemTools';
import { createFileSelectorLLMTool } from '../tools/llmTools';
import { LLMService } from './LLMService';

/**
 * 负责在扩展启动时初始化所有工具，并按需提供。
 * 这是一个集中管理工具的单例服务。
 */
export class ToolRegistry {
    private tools = new Map<string, StructuredTool>();

    constructor(private llmService: LLMService) {}

    /**
     * 初始化所有工具，特别是那些需要LLM实例的工具。
     * @param defaultModelConfig 用于创建工具内部LLM的默认模型配置。
     */
    public async initialize(defaultModelConfig: ModelConfig): Promise<void> {
        // 为工具创建一个专用的、非流式的LLM实例
        const toolLlm = await this.llmService.createModel({
            modelConfig: defaultModelConfig,
            temperature: 0.1,
            streaming: false,
        });

        const allTools: StructuredTool[] = [
            new GetFileSummariesTool(),
            new GetFilesContentByListTool(),
            new GetAllFilesContentTool(),
            new GetDirectoryTreeTool(),
            createFileSelectorLLMTool(toolLlm, this.llmService),
        ];

        for (const tool of allTools) {
            this.tools.set(tool.name, tool);
        }
        console.log("ToolRegistry initialized with tools:", Array.from(this.tools.keys()));
    }

    /**
     * 根据名称获取单个工具。
     * @param name 工具的名称。
     * @returns 返回工具实例，如果找不到则返回undefined。
     */
    public getTool(name: string): StructuredTool | undefined {
        return this.tools.get(name);
    }
    
    /**
     * 根据名称列表获取一组工具。
     * @param names 工具名称的数组。
     * @returns 返回工具实例的数组。
     * @throws 如果有任何一个工具找不到，则抛出错误。
     */
    public getTools(names: string[]): StructuredTool[] {
         return names.map(name => {
             const tool = this.getTool(name);
             if (!tool) {
                 throw new Error(`Tool "${name}" not found in registry.`);
             }
             return tool;
         });
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/services/logging.ts ---
// src/extension/services/logging.ts (修改后完整文件)

import * as vscode from 'vscode';
import { AgentPlan, StepExecution, StepUpdate, StepResult, StreamChunk, AgentResult } from '../../common/types';
import * as path from 'path'; // 引入 path 模块

/**
 * Agent 执行过程中的通用日志记录器接口。
 * 这使得核心逻辑可以与具体的UI（如OutputChannel或Webview）解耦。
 */
export interface AgentLogger {
    info(message: string): void;
    warn(message:string): void;
    error(message: string, error?: Error): void;
    log(message: string): void; // 用于原始输出，如LLM的流式数据
    logLine(message: string): void; // 新增：用于打印带换行的详细日志
    show(preserveFocus?: boolean): void; // 可选，用于显示日志面板

    // --- 新增的结构化事件方法 ---
    onPlanGenerated(plan: AgentPlan): void;
    onStepStart(step: StepExecution): void;
    onStepUpdate(update: StepUpdate): void;
    onStepEnd(result: StepResult): void;
    onStreamChunk(chunk: StreamChunk): void;
    onAgentEnd(result: AgentResult): void;
}

/**
 * AgentLogger接口的一个实现，它将日志写入VS Code的Output Channel。
 */
export class VscodeOutputChannelLogger implements AgentLogger {
    private readonly channel: vscode.OutputChannel;
    private streamBuffer: { [key: string]: string } = {}; // 用于缓存流式数据

    constructor(channelName: string) {
        this.channel = vscode.window.createOutputChannel(channelName);
    }

    public info(message: string): void {
        this.channel.appendLine(`[INFO] ${message}`);
    }

    public warn(message: string): void {
        this.channel.appendLine(`[WARN] ${message}`);
    }

    public error(message: string, error?: Error): void {
        this.channel.appendLine(`[ERROR] ${message}`);
        if (error?.stack) {
            this.channel.appendLine(error.stack);
        }
    }

    public log(message: string): void {
        // 对于原始日志，我们不添加前缀，直接追加
        this.channel.append(message);
    }
    
    public logLine(message: string): void {
        this.channel.appendLine(message);
    }

    public show(preserveFocus: boolean = true): void {
        this.channel.show(preserveFocus);
    }

     /**
     * 新接口方法的优化实现
     */
    public onPlanGenerated(plan: AgentPlan): void {
        this.channel.appendLine(`[PLAN] Agent "${plan.agentName}" is ready.`);
        plan.steps.forEach((step, i) => {
            this.channel.appendLine(`  [Step ${i+1}] ${step.name}: ${step.description}`);
        });
    }

    public onStepStart(step: StepExecution): void {
        const id = step.taskId ? `${step.stepName} (Task: ${step.taskId})` : step.stepName;
        this.channel.appendLine(`\n--- [START] ${id} ---`);
        // 初始化当前任务的流式缓存
        if (step.taskId) {
            this.streamBuffer[step.taskId] = '';
        }
    }
    
    /**
     * 核心修改：对 onStepUpdate 的内容进行审查和简化
     */
    public onStepUpdate(update: StepUpdate): void {
        if (update.type === 'output') {
            // 检查元数据中是否包含文件路径信息
            if (update.metadata?.type === 'file' && typeof update.metadata.path === 'string') {
                // 如果是文件输出，只打印文件名
                const fileName = path.basename(update.metadata.path);
                this.channel.appendLine(`[OUTPUT] Generated file: ${fileName}`);
            } else {
                // 对于其他输出，提取内容并进行长度限制
                let outputStr = '';
                if (typeof update.data === 'object' && update.data !== null && 'content' in update.data) {
                    outputStr = String(update.data.content);
                } else {
                    outputStr = typeof update.data === 'string' ? update.data : JSON.stringify(update.data);
                }
                
                // // 如果内容过长，只打印摘要信息，否则打印完整内容
                // const MAX_LENGTH = 150;
                // if (outputStr.length > MAX_LENGTH) {
                //     this.channel.appendLine(`[OUTPUT] ${outputStr.substring(0, MAX_LENGTH)}... (Content too long)`);
                // } else {
                //     this.channel.appendLine(`[OUTPUT] ${outputStr}`);
                // }
            }
        }
        // 其他类型的 update (input, llm-request) 将被忽略，不打印
    }
    
    /**
     * 核心修改：onStepEnd 不再打印流式缓存，因为 onStreamChunk 已被禁用
     */
    public onStepEnd(result: StepResult): void {
        const id = result.taskId ? `${result.status.toUpperCase()} (Task: ${result.taskId})` : result.status.toUpperCase();
        
        // 如果失败，打印错误信息
        if (result.status === 'failed' && result.error) {
            this.channel.appendLine(`[ERROR] ${result.error}`);
        }
        
        this.channel.appendLine(`--- [${id}] ---`);
        // 不再需要处理 streamBuffer
    }

    /**
     * 核心修改：onStreamChunk 完全禁用，不执行任何操作
     */
    public onStreamChunk(chunk: StreamChunk): void {
        // Do nothing. We don't want to log stream chunks to the output channel.
    }

    public onAgentEnd(result: AgentResult): void {
        this.channel.appendLine(`\n====== [AGENT ${result.status.toUpperCase()}] ======`);
        if(result.error) {
            this.error("Agent failed", new Error(result.error));
        }
    }
}

/**
 * AgentLogger接口的一个实现，它将日志通过postMessage发送到Webview。
 */
export class WebviewLogger implements AgentLogger {
    constructor(private webview: vscode.Webview) {}

    info(message: string): void {
        // 只发送简洁的状态更新
        this.webview.postMessage({ command: 'agentStatusUpdate', payload: { status: 'info', message }});
    }

    warn(message: string): void {
        this.webview.postMessage({ command: 'agentStatusUpdate', payload: { status: 'warn', message }});
    }

    error(message: string, error?: Error): void {
        const errorMessage = error ? `${message}: ${error.message}` : message;
        this.webview.postMessage({ command: 'requestFailed', payload: { error: errorMessage }});
    }

    log(message: string): void {
        // 流式数据有专门的命令
        this.webview.postMessage({ command: 'streamData', payload: message });
    }

    logLine(message: string): void {
        // 对于Webview，一行详细日志可以被视为一个'info'状态
        this.info(message);
    }

    show(preserveFocus?: boolean | undefined): void {
        // Webview 默认就是可见的，此方法可以为空
    }

    // --- highlight-start ---
    // --- 任务1实现：填充结构化事件发送方法 ---
    public onPlanGenerated(plan: AgentPlan): void {
        this.webview.postMessage({ command: 'agent:planGenerated', payload: plan });
    }
    public onStepStart(step: StepExecution): void {
        this.webview.postMessage({ command: 'agent:stepStart', payload: step });
    }
    public onStepUpdate(update: StepUpdate): void {
        this.webview.postMessage({ command: 'agent:stepUpdate', payload: update });
    }
    public onStepEnd(result: StepResult): void {
        this.webview.postMessage({ command: 'agent:stepEnd', payload: result });
    }
    public onStreamChunk(chunk: StreamChunk): void { 
        this.webview.postMessage({ command: 'agent:streamChunk', payload: chunk });
    }
    public onAgentEnd(result: AgentResult): void {
        this.webview.postMessage({ command: 'agent:end', payload: result });
    }
    // --- highlight-end ---
}

--------------------------------------------------------------------------------

--- file_path: extension/tools/fileSystemTools.ts ---
// src/extension/tools/fileSystemTools.ts (完整文件)

import * as vscode from 'vscode';
import * as path from 'path';
import { z } from 'zod';
import { StructuredTool } from '@langchain/core/tools';
import { languageFilters, GENERIC_EXCLUDE, LanguageFilter } from '../config/fileFilters';

/**
 * 获取当前工作区的根路径。
 * @returns {string} 工作区根目录的绝对路径。
 * @throws {Error} 如果没有打开的工作区。
 */
function getWorkspaceRoot(): string {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders || workspaceFolders.length === 0) {
        throw new Error("没有打开的工作区。请先打开一个项目文件夹。");
    }
    return workspaceFolders[0].uri.fsPath;
}

/**
 * 新增的辅助函数，用于递归获取过滤后的文件路径。
 * @param dirUri 起始目录的URI
 * @param language 用于选择过滤规则的语言
 * @returns {Promise<vscode.Uri[]>} 过滤后的文件URI列表
 */
async function getFilteredFilePathsRecursive(dirUri: vscode.Uri, language: string = 'unknown'): Promise<vscode.Uri[]> {
    let files: vscode.Uri[] = [];
    const filter: LanguageFilter = languageFilters[language.toLowerCase()] || languageFilters.unknown;

    try {
        const entries = await vscode.workspace.fs.readDirectory(dirUri);

        for (const [name, type] of entries) {
            // 检查是否在通用排除列表中
            if (GENERIC_EXCLUDE.includes(name)) {
                continue;
            }

            const entryUri = vscode.Uri.joinPath(dirUri, name);
            if (type === vscode.FileType.File) {
                const extension = path.extname(name);
                const shouldInclude = filter.include.includes(extension);
                const shouldExclude = filter.exclude.some(pattern => name.endsWith(pattern));

                if (shouldInclude && !shouldExclude) {
                    files.push(entryUri);
                }
            } else if (type === vscode.FileType.Directory) {
                files = files.concat(await getFilteredFilePathsRecursive(entryUri, language));
            }
        }
    } catch (error) {
        console.warn(`Could not read directory ${dirUri.fsPath}:`, error);
    }
    return files;
}

/**
 * 一个LangChain工具，用于获取指定目录下所有文件的路径和内容摘要。
 * 摘要是文件的前20行。
 */
export class GetFileSummariesTool extends StructuredTool {
    static lc_name() {
        return "GetFileSummariesTool";
    }

    name = "get_file_summaries";
    description = "获取指定目录中所有文件的路径和内容摘要（文件的前20行）。用于在阅读完整文件之前，快速了解一个模块的结构。";

    schema = z.object({
        path: z.string().describe("从工作区根目录出发的相对路径。"),
        language: z.string().optional().describe("项目的编程语言 (例如 'typescript', 'python')，用于智能过滤文件。如果未提供，则使用通用规则。"),
    });

    protected async _call({ path: relativePath }: z.infer<typeof this.schema>): Promise<string> {
        try {
            const workspaceRoot = getWorkspaceRoot();
            const absolutePath = path.join(workspaceRoot, relativePath);

            const entries = await vscode.workspace.fs.readDirectory(vscode.Uri.file(absolutePath));
            const fileSummaries: string[] = [];

            for (const [name, type] of entries) {
                if (type === vscode.FileType.File) {
                    const filePath = path.join(absolutePath, name);
                    const fileUri = vscode.Uri.file(filePath);
                    
                    const contentBytes = await vscode.workspace.fs.readFile(fileUri);
                    const content = Buffer.from(contentBytes).toString('utf-8');
                    const summary = content.split('\n').slice(0, 20).join('\n');
                    
                    const fileRelativePath = path.relative(workspaceRoot, filePath);

                    fileSummaries.push(
                        `--- FILE: ${fileRelativePath.replace(/\\/g, '/')} ---\n${summary}\n--- END OF SUMMARY ---\n`
                    );
                }
            }

            if (fileSummaries.length === 0) {
                return `在目录 "${relativePath}" 中没有找到任何文件。`;
            }

            return fileSummaries.join('\n');
        } catch (error: any) {
            return `获取路径 "${relativePath}" 的文件摘要时出错: ${error.message}`;
        }
    }
}


/**
 * 一个LangChain工具，根据提供的文件路径列表，获取这些文件的完整内容。
 */
export class GetFilesContentByListTool extends StructuredTool {
    static lc_name() {
        return "GetFilesContentByListTool";
    }

    name = "get_files_content_by_list";
    description = "根据一个包含相对路径的列表，读取这些文件的完整内容。这个列表通常是文件选择工具的输出。";

    schema = z.object({
        file_paths: z.array(z.string()).describe("一个包含文件相对路径的数组，路径从工作区根目录开始计算。"),
    });

    protected async _call({ file_paths }: z.infer<typeof this.schema>): Promise<string> {
        if (!file_paths || file_paths.length === 0) {
            return "输入的文件列表为空，没有内容可以读取。";
        }

        try {
            const workspaceRoot = getWorkspaceRoot();
            const contentPromises = file_paths.map(async (relativePath) => {
                const absolutePath = path.join(workspaceRoot, relativePath);
                const fileUri = vscode.Uri.file(absolutePath);
                
                try {
                    const contentBytes = await vscode.workspace.fs.readFile(fileUri);
                    const content = Buffer.from(contentBytes).toString('utf-8');
                    return `--- FILE: ${relativePath.replace(/\\/g, '/')} ---\n${content}\n--- END OF FILE ---\n`;
                } catch (fileError: any) {
                    // 如果单个文件读取失败，返回错误信息而不是让整个工具失败
                    return `--- FILE: ${relativePath.replace(/\\/g, '/')} ---\n错误: 无法读取文件。 ${fileError.message}\n--- END OF FILE ---\n`;
                }
            });

            const allContents = await Promise.all(contentPromises);
            return allContents.join('\n');

        } catch (error: any) {
            // 捕获 getWorkspaceRoot 的错误
            return `获取文件内容时出错: ${error.message}`;
        }
    }
}

/**
 * 一个LangChain工具，用于递归获取指定目录下所有文件的完整内容。
 */
export class GetAllFilesContentTool extends StructuredTool {
    static lc_name() {
        return "GetAllFilesContentTool";
    }

    name = "get_all_files_content";
    description = "递归地获取指定目录及其所有子目录中所有文件的完整内容。当需要对一个模块的所有代码进行全面分析时使用。";

    schema = z.object({
        path: z.string().describe("从工作区根目录出发的相对路径。"),
        language: z.string().optional().describe("项目的编程语言 (例如 'typescript', 'python')，用于智能过滤文件。如果未提供，则使用通用规则。"),
    });

    /**
     * 递归遍历目录并收集文件内容。
     * @param dirUri 要遍历的目录的 URI。
     * @param workspaceRoot 工作区的根路径，用于计算相对路径。
     * @returns 一个包含文件内容和标记的字符串数组。
     */
    private async _traverseDirectory(dirUri: vscode.Uri, workspaceRoot: string): Promise<string[]> {
        let allContents: string[] = [];
        const entries = await vscode.workspace.fs.readDirectory(dirUri);

        for (const [name, type] of entries) {
            const entryUri = vscode.Uri.joinPath(dirUri, name);
            if (type === vscode.FileType.File) {
                const fileRelativePath = path.relative(workspaceRoot, entryUri.fsPath).replace(/\\/g, '/');
                try {
                    const contentBytes = await vscode.workspace.fs.readFile(entryUri);
                    const content = Buffer.from(contentBytes).toString('utf-8');
                    allContents.push(`--- FILE: ${fileRelativePath} ---\n${content}\n--- END OF FILE ---\n`);
                } catch (fileError: any) {
                    allContents.push(`--- FILE: ${fileRelativePath} ---\n错误: 无法读取文件。 ${fileError.message}\n--- END OF FILE ---\n`);
                }
            } else if (type === vscode.FileType.Directory) {
                // 如果是目录，则递归调用
                const subDirContents = await this._traverseDirectory(entryUri, workspaceRoot);
                allContents = allContents.concat(subDirContents);
            }
        }
        return allContents;
    }

    protected async _call({ path: relativePath, language }: z.infer<typeof this.schema>): Promise<string> {
        try {
            const workspaceRoot = getWorkspaceRoot();
            const absolutePath = path.join(workspaceRoot, relativePath);
            const dirUri = vscode.Uri.file(absolutePath);

            
            // 使用新的过滤辅助函数
            const fileUris = await getFilteredFilePathsRecursive(dirUri, language);
            

            if (fileUris.length === 0) {
                return `在目录 "${relativePath}" 及其子目录中没有找到与语言 '${language}' 相关的任何文件。`;
            }
            
            const contentPromises = fileUris.map(async (uri) => {
                 const fileRelativePath = path.relative(workspaceRoot, uri.fsPath).replace(/\\/g, '/');
                 try {
                    const contentBytes = await vscode.workspace.fs.readFile(uri);
                    const content = Buffer.from(contentBytes).toString('utf-8');
                    return `--- FILE: ${fileRelativePath} ---\n${content}\n--- END OF FILE ---\n`;
                 } catch (fileError: any) {
                    return `--- FILE: ${fileRelativePath} ---\n错误: 无法读取文件。 ${fileError.message}\n--- END OF FILE ---\n`;
                 }
            });
            
            const allContents = await Promise.all(contentPromises);
            return allContents.join('\n');

        } catch (error: any) {
            return `递归获取路径 "${relativePath}" 的所有文件内容时出错: ${error.message}`;
        }
    }
}

/**
 * 一个LangChain工具，用于生成指定路径的目录树结构。
 */
export class GetDirectoryTreeTool extends StructuredTool {
    static lc_name() {
        return "GetDirectoryTreeTool";
    }

    name = "get_directory_tree";
    // 更新描述，告知 AI 此工具输出紧凑的树状结构以节省 Token
    description = "生成给定路径的目录和文件树状结构图，并以紧凑的、节省 Token 的格式展示。会自动过滤掉常见的非源码目录（如 .git, .vscode, build, target 等）。用于快速了解项目的整体文件布局。";

    schema = z.object({
        path: z.string().describe("从工作区根目录出发的相对路径。"),
    });

    private readonly ignoreDirs: Set<string> = new Set([
        '.git',
        '.vscode',
        '.idea',
        'node_modules',
        'build',
        'dist',
        'target',
        'out',
        'bin',
        '.codewiki',
        '__pycache__',
    ]);

    /**
     * 递归生成格式化的目录树。
     * @param dirUri 要生成树的目录的 URI。
     * @param prefix 用于排版的树状前缀字符串 (例如 "│   " 或 "    ")。
     * @returns 一个包含格式化后树形结构行的字符串数组。
     */
    private async _generateTree(dirUri: vscode.Uri, prefix: string): Promise<string[]> {
        let treeLines: string[] = [];
        const entries = await vscode.workspace.fs.readDirectory(dirUri);

        // 先过滤掉需要忽略的目录/文件
        const filteredEntries = entries.filter(([name, _]) => !this.ignoreDirs.has(name));
        const count = filteredEntries.length;

        for (let i = 0; i < count; i++) {
            const [name, type] = filteredEntries[i];
            const isLast = i === count - 1; // 判断是否是当前目录的最后一个条目

            // 根据是否为最后一个条目，选择不同的连接符
            const connector = isLast ? '└── ' : '├── ';
            treeLines.push(`${prefix}${connector}${name}`);

            if (type === vscode.FileType.Directory) {
                // 为下一层递归计算新的前缀
                // 如果当前是最后一个，下一层的前缀使用空格；否则使用竖线连接
                const newPrefix = prefix + (isLast ? '    ' : '│   ');
                const subTreeLines = await this._generateTree(vscode.Uri.joinPath(dirUri, name), newPrefix);
                treeLines = treeLines.concat(subTreeLines);
            }
        }
        return treeLines;
    }

    protected async _call({ path: relativePath }: z.infer<typeof this.schema>): Promise<string> {
        try {
            const workspaceRoot = getWorkspaceRoot();
            if (!relativePath || relativePath === '/' || relativePath === '\\') {
                relativePath = '.';
            }
            const absolutePath = path.join(workspaceRoot, relativePath);
            const dirUri = vscode.Uri.file(absolutePath);

            try {
                const stat = await vscode.workspace.fs.stat(dirUri);
                if (stat.type !== vscode.FileType.Directory) {
                    return `错误：路径 "${relativePath}" 不是一个目录。`;
                }
            } catch (e) {
                return `错误：路径 "${relativePath}" 不存在或无法访问。`;
            }

            const displayRoot = relativePath === '.' ? '.' : `./${relativePath.replace(/\\/g, '/')}`;

            let treeLines = [displayRoot];
            // 初始调用时，前缀为空字符串 ""
            const subTree = await this._generateTree(dirUri, "");
            treeLines = treeLines.concat(subTree);

            if (treeLines.length === 1) {
                return `${displayRoot} (目录为空或所有内容均被过滤)`;
            }

            return treeLines.join('\n');
        } catch (error: any) {
            return `生成路径 "${relativePath}" 的目录树时出错: ${error.message}`;
        }
    }
}


--------------------------------------------------------------------------------

--- file_path: extension/tools/llmTools.ts ---
// src/extension/tools/llmTools.ts (完整文件)

import { z } from 'zod';
import { StructuredTool } from '@langchain/core/tools';
import { BaseLanguageModel } from '@langchain/core/language_models/base';
import { ChatPromptTemplate } from '@langchain/core/prompts';
import { StringOutputParser } from '@langchain/core/output_parsers';
import { LLMService } from '../services/LLMService'; // 导入 LLMService

// 这是 FileSelectorLLMTool 内部使用的 Prompt 模板
const SELECTION_PROMPT = `You are an expert software engineer assistant. Your task is to analyze a list of file summaries and select the most relevant files based on a user's task description.

Analyze the following file summaries:
---
{file_summaries}
---

The user's task is: "{task_description}"

Based on this, which files are the most critical for understanding and completing the task?

Please provide your answer as a clean, comma-separated list of file paths. Do NOT include any other text, explanations, or formatting.

Example response:
src/common/types.ts,src/extension/LLMService.ts,src/webview/views/ChatView.ts
`;

/**
 * 一个内部类，代表了 LLM-as-a-Tool 的具体实现。
 * 我们不直接导出它，而是通过工厂函数创建。
 */
class FileSelectorLLMTool extends StructuredTool {
    static lc_name() {
        return "FileSelectorLLMTool";
    }

    name = "file_selector_llm_tool";
    
    description = "分析文件摘要列表和任务描述，以智能地选择最相关的文件。输出是一个包含文件路径的数组。";
    
    
    // 该工具的输入 schema
    schema = z.object({
        file_summaries: z.string().describe("一个包含所有文件摘要的单一字符串，每个摘要由标记分隔。"),
        task_description: z.string().describe("用于指导文件选择的目标或任务的描述。"),
    });

    // 持有传入的 LLM 实例
    private llm: BaseLanguageModel;
    private llmService: LLMService; // 新增

    constructor(llm: BaseLanguageModel, llmService: LLMService) { // 修改构造函数
        super(); // 调用父类构造函数
        this.llm = llm;
        this.llmService = llmService; // 存储 LLMService 实例
    }

    protected async _call({ file_summaries, task_description }: z.infer<typeof this.schema>): Promise<string> {
        try {
            // 1. 构建专门用于文件筛选的 Prompt
            const selectionPrompt = ChatPromptTemplate.fromTemplate(SELECTION_PROMPT);

            // 2. 构建一个临时的、用于该工具内部的 LangChain "子链"
            //    它接收格式化的 prompt，调用 LLM，然后解析出字符串结果。
            const selectionChain = selectionPrompt
                .pipe(this.llm)
                .pipe(new StringOutputParser());

            // 3. 调用子链来执行 LLM 推理
            // 3. 调用子链来执行 LLM 推理
            console.log("Scheduling file_selector_llm_tool with task:", task_description);
            const llmResult = await this.llmService.scheduleLlmCall(async () => {
                const stream = await selectionChain.stream({
                    file_summaries,
                    task_description
                });
                let fullReply = '';
                for await (const chunk of stream) {
                    fullReply += chunk;
                }
                return fullReply;
            });

            // 4. 解析 LLM 返回的结果
            //    LLM 可能返回一些额外的空格或换行符，我们进行清理。
            //    我们期望的结果是 "path/a.ts, path/b.ts, ..."
            const cleanedResult = llmResult.replace(/```/g, '').trim(); // 移除代码块标记和多余空格
            const filePaths = cleanedResult.split(',')
                .map(p => p.trim())
                .filter(p => p.length > 0 && p.includes('/')); // 过滤掉空字符串和无效条目

            if (filePaths.length === 0) {
                console.warn("File selector LLM did not return any valid file paths.");
                return "[]"; // 返回一个表示空数组的JSON字符串
            }
            
            // 5. 将结果（一个字符串数组）序列化为 JSON 字符串返回。
            //    这是因为 LangChain 工具的标准输出是 string。
            //    我们的自定义 Agent Executor (将在下一阶段实现) 将负责解析这个JSON。
            return JSON.stringify(filePaths);

        } catch (error: any) {
            console.error("Error in FileSelectorLLMTool:", error);
            return `在文件选择LLM调用期间出错: ${error.message}`;
        }
    }
}

/**
 * 工厂函数，用于创建和配置 FileSelectorLLMTool。
 * @param llm - 一个配置好的、可用于调用的 BaseLanguageModel 实例。
 * @param llmService - 用于调度LLM调用的服务实例。
 * @returns {StructuredTool} 一个配置好的、可直接使用的工具实例。
 */
export function createFileSelectorLLMTool(llm: BaseLanguageModel, llmService: LLMService): StructuredTool {
    return new FileSelectorLLMTool(llm, llmService);
}

--------------------------------------------------------------------------------

--- file_path: test/suite/index.ts ---


--------------------------------------------------------------------------------

--- file_path: webview/components/AgentRunBlock.ts ---
// --- file_path: webview/components/AgentRunBlock.ts ---

import { AgentPlan, AgentResult, StepExecution, StepUpdate, StreamChunk, AgentPlanStep, StepResult as CommonStepResultType, AgentRunRecord, SavedStepState } from '../../common/types'; 
import { marked } from 'marked';
import { vscode } from '../vscode';

type AgentStatus = 'planning' | 'validating' | 'executing' | 'completed' | 'failed' | 'cancelled';

interface ExecutionStepState extends StepExecution {
    logs: { type: 'input' | 'output' | 'llm-request', data: any, metadata?: Record<string, any> }[];
    isCollapsed: boolean;
    streamedContent: string;
    error?: string;
}

// 类型守卫，用于区分 AgentPlan 和 AgentRunRecord
function isAgentRunRecord(data: AgentPlan | AgentRunRecord): data is AgentRunRecord {
    return (data as AgentRunRecord).result !== undefined;
}

export class AgentRunBlock {
    private element: HTMLElement;
    private plan: AgentPlan;
    private onExecute: ((params: Record<string, any>) => void) | null = null; // 可为 null
    private status: AgentStatus = 'planning';
    private executionState: Map<string, ExecutionStepState> = new Map();
    private agentResult: AgentResult | null = null;
    private animatedStepIds: Set<string> = new Set();
    private stepElementsCache: Map<string, HTMLElement> = new Map();
    private executionStepsOuterContainer: HTMLElement | null = null; // Cache this
    private runId: string | null = null;
    private onCancel?: () => void; // 新增 onCancel 属性

    constructor(
        container: HTMLElement,
        // 构造函数现在可以接收一个 AgentPlan（用于新的运行）或一个 AgentRunRecord（用于从历史恢复）
        planOrRecord: AgentPlan | AgentRunRecord,
        onExecute?: (params: Record<string, any>) => void,
        onCancel?: () => void // 在构造函数中接收回调
    ) {
        this.element = container;
        this.element.className = 'agent-run-block';
        
        if (isAgentRunRecord(planOrRecord)) {
            // 从历史记录中恢复
            const record = planOrRecord;
            this.plan = record.plan;
            this.agentResult = record.result;
            this.status = record.result.status as AgentStatus;
            this.runId = record.result.runId;
            // 将保存的普通对象转换回 Map
            this.executionState = new Map(Object.entries(record.executionState).map(([key, value]) => {
                // 确保每个步骤状态都符合 ExecutionStepState 接口
                const fullStepState: ExecutionStepState = {
                    runId: record.result.runId, // 从顶层结果中恢复 runId
                    stepName: value.stepName,
                    taskId: value.taskId,
                    status: value.status,
                    logs: value.logs || [],
                    isCollapsed: true, // 从历史记录加载时默认折叠
                    streamedContent: value.streamedContent || '',
                    error: value.error,
                };
                return [key, fullStepState];
            }));
            this.onExecute = null; // 历史记录是只读的
            this.onCancel = undefined; // 历史记录没有取消功能
        } else {
            // 开始一个新的运行
            this.plan = planOrRecord;
            this.onExecute = onExecute || null;
            this.onCancel = onCancel; // 保存回调
            this.status = 'planning';
        }

        this.render(); // Initial render
        this.setupEventListeners();
    }
    
    /**
     * 新增：获取组件当前的可序列化状态，用于保存到历史记录。
     */
    public getSerializableState(): AgentRunRecord | null {
        if (!this.agentResult) {
            console.error("Cannot serialize state: Agent has not completed.");
            return null;
        }

        
        // 将 Map 转换为普通对象以便 JSON 序列化
        const serializableExecutionState: Record<string, SavedStepState> = {};
        this.executionState.forEach((state, key) => {
            // 从 state 中只选择要保存的字段
            serializableExecutionState[key] = {
                stepName: state.stepName,
                taskId: state.taskId,
                status: state.status,
                logs: state.logs,
                streamedContent: state.streamedContent,
                error: state.error,
            };
        });
        

        return {
            plan: this.plan,
            executionState: serializableExecutionState,
            result: this.agentResult
        };
    }

    // Called by ChatView when agent:stepStart or agent:stepEnd is received
    public updateStepExecutionStatus(stepEventData: StepExecution | CommonStepResultType) {
        if (!this.runId) {
            this.runId = stepEventData.runId;
        }
        const stepKey = stepEventData.taskId || stepEventData.stepName;
        let stepState = this.executionState.get(stepKey);
        const isNewStepInState = !stepState;

        if (isNewStepInState) {
            // This is a StepExecution event for a new step/task
            stepState = { ...(stepEventData as StepExecution), logs: [], isCollapsed: false, streamedContent: '' };
        } else {
            // This is an update for an existing step (either StepExecution or StepResult)
            stepState!.status = stepEventData.status;
        }
        
        if (stepEventData.status === 'failed' && 'error' in stepEventData && stepEventData.error) {
            stepState!.error = stepEventData.error;
        }
        this.executionState.set(stepKey, stepState!);

        const isSubStep = stepState!.stepName.startsWith("分析模块:"); // Heuristic for sub-steps

        if (isNewStepInState) {
            // New step appearing in the execution flow
            if (isSubStep) {
                // Try to update parent's sub-step container directly
                const parentPlanStep = this.plan.steps.find(p => p.name === "分析: 并行处理模块"); // More robust way to find parent needed
                if (parentPlanStep) {
                    const parentStepState = Array.from(this.executionState.values()).find(
                        s => s.stepName === parentPlanStep.name && s.runId === stepState!.runId
                    );
                    if (parentStepState) {
                        const parentKey = parentStepState.taskId || parentStepState.stepName;
                        const parentElement = this.stepElementsCache.get(parentKey);
                        if (parentElement) {
                            const subStepsContainer = parentElement.querySelector('.sub-steps-container') as HTMLElement;
                            if (subStepsContainer) {
                                this.updateSubStepsContainerRendering(subStepsContainer, parentStepState);
                                return; // Handled locally
                            }
                        }
                    }
                }
            }
            // Fallback to full render if sub-step parent not found/rendered, or if it's a new top-level step
            this.render();
        } else {
            // Status update for an existing, rendered step
            const stepElement = this.stepElementsCache.get(stepKey);
            if (stepElement) {
                this.updateElementHeaderAndError(stepElement, stepState!);
            }
        }
    }


    public addStepLog(update: StepUpdate) {
        const stepKey = update.taskId ||
            (this.plan.steps.find(s => s.name === update.metadata?.stepNameHint)?.name) ||
            'global_logs';

        const stepState = this.executionState.get(stepKey) || Array.from(this.executionState.values()).find(s => s.stepName === stepKey);

        if (stepState && (update.type === 'input' || update.type === 'output' || update.type === 'llm-request')) {
            stepState.logs.push({ type: update.type, data: update.data, metadata: update.metadata });

            const stepElement = this.stepElementsCache.get(stepKey);
            if (stepElement) {
                const contentWrapper = stepElement.querySelector(stepElement.classList.contains('sub-step') ? '.sub-step-content-wrapper' : '.step-content-wrapper') as HTMLElement;
                if (contentWrapper) {
                    const logsContainer = contentWrapper.querySelector('.logs-wrapper') as HTMLElement;
                    if (logsContainer) {
                        const newLogElement = this.renderLogItem({ type: update.type, data: update.data, metadata: update.metadata });
                        logsContainer.appendChild(newLogElement);
                        // Potentially scroll the logs container if needed
                        logsContainer.scrollTop = logsContainer.scrollHeight;
                    } else {
                        // Logs container doesn't exist, might need to re-render step internals for this step
                        // This case should be rare if renderStepInternals always creates it.
                        contentWrapper.innerHTML = this.renderStepInternals(stepState);
                    }
                }
            }
        }
    }

    public appendStreamChunk(chunk: StreamChunk) {
        const stepKey = chunk.taskId;
        if (!stepKey) {
            console.warn('AgentRunBlock: StreamChunk received without taskId.', chunk);
            return;
        }

        const stepState = this.executionState.get(stepKey);
        if (stepState) {
            stepState.streamedContent += chunk.content;

            const stepElement = this.stepElementsCache.get(stepKey);
            if (stepElement) {
                const contentWrapper = stepElement.querySelector(stepElement.classList.contains('sub-step') ? '.sub-step-content-wrapper' : '.step-content-wrapper') as HTMLElement;
                if (contentWrapper) {
                    let streamWrapper = contentWrapper.querySelector('.stream-wrapper') as HTMLElement;
                    if (!streamWrapper) {
                        // If stream wrapper doesn't exist, create it (e.g. by re-rendering internals for this step)
                        // This is a fallback; ideally, renderStepInternals would have set it up.
                        // A simpler approach for now is to just re-render the step's internals fully if the stream wrapper isn't found.
                        // However, a more robust way is to ensure renderStepInternals always creates these wrappers.
                        contentWrapper.innerHTML = this.renderStepInternals(stepState); //This will create the stream-wrapper
                        streamWrapper = contentWrapper.querySelector('.stream-wrapper') as HTMLElement; // Re-query
                    }
                    if (streamWrapper) {
                        streamWrapper.innerHTML = this.renderStreamedContent(stepState.streamedContent); // renderStreamedContent returns HTML for the content *inside* the wrapper
                    }
                }
            }
        } else {
            console.warn(`AgentRunBlock: Could not find step state for taskId '${stepKey}' to append stream chunk.`);
        }
    }

    public setAgentResult(result: AgentResult) {
        this.status = result.status;
        this.agentResult = result;
        // 如果Agent被取消或失败，遍历所有正在执行的步骤，并将它们标记为失败。
        if (result.status === 'cancelled' || result.status === 'failed') {
            this.executionState.forEach(stepState => {
                if (stepState.status === 'running' || stepState.status === 'waiting') {
                    stepState.status = 'failed'; // 将状态强制更新为 'failed'
                    // 可以添加一条错误信息，解释为什么这个步骤失败了
                    stepState.error = 'Execution was cancelled or failed.'; 
                }
            });
        }
        this.render();
    }

    private render() {
        // 如果 onExecute 为 null，说明是从历史记录中恢复的，始终为只读状态
        const isPlanningReadOnly = (this.status !== 'planning' && this.status !== 'validating') || this.onExecute === null;

        const planningViewContainer = this.element.querySelector('.planning-view-container');
        if (!planningViewContainer) {
            this.element.innerHTML = `<div class="planning-view-container"></div><div class="executing-view-container"></div>`;
        }
        const planningContainer = this.element.querySelector('.planning-view-container') as HTMLElement;
        planningContainer.innerHTML = this.renderPlanningView(isPlanningReadOnly);

        const executingViewContainer = this.element.querySelector('.executing-view-container') as HTMLElement;
        if (isPlanningReadOnly) {
            if (!executingViewContainer.classList.contains('active')) {
                this.animatedStepIds.clear();
                // Do NOT clear stepElementsCache here if we want to preserve elements across minor re-renders
                // this.stepElementsCache.clear(); 
                executingViewContainer.classList.add('active');
            }
            this.renderExecutingViewContents(executingViewContainer);
        } else {
            executingViewContainer.classList.remove('active');
            executingViewContainer.innerHTML = '';
        }
        this.postRender();
    }

    private renderExecutingViewContents(container: HTMLElement) {
        const statusClassMapping: Record<AgentStatus, string> = { /* ... */ planning: 'planning', validating: 'planning', executing: 'executing', completed: 'completed', failed: 'failed', cancelled: 'failed'};
        const statusClass = statusClassMapping[this.status] || 'executing';
        const statusText = this.status.charAt(0).toUpperCase() + this.status.slice(1);

        if (!this.executionStepsOuterContainer || !container.contains(this.executionStepsOuterContainer)) {
            container.innerHTML = `
            <div class="executing-view">
                <div class="agent-header">
                    <h4>执行过程</h4>
                    <span class="badge ${statusClass}">${statusText}</span>
                </div>
                <div class="execution-steps-outer-container"></div>
                <div class="final-result-container"></div>
            </div>`;
            this.executionStepsOuterContainer = container.querySelector('.execution-steps-outer-container') as HTMLElement;
        } else {
            const badge = container.querySelector('.executing-view .agent-header .badge') as HTMLElement;
            if (badge) {
                badge.className = `badge ${statusClass}`;
                badge.textContent = statusText;
            }
        }
        
        // Ensure executionStepsOuterContainer is defined
        if (!this.executionStepsOuterContainer) {
             this.executionStepsOuterContainer = container.querySelector('.execution-steps-outer-container') as HTMLElement;
             if (!this.executionStepsOuterContainer) return; // Should not happen
        }

        // 清理旧的DOM元素，并根据当前状态重新渲染
        this.executionStepsOuterContainer.innerHTML = '';
        this.stepElementsCache.clear();

        this.plan.steps.forEach((planStep, index) => {
            // 从 state 中找到所有与 planStep 匹配的顶级执行步骤
            // 这很重要，因为从历史恢复时，executionState 是预先填充好的
            const executionStepState = Array.from(this.executionState.values())
                .find(s => s.stepName === planStep.name && !s.stepName.startsWith("分析模块:"));

            if (!executionStepState) {
                // 如果是实时执行，可能会暂时没有状态，直接跳过
                // 如果是从历史恢复，这里不应该发生
                return;
            }

            const stepMapKey = executionStepState.taskId || executionStepState.stepName;
            let stepElement = this.stepElementsCache.get(stepMapKey);

            if (!stepElement) {
                let animationClass = '';
                 // 从历史恢复时，不应用动画
                if (!isAgentRunRecord(this.plan) && !this.animatedStepIds.has(stepMapKey)) {
                    animationClass = 'needs-animation';
                    this.animatedStepIds.add(stepMapKey);
                }
                const isParallel = planStep.name === "分析: 并行处理模块"; // Heuristic
                const stepHtml = isParallel
                    ? this.getParallelAnalysisStepHtml(planStep, index, executionStepState, animationClass)
                    : this.getExecutionStepHtml(executionStepState, planStep, index, animationClass);

                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = stepHtml.trim();
                stepElement = tempDiv.firstChild as HTMLElement;

                if (stepElement) {
                    this.executionStepsOuterContainer!.appendChild(stepElement);
                    this.stepElementsCache.set(stepMapKey, stepElement);
                }
            } else {
                 // 理论上，因为我们清理了 outer container，这个分支在当前逻辑下不会被走到
                this.updateStepElement(stepElement, executionStepState, planStep, planStep.name === "分析: 并行处理模块", index);
            }
        });

        const finalResultContainer = container.querySelector('.final-result-container') as HTMLElement;
        if (this.agentResult) {
            this.renderOrUpdateFinalResult(finalResultContainer);
        } else {
            finalResultContainer.innerHTML = '';
        }
    }

    private updateStepElement(element: HTMLElement, stepState: ExecutionStepState, planStep: AgentPlanStep, isParallel: boolean, index: number) {
        this.updateElementHeaderAndError(element, stepState); // Update header and error

        const contentWrapper = element.querySelector('.step-content-wrapper') as HTMLElement;
        if (contentWrapper) {
            contentWrapper.style.maxHeight = stepState.isCollapsed ? '0' : (isParallel ? '5000px' : '2000px');
            contentWrapper.style.padding = stepState.isCollapsed ? '0 15px' : '10px 15px';

            if (isParallel) {
                const subStepsContainer = contentWrapper.querySelector('.sub-steps-container') as HTMLElement;
                if (subStepsContainer) {
                    this.updateSubStepsContainerRendering(subStepsContainer, stepState);
                }
            } else {
                // Only set innerHTML for content if the wrapper is empty (initial population)
                // OR if there are logs/stream/error to display and it wasn't populated before.
                // This prevents re-rendering content if it's managed by targeted updates.
                const needsContentPopulation = !contentWrapper.querySelector('.logs-wrapper') && !contentWrapper.querySelector('.stream-wrapper');
                if (needsContentPopulation && (stepState.logs.length > 0 || stepState.streamedContent || stepState.error)) {
                    contentWrapper.innerHTML = this.renderStepInternals(stepState);
                } else if (contentWrapper.children.length === 0 && (stepState.logs.length > 0 || stepState.streamedContent || stepState.error)) {
                    // Fallback if specific wrappers are not used and content is empty
                    contentWrapper.innerHTML = this.renderStepInternals(stepState);
                }
                // If content exists, assume addStepLog/appendStreamChunk will handle it.
            }
        }
    }
    
    // New helper to specifically update header and error parts of a step element
    private updateElementHeaderAndError(element: HTMLElement, stepState: ExecutionStepState) {
        const baseClass = element.classList.contains('sub-step') ? 'sub-step' : 'execution-step';
        element.className = `${baseClass} ${stepState.status}`; // Animation might be re-added if logic desires

        const statusIconEl = element.querySelector('.status-icon');
        if (statusIconEl) statusIconEl.innerHTML = this.getIconForStatus(stepState.status);
        
        const stepStatusEl = element.querySelector('.step-status'); // For top-level steps
        if (stepStatusEl) stepStatusEl.textContent = stepState.status;

        // Update error message
        let errorWrapper = element.querySelector('.step-error-wrapper') as HTMLElement;
        if (stepState.error) {
            if (!errorWrapper) {
                // Find content wrapper to append error to
                const contentWrapper = element.querySelector(baseClass === 'sub-step' ? '.sub-step-content-wrapper' : '.step-content-wrapper') as HTMLElement;
                if (contentWrapper) {
                    errorWrapper = document.createElement('div');
                    errorWrapper.className = 'step-error-wrapper';
                    contentWrapper.appendChild(errorWrapper); // Append, not replace all content
                }
            }
            if (errorWrapper) errorWrapper.innerHTML = `<div class="step-error">${stepState.error}</div>`;
        } else {
            if (errorWrapper) errorWrapper.innerHTML = ''; // Clear error
        }
    }


    private updateSubStepsContainerRendering(container: HTMLElement, parentStepState: ExecutionStepState) {
        const subStepStates = Array.from(this.executionState.values()).filter(s =>
            s.stepName.startsWith("分析模块:") && s.runId === parentStepState.runId
        );

        const existingSubStepElements = new Map<string, HTMLElement>();
        container.querySelectorAll<HTMLElement>('.sub-step').forEach(el => {
            if (el.dataset.taskId) existingSubStepElements.set(el.dataset.taskId, el);
        });
        
        let newHtmlForSubSteps = '';
        if (subStepStates.length > 0) {
            newHtmlForSubSteps = subStepStates.map(subState => {
                 const subStepKey = subState.taskId!;
                 let animationClass = '';
                 // Check if this sub-step was already animated or if it's new to this render pass
                 if (!this.animatedStepIds.has(subStepKey) && !existingSubStepElements.has(subStepKey)) {
                     animationClass = 'needs-animation';
                     // this.animatedStepIds.add(subStepKey); // Add when actually appended
                 }
                const existingElement = existingSubStepElements.get(subStepKey);
                if (existingElement) {
                     // If exists, we might want to preserve it and update, but for now, full re-render of sub-step list
                     // For more granular, we'd call updateStepElement on existingElement here.
                    // For simplicity in this pass, this method will still use innerHTML for the whole sub-steps list.
                    // A truly granular update would diff this list.
                }
                 return this.getSubStepHtml(subState, animationClass);
             }).join('');
        } else if (parentStepState.status === 'running') {
            newHtmlForSubSteps = '<div class="sub-step-placeholder">等待模块分析任务启动...</div>';
        }
        
        container.innerHTML = newHtmlForSubSteps;

        // After setting innerHTML, re-query and add new animated IDs
        container.querySelectorAll<HTMLElement>('.sub-step.needs-animation').forEach(el => {
            if (el.dataset.taskId) this.animatedStepIds.add(el.dataset.taskId);
        });
        // Also update cache for new sub-steps
        subStepStates.forEach(subState => {
            const subStepKey = subState.taskId!;
            if (!this.stepElementsCache.has(subStepKey)) {
                const newEl = container.querySelector(`.sub-step[data-task-id="${subStepKey}"]`) as HTMLElement;
                if (newEl) this.stepElementsCache.set(subStepKey, newEl);
            }
        });
    }

    private renderStepInternals(stepState: ExecutionStepState): string {
        // Ensure this method creates the distinct wrappers
        const logsHtml = stepState.logs.map(log => this.renderLogItemToString(log)).join(''); // Temporarily back to string
        let waitingPlaceholderHtml = '';
        // ... (waiting placeholder logic) ...
        const streamRendered = this.renderStreamedContent(stepState.streamedContent); // This returns HTML for *inside* the stream wrapper
        const errorHtml = stepState.error ? `<div class="step-error">${stepState.error}</div>` : '';

        return `
            <div class="logs-wrapper">${logsHtml}</div>
            ${waitingPlaceholderHtml}
            <div class="stream-wrapper">${streamRendered}</div>
            <div class="step-error-wrapper">${errorHtml}</div>
        `;
    }
    
    // New: Renders a single log item to an HTML string for renderStepInternals
    private renderLogItemToString(log: { type: string, data: any, metadata?: Record<string, any> }): string {
        // ... (logic from original renderLogItem to build HTML string for one log) ...
        let content = '';
        const logDataName = log.data && typeof log.data === 'object' && 'name' in log.data ? log.data.name : '';
        const logContent = log.data && typeof log.data === 'object' && 'content' in log.data
            ? (typeof log.data.content === 'string' ? log.data.content : JSON.stringify(log.data.content, null, 2))
            : (typeof log.data === 'string' ? log.data : JSON.stringify(log.data, null, 2));

        if (log.metadata?.type === 'file') {
            content = this.renderFileCard(log.metadata.path, logDataName);
        } else {
            content = `<pre><code>${logContent}</code></pre>`;
        }
        const iconHtml = this.getIconForLogType(log.type);
        const titleText = `${log.type.toUpperCase()}${logDataName ? ': ' + logDataName : ''}`;
        const isLargeInput = log.type === 'input' && logContent.length > 500 && logContent.includes('\n');
        const collapsedClass = isLargeInput ? 'collapsed' : '';

        return `<div class="log-item log-${log.type} ${collapsedClass}"><div class="log-header">${iconHtml}<span>${titleText}</span></div><div class="log-content-wrapper">${content}</div></div>`;
    }

    // Changed: renderLogItem now returns HTMLElement for direct DOM append
    private renderLogItem(log: { type: string, data: any, metadata?: Record<string, any> }): HTMLElement {
        let content = '';
        const logDataName = log.data && typeof log.data === 'object' && 'name' in log.data ? log.data.name : '';
        const logContentText = log.data && typeof log.data === 'object' && 'content' in log.data
            ? (typeof log.data.content === 'string' ? log.data.content : JSON.stringify(log.data.content, null, 2))
            : (typeof log.data === 'string' ? log.data : JSON.stringify(log.data, null, 2));

        if (log.metadata?.type === 'file') {
            content = this.renderFileCard(log.metadata.path, logDataName);
        } else {
            content = `<pre><code>${logContentText}</code></pre>`;
        }
        const iconHtml = this.getIconForLogType(log.type);
        const titleText = `${log.type.toUpperCase()}${logDataName ? ': ' + logDataName : ''}`;
        const isLargeInput = log.type === 'input' && logContentText.length > 500 && logContentText.includes('\n');
        const collapsedClass = isLargeInput ? 'collapsed' : '';
        
        const logItemElement = document.createElement('div');
        logItemElement.className = `log-item log-${log.type} ${collapsedClass}`;
        logItemElement.innerHTML = `<div class="log-header">${iconHtml}<span>${titleText}</span></div><div class="log-content-wrapper">${content}</div>`;
        return logItemElement;
    }


    private renderStreamedContent(content: string): string {
        // This method returns the HTML string for the *content* of the stream wrapper
        if (!content) return '';
        const htmlContent = marked.parse(content, { gfm: true, breaks: true });
        // The class 'markdown-body' should be on the wrapper if specific styling is needed
        return `<div class="markdown-body">${htmlContent}</div>`; 
    }

    // --- Other methods (getExecutionStepHtml, getParallelAnalysisStepHtml, getSubStepHtml, renderPlanningView, etc.) largely remain the same for initial HTML string generation ---
    // Make sure they call renderStepInternals when creating content.

    private getExecutionStepHtml(stepState: ExecutionStepState, planStep: { name: string }, index: number, animationClass: string): string {
        const state = stepState.status;
        const taskIdAttr = stepState.taskId ? `data-task-id="${stepState.taskId}"` : '';
        const contentWrapperStyle = stepState.isCollapsed ? 'max-height: 0px; padding: 0px 15px;' : 'max-height: 2000px; padding: 10px 15px;';
        return `
            <div class="execution-step ${state} ${animationClass}" data-step-name="${planStep.name}" ${taskIdAttr}>
                <div class="step-header">
                    <span class="status-icon">${this.getIconForStatus(state)}</span>
                    <span class="step-name"><b>Step ${index + 1}:</b> ${planStep.name}</span>
                    <span class="step-status">${state}</span>
                </div>
                <div class="step-content-wrapper" style="${contentWrapperStyle}">
                    ${this.renderStepInternals(stepState)}
                </div>
            </div>
        `;
    }

    private getParallelAnalysisStepHtml(planStep: AgentPlanStep, index: number, parentStepState: ExecutionStepState, animationClass: string): string {
        const state = parentStepState.status;
        const taskIdAttr = parentStepState.taskId ? `data-task-id="${parentStepState.taskId}"` : '';
        // Initial sub-steps rendering (likely empty or placeholder if just started)
        const subStepsHtml = this.renderSubStepsContainerInitial(parentStepState);
        const contentWrapperStyle = parentStepState.isCollapsed ? 'max-height: 0px; padding: 0px 15px;' : 'max-height: 5000px; padding: 10px 15px;';

        return `
            <div class="execution-step ${state} ${animationClass}" data-step-name="${planStep.name}" ${taskIdAttr}>
                <div class="step-header">
                    <span class="status-icon">${this.getIconForStatus(state)}</span>
                    <span class="step-name"><b>Step ${index + 1}:</b> ${planStep.name}</span>
                    <span class="step-status">${state}</span>
                </div>
                <div class="step-content-wrapper" style="${contentWrapperStyle}">
                     <div class="sub-steps-container">
                        ${subStepsHtml}
                    </div>
                    ${this.renderStepInternals(parentStepState)} 
                </div>
            </div>
        `;
    }
    
    // Renders the initial HTML for the sub-steps container (used during creation of parent step)
    private renderSubStepsContainerInitial(parentStepState: ExecutionStepState): string {
        const subSteps = Array.from(this.executionState.values()).filter(s =>
            s.stepName.startsWith("分析模块:") && s.runId === parentStepState.runId
        );
        if (subSteps.length > 0) {
            return subSteps.map(sub => {
                const subStepMapKey = sub.taskId || sub.stepName;
                let subAnimationClass = ''; // No animation on initial parent render for existing sub-steps
                return this.getSubStepHtml(sub, subAnimationClass);
            }).join('');
        } else if (parentStepState.status === 'running' || parentStepState.status === 'waiting') {
            return '<div class="sub-step-placeholder">等待模块分析任务启动...</div>';
        }
        return '';
    }


    private getSubStepHtml(subStep: ExecutionStepState, animationClass: string): string {
        const contentWrapperStyle = subStep.isCollapsed ? 'max-height: 0px; padding: 0px 10px;' : 'max-height: 2000px; padding: 10px;';
        return `
            <div class="sub-step ${subStep.status} ${animationClass}" data-task-id="${subStep.taskId}">
                 <div class="sub-step-header">
                    <span class="status-icon">${this.getIconForStatus(subStep.status)}</span>
                    <span class="step-name">${subStep.stepName}</span>
                </div>
                <div class="sub-step-content-wrapper" style="${contentWrapperStyle}">
                    ${this.renderStepInternals(subStep)}
                </div>
            </div>
        `;
    }
    
    // renderPlanningView, renderStepCard, renderParameterInput, getIconForStatus, renderFinalResult, setupEventListeners, postRender remain the same
    private renderPlanningView(isReadOnly: boolean): string {
        const badgeClass = this.status === 'planning' || this.status === 'validating' ? 'planning' : (this.status === 'executing' ? 'executing' : 'completed');
        const badgeText = this.status === 'planning' || this.status === 'validating' ? '待执行' : (this.status === 'executing' ? '运行中' : '规划已锁定');

        const renderAgentActions = (status: AgentStatus) => {
            // 如果 onExecute 为 null (从历史恢复)，则不显示任何操作按钮
            if (this.onExecute === null) {
                return '';
            }
            if (status === 'executing') {
                return `<button class="stop-btn secondary"><i class="codicon codicon-stop-circle"></i> 停止执行</button>`;
            }
            if (status === 'planning' || status === 'validating') {
                return `
                    <button class="execute-btn"><i class="codicon codicon-play"></i> 开始执行</button>
                    <button class="cancel-btn secondary"><i class="codicon codicon-close"></i> 取消</button>
                `;
            }
            return '';
        };

        return `
            <div class="planning-view ${isReadOnly ? 'read-only' : ''}">
                <div class="agent-header">
                    <h4>${this.plan.agentName}</h4>
                    <span class="badge ${badgeClass}">${badgeText}</span>
                </div>
                <div class="agent-plan-steps">
                    <h5>执行计划</h5>
                    ${this.plan.steps.map(step => this.renderStepCard(step)).join('')}
                </div>
                ${this.plan.parameters.length > 0 ? `
                    <div class="agent-parameters">
                        <h5>参数</h5>
                        ${this.plan.parameters.map(param => this.renderParameterInput(param, isReadOnly)).join('')}
                    </div>
                ` : ''}
                <div class="agent-actions" style="display: ${this.status === 'completed' || this.status === 'failed' || this.status === 'cancelled' ? 'none' : 'flex'};">
                    ${renderAgentActions(this.status)}
                </div>
            </div>
        `;
    }
    private renderStepCard(step: AgentPlanStep): string {
        return `
            <div class="step-card">
                <div class="step-card-name">${step.name}</div>
                <div class="step-card-desc">${step.description}</div>
                ${step.promptFiles && step.promptFiles.length > 0 ? `
                    <div class="prompt-files-container">
                        ${step.promptFiles.map(file => this.renderFileCard(file)).join('')}
                    </div>
                ` : ''}
            </div>
        `;
    }
    private renderParameterInput(param: { name: string, description: string, type: string, value?: any, isValid?: boolean, error?: string }, isReadOnly: boolean): string {
        const isInvalid = param.error ? 'invalid' : '';
        const value = param.value || '';
        return `
            <div class="parameter-item">
                <label for="param-${param.name}">${param.name}</label>
                <div class="parameter-description">${param.description}</div>
                <input type="text" id="param-${param.name}" name="${param.name}" class="${isInvalid}" value="${value}" ${isReadOnly ? 'disabled' : ''}>
                ${param.error ? `<div class="error-text">${param.error}</div>` : ''}
            </div>
        `;
    }
    private renderFileCard(filePath: string, displayName?: string): string {
        const fileName = displayName || filePath.split(/[\\/]/).pop() || 'file';
        let icon = 'codicon-file';
        if (fileName.endsWith('.md')) icon = 'codicon-markdown';
        if (fileName.endsWith('.json')) icon = 'codicon-json';
        if (fileName.endsWith('.yml') || fileName.endsWith('.yaml')) icon = 'codicon-symbol-keyword';
        if (fileName.endsWith('.txt')) icon = 'codicon-file-code';
        return `<div class="file-card" data-file-path="${filePath}" title="${filePath}"><i class="codicon ${icon}"></i><span>${fileName}</span></div>`;
    }
    private getIconForLogType(logType: string): string {
        switch (logType) {
            case 'input': return '<i class="codicon codicon-arrow-right"></i>';
            case 'output': return '<i class="codicon codicon-arrow-left"></i>';
            case 'llm-request': return '<i class="codicon codicon-comment"></i>';
            case 'llm-stream': return '<i class="codicon codicon-wand"></i>';
            default: return '';
        }
    }
    private getIconForStatus(status: string): string {
        switch (status) {
            case 'running': return '<i class="codicon codicon-loading codicon-spin"></i>';
            case 'completed': return '<i class="codicon codicon-check"></i>';
            case 'failed': return '<i class="codicon codicon-error"></i>';
            case 'waiting': return '<i class="codicon codicon-more"></i>';
            default: return '';
        }
    }
    private renderOrUpdateFinalResult(container: HTMLElement) { // Was renderFinalResult()
        if (!this.agentResult) {
            container.innerHTML = '';
            this.stepElementsCache.delete('__agent_final_result__');
            return;
        }

        let resultElement = this.stepElementsCache.get('__agent_final_result__');
        const resultKey = '__agent_final_result__';
        let animationClass = '';

        if (!resultElement) {
            // 从历史恢复时，不应用动画
            if (!isAgentRunRecord(this.plan) && !this.animatedStepIds.has(resultKey)) {
                animationClass = 'needs-animation';
                this.animatedStepIds.add(resultKey);
            }
            const resultHtml = this.getFinalResultHtml(animationClass); 
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = resultHtml.trim();
            resultElement = tempDiv.firstChild as HTMLElement;
            if (resultElement) {
                container.innerHTML = ''; 
                container.appendChild(resultElement);
                this.stepElementsCache.set(resultKey, resultElement);
            }
        } else {
            resultElement.className = `agent-final-result ${this.agentResult.status} ${animationClass}`;
            const iconEl = resultElement.querySelector('.result-header .codicon') as HTMLElement;
            const titleEl = resultElement.querySelector('.result-header span') as HTMLElement;
            const contentEl = resultElement.querySelector('.result-content') as HTMLElement;

            const isCompleted = this.agentResult.status === 'completed';
            if (iconEl) iconEl.className = `codicon ${isCompleted ? 'codicon-check-all' : 'codicon-error'}`;
            if (titleEl) titleEl.textContent = isCompleted ? 'Agent Execution Completed' : 'Agent Execution Failed';

            if (contentEl) {
                let newContentHtml = '';
                 if (isCompleted && this.agentResult.stats) {
                    const stats = this.agentResult.stats;
                    newContentHtml = `
                        <div class="result-stats">
                            <div class="stat-item"><i class="codicon codicon-clock"></i><span>耗时</span><strong>${stats.duration}</strong></div>
                            <div class="stat-item"><i class="codicon codicon-symbol-event"></i><span>总 Tokens</span><strong>${stats.totalTokens.toLocaleString()}</strong></div>
                            <div class="stat-item"><i class="codicon codicon-arrow-right"></i><span>输入 Tokens</span><strong>${stats.promptTokens.toLocaleString()}</strong></div>
                            <div class="stat-item"><i class="codicon codicon-arrow-left"></i><span>输出 Tokens</span><strong>${stats.completionTokens.toLocaleString()}</strong></div>
                        </div>`;
                } else if (!isCompleted) {
                    newContentHtml = `<div class="error-text">${this.agentResult.error || '未知错误'}</div>`;
                }
                // Only update if different to avoid flicker
                if (contentEl.innerHTML !== newContentHtml) {
                     contentEl.innerHTML = newContentHtml;
                }
            }
        }
    }
    private getFinalResultHtml(animationClass: string): string {
        if (!this.agentResult) return '';
        const resultClass = this.agentResult.status;
        const icon = resultClass === 'completed' ? '<i class="codicon codicon-check-all"></i>' : '<i class="codicon codicon-error"></i>';
        const title = resultClass === 'completed' ? 'Agent Execution Completed' : 'Agent Execution Failed';
        let contentHtml = '';
        if (resultClass === 'completed' && this.agentResult.stats) {
            const stats = this.agentResult.stats;
            contentHtml = `
                <div class="result-stats">
                    <div class="stat-item"><i class="codicon codicon-clock"></i><span>耗时</span><strong>${stats.duration}</strong></div>
                    <div class="stat-item"><i class="codicon codicon-symbol-event"></i><span>总 Tokens</span><strong>${stats.totalTokens.toLocaleString()}</strong></div>
                    <div class="stat-item"><i class="codicon codicon-arrow-right"></i><span>输入 Tokens</span><strong>${stats.promptTokens.toLocaleString()}</strong></div>
                    <div class="stat-item"><i class="codicon codicon-arrow-left"></i><span>输出 Tokens</span><strong>${stats.completionTokens.toLocaleString()}</strong></div>
                </div>`;
        } else if (resultClass !== 'completed') {
            contentHtml = `<div class="error-text">${this.agentResult.error || '未知错误'}</div>`;
        }
        return `<div class="agent-final-result ${resultClass} ${animationClass}"><div class="result-header">${icon}<span>${title}</span></div><div class="result-content">${contentHtml}</div></div>`;
    }
    private setupEventListeners() {
        this.element.addEventListener('click', (e) => { 
            const target = e.target as HTMLElement;
            const logHeader = target.closest('.log-header');
            if (logHeader) {
                const logItem = logHeader.closest('.log-item');
                if (logItem) {
                    e.stopPropagation();
                    logItem.classList.toggle('collapsed');
                    return; 
                }
            }
            // Event listener for agent actions (start, stop, cancel)
            const actionsContainer = target.closest('.agent-actions');
            if (actionsContainer) {
                const executeBtn = target.closest('.execute-btn');
                const cancelBtn = target.closest('.cancel-btn');
                const stopBtn = target.closest('.stop-btn');

                if (executeBtn) {
                    if (!this.onExecute) return; // 从历史恢复时，onExecute 为 null
                    const params: Record<string, any> = {};
                    let allValid = true;
                    this.plan.parameters.forEach(p => {
                        const input = this.element.querySelector(`#param-${p.name}`) as HTMLInputElement;
                        if (input) {
                            const value = input.value.trim();
                            if (!value && p.type === 'path') { p.error = 'This field is required.'; allValid = false; }
                            else { p.error = undefined; params[p.name] = value; p.value = value; }
                        }
                    });
                    this.status = allValid ? 'executing' : 'validating';
                    this.render(); 
                    if (allValid) this.onExecute(params); 
                    return;
                }
                if (cancelBtn) {
                    // 如果 onCancel 回调存在，就调用它
                    if (this.onCancel) {
                        this.onCancel();
                    } else {
                        // 否则，作为后备，只移除元素（不应该发生）
                        this.element.remove();
                    }
                    return;
                }
                if (stopBtn) {
                    if (this.runId) {
                        vscode.postMessage({ command: 'agent:cancel', payload: { runId: this.runId } });
                    } else {
                        console.warn('Stop button clicked, but no runId is available.');
                        this.element.remove();
                    }
                    return;
                }
            }
            const fileCard = target.closest('.file-card');
            if (fileCard) {
                e.stopPropagation(); 
                const filePath = (fileCard as HTMLElement).dataset.filePath;
                if (filePath) {
                    vscode.postMessage({ command: 'viewFile', payload: { path: filePath } });
                }
                return;
            }
            const stepHeader = target.closest('.step-header, .sub-step-header');
            if (stepHeader) {
                e.stopPropagation();
                const stepElement = stepHeader.closest('.execution-step, .sub-step');
                if (stepElement instanceof HTMLElement) {
                    const stepName = stepElement.dataset.stepName;
                    const taskId = stepElement.dataset.taskId;
                    const key = taskId || stepName;
                    if (key) {
                        const state = this.executionState.get(key);
                        if (state) {
                            state.isCollapsed = !state.isCollapsed;
                            const contentWrapper = stepElement.querySelector('.step-content-wrapper, .sub-step-content-wrapper') as HTMLElement;
                            if (contentWrapper) {
                                const isParallel = stepElement.classList.contains('execution-step') && !!stepElement.querySelector('.sub-steps-container');
                                contentWrapper.style.maxHeight = state.isCollapsed ? '0' : (isParallel ? '5000px' : '2000px');
                                contentWrapper.style.padding = state.isCollapsed ? '0 15px' : '10px 15px';
                            }
                        }
                    }
                }
                return;
            }
        });
    }
    private postRender() { /* For future use */ }
}

--------------------------------------------------------------------------------

--- file_path: webview/components/AtCommandMenu.ts ---
// --- file_path: webview/components/AtCommandMenu.ts ---

// 定义命令节点的接口
interface CommandNode {
    id: string;
    name: string;
    children: (CommandNode | CommandLeaf)[];
}

// 定义命令叶子节点（可执行的Agent）的接口
interface CommandLeaf {
    id: string;
    name: string;
    agentId: string; // 对应 AgentService 中的 ID
    description: string;
}

// 类型守卫，用于判断一个节点是否是叶子节点
function isLeaf(node: CommandNode | CommandLeaf): node is CommandLeaf {
    return !('children' in node);
}

// 所有可用命令的树状结构定义
const COMMAND_TREE: (CommandNode | CommandLeaf)[] = [
    {
        id: 'docgen',
        name: 'DocGen',
        children: [
            {
                id: 'docgen-project',
                name: 'DocGen-Project',
                agentId: 'docgen-project',
                description: '生成项目级软件实现设计文档'
            },
            {
                id: 'docgen-module-direct',
                name: 'DocGen-Module-Direct',
                agentId: 'docgen-module-direct',
                description: '采用直接分析的方式，生成模块级详细设计文档'
            },
            {
                id: 'docgen-module-mapreduce',
                name: 'DocGen-Module-MapReduce',
                agentId: 'docgen-module-mapreduce',
                description: '对大模块进行分批摘要总结分析，生成模块级详细设计文档'
            }
        ]
    },
    // 未来可以添加更多一级命令, e.g., CodeRefactor, TestGen etc.
];


export class AtCommandMenu {
    private element: HTMLElement;
    private onSelect: (command: CommandLeaf) => void = () => {};
    
    // 状态管理
    private commands: (CommandNode | CommandLeaf)[] = COMMAND_TREE;
    private currentPath: CommandNode[] = []; // 导航路径
    private visibleItems: (CommandNode | CommandLeaf)[] = []; // 当前显示的列表
    private activeIndex: number = -1; // 当前高亮的索引
    private isSearchMode: boolean = false; // 是否为搜索模式
    private filterText: string = ''; // 搜索文本

    constructor(private container: HTMLElement) {
        // 直接使用传入的容器作为菜单的根元素
        this.element = container;
        this.element.className = 'at-command-menu'; // 确保 class 正确
        this.element.style.display = 'none'; // 默认隐藏

        // 事件监听器直接绑定到容器上
        this.element.addEventListener('click', (e) => {
            const li = (e.target as HTMLElement).closest('li');
            if (li) {
                const index = parseInt(li.dataset.index || '-1', 10);
                if (index !== -1) {
                    this.activeIndex = index;
                    this.handleSelection();
                }
            }
        });
    }

    /**
     * 显示并初始化菜单。
     * @param filter 用户输入的 @ 后面的文本
     * @param onSelect 选择命令后的回调
     */
    public show(filter: string, onSelect: (command: CommandLeaf) => void) {
        this.onSelect = onSelect;
        this.filterText = filter.trim().toLowerCase();
        
        
        // 强制禁用搜索模式，总是显示层级菜单
        this.isSearchMode = false;
        

        this.currentPath = [];
        this.activeIndex = 0;
        
        // 逻辑大幅简化：只需显示并渲染
        this.element.style.display = 'block';
        this.render(); 
    }



    public hide() {
        this.element.style.display = 'none';
        this.currentPath = [];
        this.activeIndex = -1;
    }

    public isVisible(): boolean {
        return this.element.style.display !== 'none';
    }

    /**
     * 处理键盘事件，由 ChatView 委托
     */
    public handleKeyDown(e: KeyboardEvent) {
        if (!this.isVisible()) return;

        e.preventDefault();
        e.stopPropagation();

        switch (e.key) {
            case 'ArrowDown':
                this.activeIndex = (this.activeIndex + 1) % this.visibleItems.length;
                this.render();
                break;
            case 'ArrowUp':
                this.activeIndex = (this.activeIndex - 1 + this.visibleItems.length) % this.visibleItems.length;
                this.render();
                break;
            case 'Tab':
            case 'Enter':
                this.handleSelection();
                break;
            case 'Escape':
                if (this.currentPath.length > 0) {
                    this.currentPath.pop();
                    this.activeIndex = 0;
                    this.render();
                } else {
                    this.hide();
                }
                break;
        }
    }

    /**
     * 处理用户通过 Enter/Tab/Click 进行的选择
     */
    private handleSelection() {
        if (this.activeIndex < 0 || this.activeIndex >= this.visibleItems.length) return;

        const selectedItem = this.visibleItems[this.activeIndex];
        if (isLeaf(selectedItem)) {
            this.onSelect(selectedItem);
            this.hide();
        } else {
            // 进入下一级
            this.currentPath.push(selectedItem);
            this.activeIndex = 0;
            this.render();
        }
    }

    /**
     * 渲染菜单的当前视图
     */
    private render() {
        if (this.isSearchMode) {
            this.renderSearchResults();
        } else {
            this.renderHierarchicalView();
        }
    }

    private renderHierarchicalView() {
        let itemsToShow: (CommandNode | CommandLeaf)[];
        let parent: CommandNode | undefined = this.currentPath[this.currentPath.length - 1];
        
        if (parent) {
            itemsToShow = parent.children;
        } else {
            itemsToShow = this.commands;
        }

        this.visibleItems = itemsToShow;
        if (this.activeIndex >= this.visibleItems.length) {
            this.activeIndex = 0;
        }

        const breadcrumbs = ['@', ...this.currentPath.map(p => p.name)].join(' > ');
        
        this.element.innerHTML = `
            <div class="menu-header">${breadcrumbs}</div>
            <ul>
                ${this.visibleItems.map((item, index) => this.renderItem(item, index)).join('')}
            </ul>
        `;
        this.scrollIntoView();
    }

    private renderSearchResults() {
        const allLeaves = this.flattenCommands(this.commands);
        const searchTerms = this.filterText.split(' ').filter(Boolean);

        this.visibleItems = allLeaves.filter(leaf => 
            searchTerms.every(term => 
                leaf.name.toLowerCase().includes(term) ||
                leaf.agentId.toLowerCase().includes(term) ||
                (this.findPath(leaf.id)?.map(p => p.name.toLowerCase()).join(' ') || '').includes(term)
            )
        );

        if (this.activeIndex >= this.visibleItems.length) {
            this.activeIndex = 0;
        }
        
        if (this.visibleItems.length === 0) {
            this.element.innerHTML = `<div class="menu-header">No results for "${this.filterText}"</div>`;
            return;
        }

        this.element.innerHTML = `
            <div class="menu-header">Search results for "${this.filterText}"</div>
            <ul>
                ${this.visibleItems.map((item, index) => this.renderItem(item, index)).join('')}
            </ul>
        `;
        this.scrollIntoView();
    }

    private renderItem(item: CommandNode | CommandLeaf, index: number): string {
        const isActive = index === this.activeIndex ? 'active' : '';
        const hasChildren = !isLeaf(item);

        return `
            <li class="${isActive}" data-index="${index}">
                <div class="menu-item-name" style="display: flex; align-items: center;">
                    <span>${item.name}</span>
                    ${hasChildren ? '<i class="codicon codicon-chevron-right"></i>' : ''}
                </div>
                ${isLeaf(item) ? `<div class="menu-item-description">${item.description}</div>` : ''}
            </li>
        `;
    }

    private scrollIntoView() {
        const activeItem = this.element.querySelector('li.active');
        if (activeItem) {
            activeItem.scrollIntoView({ block: 'nearest' });
        }
    }

    // --- 辅助函数 ---
    private flattenCommands(nodes: (CommandNode | CommandLeaf)[]): CommandLeaf[] {
        let leaves: CommandLeaf[] = [];
        for (const node of nodes) {
            if (isLeaf(node)) {
                leaves.push(node);
            } else {
                leaves = leaves.concat(this.flattenCommands(node.children));
            }
        }
        return leaves;
    }
    
    private findPath(id: string, nodes: (CommandNode | CommandLeaf)[] = this.commands, path: CommandNode[] = []): CommandNode[] | null {
        for (const node of nodes) {
            if (node.id === id) {
                return path;
            }
            if (!isLeaf(node)) {
                const newPath = [...path, node];
                const found = this.findPath(id, node.children, newPath);
                if (found) {
                    return found;
                }
            }
        }
        return null;
    }
}

--------------------------------------------------------------------------------

--- file_path: webview/components/MessageBlock.ts ---
// src/webview/components/MessageBlock.ts
import { ChatMessage } from "../../common/types";

export class MessageBlock {
    constructor(private readonly message: ChatMessage, private readonly messageIndex: number) { }

    public render(): HTMLElement {
        const element = document.createElement('div');
        element.className = `message-block ${this.message.role}`;
        element.dataset.index = this.messageIndex.toString();

        const content = document.createElement('div');
        content.className = 'message-content';

        // FIX: 使用类型守卫来设置内容
        if (this.message.type === 'text') {
            content.textContent = this.message.content;
        } else { // this.message.type === 'agent_run'
            // 为 AgentRun 消息提供一个摘要或占位符
            content.innerHTML = `<strong>Agent Run: ${this.message.run.plan.agentName}</strong><br>Status: ${this.message.run.result.status}`;
            // 这里可以将来扩展为更复杂的渲染组件
        }

        element.appendChild(content);
        element.appendChild(this.createToolbar());

        return element;
    }

    private createToolbar(): HTMLElement {
        const toolbar = document.createElement('div');
        toolbar.className = 'message-toolbar';

        toolbar.appendChild(this.createButton('toggle-fold', 'Fold', 'codicon-chevron-up'));

        // Agent 运行消息也视为 assistant 角色
        if (this.message.role === 'assistant') {
            toolbar.appendChild(this.createButton('copy-content', 'Copy', 'codicon-copy'));
            // 仅为文本消息提供“重新生成”
            if (this.message.type === 'text') {
                toolbar.appendChild(this.createButton('regenerate-response', 'Regenerate', 'codicon-sync'));
            }
        } else { // user 角色
            toolbar.appendChild(this.createButton('copy-content', 'Copy', 'codicon-copy'));
            toolbar.appendChild(this.createButton('edit-message', 'Edit', 'codicon-pencil'));
        }

        return toolbar;
    }

    private createButton(action: string, title: string, icon: string): HTMLButtonElement {
        const button = document.createElement('button');
        button.className = `icon-button`;
        button.title = title;
        button.dataset.action = action;
        button.innerHTML = `<i class="codicon ${icon}"></i>`;
        return button;
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/css/main.css ---
/* --- file_path: webview/css/main.css --- */
body,
html {
    height: 100%;
    margin: 0;
    padding: 0;
    background-color: var(--vscode-sideBar-background);
    color: var(--vscode-editor-foreground);
    font-family: var(--vscode-font-family);
    display: flex;
    flex-direction: column;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
}

#root {
    display: flex;
    flex-direction: column;
    height: 100%;
    flex: 1;
}

.top-toolbar {
    display: flex;
    justify-content: flex-start;
    padding: 5px;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    flex-shrink: 0;
}

.nav-icon {
    cursor: pointer;
    padding: 5px;
    margin: 0 5px;
    border-radius: 5px;
}

.nav-icon:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.nav-icon.active {
    background-color: var(--vscode-list-activeSelectionBackground);
}

.main-content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    padding: 0;
}

.view {
    display: none;
    height: 100%;
    width: 100%;
    flex-direction: column;
}

.view.active {
    display: flex;
}


/* Chat View & Focus Editor Common Styles */
.chat-container,
.focus-editor-container {
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    flex: 1;
    position: relative;
}

.messages-list {
    flex-grow: 1;
    overflow-y: auto;
    min-height: 0;
    width: 100%;
    box-sizing: border-box;
}

.chat-sticky-bottom {
    flex-shrink: 0;
    width: 100%;
    box-sizing: border-box;
    padding: 10px;
    border-top: 1px solid var(--vscode-editorGroup-border);
    background-color: var(--vscode-sideBar-background);
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.chat-quick-actions {
    display: flex;
    gap: 10px;
    align-items: center;
}

.chat-quick-actions label {
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
}

#model-selector,
#prompt-selector {
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 5px;
    border-radius: 5px;
    flex-grow: 1;
}

.chat-quick-actions button {
    margin-left: auto;
    margin-top: 0;
}

.chat-input-box-container {
    display: flex;
}

.chat-input-box-container textarea {
    flex-grow: 1;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 8px;
    resize: none;
    border-radius: 5px;
}

.chat-container .chat-input-box-container textarea {
    max-height: 250px;
}

.focus-editor-container {
    padding: 10px;
}

.focus-editor-container .chat-input-box-container {
    flex-grow: 1;
}

.focus-editor-container .chat-input-box-container textarea {
    height: 100%;
    width: 100%;
    max-height: none;
    box-sizing: border-box;
}


/* Message Block Styles */
.message-block {
    padding: 15px;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    word-wrap: break-word;
    white-space: pre-wrap;
    position: relative;
}

.message-content {
    transition: max-height 0.3s ease-in-out;
    overflow: hidden;
    position: relative;
}

.message-block.folded .message-content {
    max-height: 70px;
}

.message-block.folded .message-content::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 30px;
    background: linear-gradient(to bottom, transparent, var(--vscode-editor-background));
    pointer-events: none;
}

.message-block:last-child {
    border-bottom: none;
}

.message-toolbar {
    position: absolute;
    top: 5px;
    right: 5px;
    background-color: var(--vscode-editorWidget-background);
    border-radius: 5px;
    padding: 2px;
    display: flex;
    gap: 2px;
    opacity: 0;
    transition: opacity 0.1s ease-in-out;
    pointer-events: none;
}

.message-block:hover .message-toolbar {
    opacity: 1;
    pointer-events: all;
}

.message-block.user {
    background-color: var(--vscode-list-hoverBackground);
    border-left: 3px solid var(--vscode-focusBorder);
    padding-left: 12px;
}

.message-block.folded.user .message-content::after {
    background: linear-gradient(to bottom, transparent, var(--vscode-list-hoverBackground));
}

.message-block.assistant {
    background-color: var(--vscode-editor-background);
}

.message-block.editing {
    border: 1px solid var(--vscode-focusBorder);
    box-shadow: 0 0 3px var(--vscode-focusBorder);
    border-radius: 5px;
}

.message-block.error {
    color: var(--vscode-errorForeground);
}

button.streaming {
    background-color: var(--vscode-button-secondaryBackground);
}

button.streaming:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

button.streaming:hover, .chat-sticky-bottom button[data-action="send-or-save"].streaming:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

/* 更新流式/停止按钮样式 */
button.streaming, .chat-sticky-bottom button[data-action="send-or-save"].streaming {
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

/* Settings View */
.config-form {
    border: 1px solid var(--vscode-editorGroup-border);
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 5px;
    background-color: var(--vscode-sideBar-sectionHeader-background);
}

.form-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.form-title {
    font-size: 1.1em;
}

.default-badge {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 0.8em;
}

.form-group {
    margin-bottom: 10px;
}

.form-group label {
    display: block;
    margin-bottom: 5px;
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
}

.form-group-description {
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
    margin-top: 5px;
    margin-bottom: 10px;
}

.config-form input {
    width: calc(100% - 20px);
    margin-bottom: 5px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 5px;
}

.form-actions {
    margin-top: 15px;
    display: flex;
    gap: 10px;
}

.form-actions button {
    margin-top: 0;
}

button {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: none;
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 5px;
}

button:hover {
    background-color: var(--vscode-button-hoverBackground);
}

/* Generic View Header */
.view-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.view-header h2 {
    margin: 0;
}

.add-btn {
    font-size: 20px;
    font-weight: bold;
    padding: 0px 8px;
}

/* Chat History View */
.history-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.history-item {
    display: flex;
    align-items: center;
    padding: 15px;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    cursor: pointer;
    position: relative;
}

.history-item:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.history-item-content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}

.history-item-timestamp {
    font-size: 0.8em;
    color: var(--vscode-descriptionForeground);
    margin-bottom: 5px;
}

.history-item-title {
    font-size: 1em;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.history-item-actions {
    display: flex;
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    background-color: var(--vscode-list-hoverBackground);
    opacity: 0;
    transition: opacity 0.1s ease-in-out;
    pointer-events: none;
}

.history-item:hover .history-item-actions {
    opacity: 1;
    pointer-events: all;
}

.icon-button {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--vscode-foreground);
    padding: 5px;
    border-radius: 5px;
}

.icon-button:hover {
    background-color: var(--vscode-toolbar-hoverBackground);
}

.history-empty {
    text-align: center;
    padding: 20px;
    color: var(--vscode-descriptionForeground);
}

/*=================================*/
/*========= Prompt Manager ========*/
/*=================================*/

.prompt-manager-view,
.prompt-editor-view {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.prompt-editor-view {
    display: none;
}

.search-bar {
    display: flex;
    align-items: center;
    flex-grow: 1;
    margin-right: 15px;
    background-color: var(--vscode-input-background);
    border: 1px solid var(--vscode-input-border);
    border-radius: 5px;
    padding: 0 8px;
}

.search-bar i {
    margin-right: 8px;
    color: var(--vscode-descriptionForeground);
}

.search-bar input {
    width: 100%;
    border: none;
    background: transparent;
    color: var(--vscode-input-foreground);
    padding: 6px 0;
    outline: none;
}

.codicon-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: none;
    padding: 6px 12px;
    cursor: pointer;
    border-radius: 5px;
}

.codicon-btn:hover {
    background-color: var(--vscode-button-hoverBackground);
}

.codicon-btn.secondary {
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
}

.codicon-btn.secondary:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.icon-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--vscode-foreground);
    padding: 5px;
    border-radius: 5px;
}

.icon-btn:hover {
    background-color: var(--vscode-toolbar-hoverBackground);
}


.prompt-list-container {
    flex-grow: 1;
    overflow-y: auto;
}

.prompt-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.prompt-list-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    cursor: pointer;
    transition: background-color 0.1s ease-in-out;
}

.prompt-list-item:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.prompt-item-main {
    flex-grow: 1;
    margin-right: 15px;
    overflow: hidden;
}

.prompt-item-title {
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: 4px;
}

.prompt-item-summary {
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.prompt-item-meta {
    flex-shrink: 0;
    text-align: right;
}

.prompt-item-time {
    font-size: 0.8em;
    color: var(--vscode-descriptionForeground);
    margin-bottom: 8px;
}

.prompt-item-actions {
    display: flex;
    gap: 5px;
    opacity: 0;
    transition: opacity 0.1s ease-in-out;
}

.prompt-list-item:hover .prompt-item-actions {
    opacity: 1;
}

.empty-state {
    text-align: center;
    padding: 40px 20px;
    color: var(--vscode-descriptionForeground);
}

.empty-state p {
    margin-bottom: 15px;
}

.highlighted-btn {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: 1px solid var(--vscode-button-border, transparent);
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
}

.highlighted-btn:hover {
    background-color: var(--vscode-button-hoverBackground);
}

/*=================================*/
/*========= Prompt Editor =========*/
/*=================================*/

.prompt-editor-form {
    flex-grow: 1;
    overflow-y: auto;
    padding: 10px;
    display: flex;
    flex-direction: column;
}

.prompt-editor-form .form-group {
    display: flex;
    flex-direction: column;
}

.prompt-editor-form .form-group:last-child {
    flex-grow: 1;
}

.prompt-editor-form input,
.prompt-editor-form textarea {
    width: calc(100% - 22px);
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 10px;
    border-radius: 5px;
}

.prompt-editor-form textarea {
    flex-grow: 1;
    resize: none;
    font-family: var(--vscode-editor-font-family);
}

.prompt-editor-form textarea:focus {
    outline: none;
}

/*=================================*/
/*====== Rich Input & Pills =======*/
/*=================================*/

.chat-input-box {
    flex-grow: 1;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 8px;
    border-radius: 5px;
    min-height: 22px;
    max-height: 250px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
    line-height: 1.5;
}

.chat-input-box:focus {
    outline: 1px solid var(--vscode-focusBorder);
}

.content-pill {
    display: inline-block;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border-radius: 12px;
    padding: 2px 10px;
    margin: 0 2px;
    font-size: 0.9em;
    font-weight: 500;
    cursor: default;
}

.chat-input-box p, .chat-input-box div {
    margin: 0;
}

/*=================================*/
/*====== @ Command Menu ===========*/
/*=================================*/
.at-command-menu {
    width: 100%;
    box-sizing: border-box;
    background-color: var(--vscode-editorWidget-background);
    border: 1px solid var(--vscode-editorWidget-border);
    border-radius: 5px;
    z-index: 100;
    max-height: 220px;
    overflow-y: auto;
    margin-bottom: 8px;
    display: none;
}

.at-command-menu ul {
    list-style: none;
    padding: 5px;
    margin: 0;
}

.at-command-menu li {
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 3px;
}

.at-command-menu li:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.at-command-menu li.active {
    background-color: var(--vscode-list-hoverBackground);
    color: var(--vscode-list-activeSelectionForeground);
}

.at-command-menu .menu-header {
    padding: 8px 12px;
    border-bottom: 1px solid var(--vscode-editorWidget-border);
    color: var(--vscode-descriptionForeground);
    font-size: 0.9em;
}

.at-command-menu .menu-item-name {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
}

.at-command-menu .menu-item-name .codicon {
    color: var(--vscode-descriptionForeground);
}

.at-command-menu .menu-item-description {
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
    margin-top: 4px;
}

/*=================================*/
/*====== Agent Run Block (Final & Cleaned) =======*/
/*=================================*/

.agent-run-block {
    background-color: var(--vscode-sideBar-sectionHeader-background);
    border: 1px solid var(--vscode-editorGroup-border);
    border-radius: 8px;
    margin: 10px 0;
    padding: 15px;
    font-size: 0.9em;
}

.agent-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    padding-bottom: 10px;
    margin-bottom: 15px;
}

.agent-header h4 {
    margin: 0;
    font-size: 1.2em;
}

.badge {
    padding: 3px 8px;
    border-radius: 12px;
    font-weight: 500;
}
.badge.planning { background-color: var(--vscode-testing-iconQueued-foreground); color: var(--vscode-button-foreground); }
.badge.executing { background-color: var(--vscode-testing-iconRunning-foreground); color: var(--vscode-button-foreground); }
.badge.completed { background-color: var(--vscode-testing-iconPassed-foreground); color: var(--vscode-button-foreground); }
.badge.failed { background-color: var(--vscode-testing-iconFailed-foreground); color: var(--vscode-button-foreground); }
.badge.cancelled { background-color: var(--vscode-testing-iconSkipped-foreground); color: var(--vscode-button-foreground); }

.agent-plan-steps, .agent-parameters {
    margin-bottom: 20px;
}

.agent-plan-steps h5, .agent-parameters h5 {
    margin: 0 0 10px 0;
    color: var(--vscode-descriptionForeground);
}

.step-card {
    background-color: var(--vscode-input-background);
    border: 1px solid var(--vscode-input-border);
    border-radius: 5px;
    padding: 10px;
    margin-bottom: 8px;
}

.step-card-name {
    font-weight: bold;
    margin-bottom: 4px;
}

.step-card-desc {
    font-size: 0.95em;
    color: var(--vscode-descriptionForeground);
}

.parameter-item {
    margin-bottom: 10px;
}

.parameter-item label {
    display: block;
    margin-bottom: 5px;
}

.parameter-description {
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
    margin-bottom: 8px; 
    font-style: italic; 
}

.parameter-item input {
    width: calc(100% - 16px);
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 8px;
    border-radius: 5px;
}

.parameter-item .error-text {
    color: var(--vscode-errorForeground);
    font-size: 0.9em;
    margin-top: 5px;
}

.parameter-item input.invalid {
    border-color: var(--vscode-errorForeground);
}

.agent-actions {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 15px;
}

.agent-actions button {
    flex: 1;
    padding: 10px;
    font-size: 1.1em;
    font-weight: 500;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}
.execute-btn:hover {
    background-color: var(--vscode-button-hoverBackground);
}

.agent-actions .stop-btn {
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
}
.agent-actions .stop-btn:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.agent-actions button.secondary {
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
}
.agent-actions button.secondary:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.execute-btn {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: none;
    padding: 8px 15px;
    cursor: pointer;
    border-radius: 5px;
}
.execute-btn:hover {
    background-color: var(--vscode-button-hoverBackground);
}


/* -- Executing View -- */
.execution-step {
    border-left: 3px solid;
    margin-bottom: 10px;
    transition: all 0.2s ease-in-out;
    border-radius: 0 5px 5px 0;
    overflow: hidden;
}
.execution-step.waiting { border-color: var(--vscode-editorHint-foreground); }
.execution-step.completed { border-color: var(--vscode-testing-iconPassed-foreground); }
.execution-step.failed { border-color: var(--vscode-testing-iconFailed-foreground); }

@keyframes pulse-border {
    0% { border-color: var(--vscode-testing-iconRunning-foreground); }
    50% { border-color: var(--vscode-focusBorder); }
    100% { border-color: var(--vscode-testing-iconRunning-foreground); }
}

.execution-step.running {
    animation: pulse-border 2s infinite;
}

.execution-step .step-header {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    cursor: pointer;
    background-color: var(--vscode-sideBar-sectionHeader-background);
    transition: background-color 0.2s ease;
}
.execution-step .step-header:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.execution-step .status-icon {
    font-size: 1.1em;
}

.execution-step .step-name {
    flex-grow: 1;
}

.execution-step .step-status {
    font-family: monospace;
    font-size: 0.9em;
    padding: 2px 6px;
    border-radius: 3px;
    background-color: var(--vscode-badge-background);
    color: var(--vscode-badge-foreground);
}

.execution-step .step-content {
    overflow: hidden;
    transition: max-height 0.4s ease-in-out, padding 0.4s ease-in-out;
    padding: 0 15px;
    background-color: var(--vscode-input-background);
}
.execution-step .step-content[style*="max-height: 2000px"],
.execution-step .step-content[style*="max-height: 5000px"] {
    padding: 10px 15px;
}


.log-item {
    border: 1px solid var(--vscode-input-border);
    border-left-width: 4px;
    border-radius: 5px;
    margin: 10px 0;
    background: var(--vscode-editor-background);
}
.log-item.log-input { border-left-color: var(--vscode-terminal-ansiBlue); }
.log-item.log-output { border-left-color: var(--vscode-terminal-ansiGreen); }
.log-item.log-llm-request { border-left-color: var(--vscode-terminal-ansiYellow); }
.log-item.log-llm-stream { border-left-color: var(--vscode-terminal-ansiCyan); }

.log-item .log-header {
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(128, 128, 128, 0.1);
    padding: 5px 10px;
    font-weight: bold;
    color: var(--vscode-descriptionForeground);
    border-bottom: 1px solid var(--vscode-input-border);
    cursor: pointer; /* 添加手型光标，提示用户这里可以点击 */
}
.log-item .log-header .codicon {
    font-size: 1.1em;
}

.log-content-wrapper {
    padding: 5px 10px;
    max-height: 400px; /* 设置一个合理的默认最大高度 */
    overflow-y: auto;  /* 当内容超出时，显示内部滚动条 */
    transition: max-height 0.3s ease-out, padding 0.3s ease-out; /* 添加平滑过渡动画 */
    background-color: var(--vscode-editor-background); /* 确保滚动条背景色正确 */
}

.log-item.collapsed .log-content-wrapper {
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
    overflow: hidden; /* 在折叠时隐藏内容，防止文字溢出 */
    border-bottom: none; /* 折叠时不需要底边框 */
}

.log-content-wrapper pre {
    margin: 0;
    padding: 5px;
    white-space: pre-wrap;
    word-break: break-all;
}
.log-content-wrapper code {
    font-family: var(--vscode-editor-font-family);
}

.log-llm-stream .markdown-body {
    padding: 0 10px 10px 10px;
}
.log-llm-stream .markdown-body p:first-child,
.log-llm-stream .markdown-body ul:first-child,
.log-llm-stream .markdown-body ol:first-child {
    margin-top: 10px;
}
.log-llm-stream .markdown-body p,
.log-llm-stream .markdown-body ul,
.log-llm-stream .markdown-body ol {
    margin-top: 0;
    margin-bottom: 0.5em;
}

.step-error {
    background-color: rgba(255, 0, 0, 0.1);
    border: 1px solid var(--vscode-errorForeground);
    color: var(--vscode-errorForeground);
    padding: 10px;
    border-radius: 5px;
    margin: 10px 0;
    white-space: pre-wrap;
}

.agent-final-result {
    margin-top: 20px;
    border: 1px solid var(--vscode-editorGroup-border);
    border-left-width: 4px;
    border-radius: 5px;
    overflow: hidden;
}
.agent-final-result.completed {
    border-left-color: var(--vscode-testing-iconPassed-foreground);
    background-color: rgba(45, 212, 129, 0.1);
}
.agent-final-result.failed,
.agent-final-result.cancelled {
    border-left-color: var(--vscode-testing-iconFailed-foreground);
    background-color: rgba(255, 0, 0, 0.1);
}

.result-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    font-weight: bold;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
}

.result-header .codicon {
    font-size: 1.2em;
}

.result-content {
    padding: 12px;
}
.result-content .error-text {
    color: var(--vscode-errorForeground);
    white-space: pre-wrap;
}

/* --- File & Prompt Card Styles --- */
.prompt-files-container {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
}

.file-card {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background-color: var(--vscode-input-background);
    border: 1px solid var(--vscode-input-border);
    padding: 6px 12px;
    border-radius: 5px;
    font-size: 0.9em;
    cursor: pointer;
    transition: background-color 0.2s ease, border-color 0.2s ease;
    flex-grow: 0;
}
.file-card:hover {
    background-color: var(--vscode-list-hoverBackground);
    border-color: var(--vscode-focusBorder);
}
.file-card .codicon {
    font-size: 1.2em;
    color: var(--vscode-descriptionForeground);
}
.result-content .file-card {
    background: none;
    border: none;
    padding: 0;
    font-size: 1em;
}
.result-content .file-card:hover {
    background: var(--vscode-list-hoverBackground);
}


/* --- Sub-step Styles --- */
.sub-steps-container {
    padding: 10px 5px;
    margin: 10px 0;
    border-radius: 5px;
    background-color: var(--vscode-sideBar-background);
}

.sub-step-placeholder {
    color: var(--vscode-descriptionForeground);
    font-style: italic;
    text-align: center;
    padding: 15px;
}

.sub-step {
    padding: 0;
    border-left: 3px solid;
    margin-bottom: 8px;
    background-color: var(--vscode-editor-background);
    border-radius: 0 3px 3px 0;
    overflow: hidden;
}
.sub-step:last-child {
    margin-bottom: 0;
}

.sub-step.waiting { border-color: var(--vscode-editorHint-foreground); }
.sub-step.running { border-color: var(--vscode-testing-iconRunning-foreground); }
.sub-step.completed { border-color: var(--vscode-testing-iconPassed-foreground); }
.sub-step.failed { border-color: var(--vscode-testing-iconFailed-foreground); }

.sub-step-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 10px;
    cursor: pointer;
    transition: background-color 0.2s ease;
}
.sub-step-header:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.sub-step-content {
    padding: 0 10px 10px 10px;
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}
.sub-step-content .log-item {
    margin: 0;
}

.planning-view.read-only .parameter-item input {
    background-color: var(--vscode-input-background);
    opacity: 0.7;
    cursor: not-allowed;
    border-style: dashed;
}

.planning-view.read-only .prompt-file-card {
    cursor: default;
}
.planning-view.read-only .prompt-file-card:hover {
    background-color: var(--vscode-button-secondaryBackground);
}

@keyframes pulse-waiting {
  0% { opacity: 1; }
  50% { opacity: 0.4; }
  100% { opacity: 1; }
}
.execution-step.waiting .status-icon .codicon-more,
.sub-step.waiting .status-icon .codicon-more {
  animation: pulse-waiting 2s infinite ease-in-out;
}

.llm-waiting-placeholder {
    border-style: dashed !important; /* 覆盖默认边框样式 */
}
.llm-waiting-placeholder .log-header {
    background: transparent !important;
    border-bottom: none !important;
    color: var(--vscode-descriptionForeground) !important;
    font-style: italic;
}
.llm-waiting-placeholder .log-header .codicon-loading {
    color: var(--vscode-testing-iconRunning-foreground);
}

/* Loading dots animation */
@keyframes-loading-dots {
  0%   { content: '.'; }
  33%  { content: '..'; }
  66%  { content: '...'; }
  100% { content: '.'; }
}

.loading-dots::after {
  content: '.';
  animation: keyframes-loading-dots 1.5s infinite;
  display: inline-block;
  width: 20px; /* Give it some space */
  text-align: left;
}

/* 新增淡入动画 */
@keyframes-fade-in {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.fade-in {
  animation: keyframes-fade-in 0.4s ease-out;
}

/* 为步骤状态变化添加平滑过渡 */
.execution-step, .sub-step {
    transition: border-color 0.4s ease-in-out, background-color 0.4s ease-in-out;
}

.executing-view-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 0;
    margin-top: 15px;
    border-top: 1px solid var(--vscode-editorGroup-border);
}
.executing-view-header h4 {
    margin: 0;
}

@keyframes card-fade-in {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* 将动画应用到主步骤卡片上 */
.execution-step {
    border-left: 3px solid;
    margin-bottom: 10px;
    transition: all 0.2s ease-in-out;
    border-radius: 0 5px 5px 0;
    animation: card-fade-in 0.4s ease-out forwards;
}

/* 将动画也应用到最终结果卡片上 */
.agent-final-result {
    margin-top: 20px;
    border: 1px solid var(--vscode-editorGroup-border);
    border-left-width: 4px;
    border-radius: 5px;
    animation: card-fade-in 0.4s ease-out forwards;
}

.execution-step.needs-animation,
.sub-step.needs-animation, /* Added for sub-steps */
.agent-final-result.needs-animation {
    animation: card-fade-in 0.4s ease-out forwards;
}

@keyframes codicon-spin-animation { /* 使用一个不冲突的动画名 */
    100% {
        transform: rotate(360deg);
    }
}

.codicon-spin:before { /* 直接针对 :before 伪元素应用动画 */
    animation: codicon-spin-animation 0.6s linear infinite; /* 时长可以调整 */
    display: inline-block; /* 有时需要确保伪元素是块级或行内块级才能应用 transform */
}

.result-content {
    padding: 12px;
    background-color: var(--vscode-editor-background);
}
.result-content .error-text {
    color: var(--vscode-errorForeground);
    white-space: pre-wrap;
}

/* highlight-start */
.result-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 10px;
    padding: 5px;
}

.stat-item {
    display: flex;
    align-items: center;
    gap: 8px;
    background-color: var(--vscode-sideBar-sectionHeader-background);
    padding: 8px 12px;
    border-radius: 5px;
    border-left: 2px solid var(--vscode-focusBorder);
}

.stat-item .codicon {
    font-size: 1.2em;
    color: var(--vscode-descriptionForeground);
}

.stat-item span {
    flex-grow: 1;
    color: var(--vscode-descriptionForeground);
    font-size: 0.9em;
}

.stat-item strong {
    font-size: 1em;
    font-weight: 600;
    color: var(--vscode-editor-foreground);
}

/*====== Chat View Empty State ======*/
.chat-empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    padding: 20px;
    box-sizing: border-box;
    text-align: center;
    color: var(--vscode-descriptionForeground);
}

.chat-empty-state .empty-state-icon {
    font-size: 48px;
    margin-bottom: 16px;
    color: var(--vscode-editor-foreground);
}

.chat-empty-state .empty-state-icon .codicon {
    font-size: 96px; /* 这直接应用到了 <i> 元素上 */
}

.chat-empty-state h2 {
    margin: 0 0 8px 0;
    font-size: 1.5em;
    font-weight: 600;
    color: var(--vscode-editor-foreground);
}

.chat-empty-state p {
    margin: 0 0 24px 0;
    font-size: 1.1em;
}

.example-prompts {
    width: 100%;
    max-width: 500px;
}

.example-prompts .example-prompt-title {
    margin-bottom: 12px;
    font-weight: bold;
}

.example-prompts .example-prompt {
    background-color: var(--vscode-sideBar-sectionHeader-background);
    border: 1px solid var(--vscode-editorGroup-border);
    padding: 12px;
    border-radius: 5px;
    margin-bottom: 8px;
    font-family: var(--vscode-editor-font-family);
    font-size: 0.95em;
    text-align: left;
}

.example-prompts .example-prompt code {
    background-color: var(--vscode-textCodeBlock-background);
    padding: 2px 4px;
    border-radius: 3px;
}

/* 1. 隐藏顶部工具栏中的 "Prompts" 导航图标 */
#nav-prompts {
    display: none;
}

/* 2. 隐藏聊天视图中 "Prompt:" 的标签和下拉选择器 */
.chat-quick-actions label[for="prompt-selector"],
#prompt-selector {
    display: none;
}

/* 3. (可选但推荐) 隐藏 Focus Editor 视图中的 "Prompt:" 标签和下拉选择器 */
.focus-editor-container .chat-quick-actions label[for="prompt-selector"],
.focus-editor-container #prompt-selector {
    display: none;
}

--------------------------------------------------------------------------------

--- file_path: webview/main.ts ---
import { App } from './views/App';

// Wait for the DOM to be fully loaded before initializing the app
window.addEventListener('load', () => {
    const app = new App(document.body);
    app.initialize();
});


--------------------------------------------------------------------------------

--- file_path: webview/views/App.ts ---
import { vscode } from '../vscode';
import { ChatView } from './ChatView';
import { SettingsView } from './SettingsView';
import { WelcomeView } from './WelcomeView';
import { ChatHistoryView } from './ChatHistoryView';
import { FocusEditorView } from './FocusEditorView';
import { PerformanceSettingsView } from './PerformanceSettingsView';

export class App {
    private chatView: ChatView;
    private focusEditorView?: FocusEditorView;
    private settingsView: SettingsView;
    private welcomeView: WelcomeView;
    private chatHistoryView: ChatHistoryView;
    private performanceSettingsView: PerformanceSettingsView;


    constructor(private readonly parent: HTMLElement) {
        this.parent.innerHTML = this.render();

        this.welcomeView = new WelcomeView(this.parent.querySelector('#view-welcome') as HTMLElement);
        this.chatView = new ChatView(this.parent.querySelector('#view-chat') as HTMLElement);
        this.chatHistoryView = new ChatHistoryView(
            this.parent.querySelector('#view-history') as HTMLElement,
            this.navigateTo.bind(this)
        );
        this.settingsView = new SettingsView(this.parent.querySelector('#view-settings') as HTMLElement);
        this.performanceSettingsView = new PerformanceSettingsView(this.parent.querySelector('#view-performance-settings') as HTMLElement);
    }

    public initialize() {
        this.setupEventListeners();
        // On initial load, determine if this is a focus editor or main view
        if (document.body.classList.contains('focus-editor-body')) {
            vscode.postMessage({ command: 'ready' });
        } else {
            this.navigateTo('chat');
            vscode.postMessage({ command: 'ready' });
        }
    }

    private setupEventListeners() {
        // Top toolbar navigation
        this.parent.querySelector('#nav-new-chat')?.addEventListener('click', () => this.chatView.clearChat());
        this.parent.querySelector('#nav-chat')?.addEventListener('click', () => this.navigateTo('chat'));
        this.parent.querySelector('#nav-history')?.addEventListener('click', () => this.navigateTo('history'));
        this.parent.querySelector('#nav-prompts')?.addEventListener('click', () => this.navigateTo('prompts'));
        this.parent.querySelector('#nav-settings')?.addEventListener('click', () => this.navigateTo('settings'));
        this.parent.querySelector('#nav-performance-settings')?.addEventListener('click', () => this.navigateTo('performance-settings'));

        // Listen for messages from the extension host
        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.command) {
                case 'initialize':
                    this.chatView.setConversations(message.payload.conversations);
                    this.chatHistoryView.setConversations(message.payload.conversations);
                    // this.promptManagerView.update(message.payload.prompts);
                    // this.chatView.setPrompts(message.payload.prompts);
                    this.chatView.setModelConfigs(message.payload.modelConfigs);
                    this.settingsView.setModelConfigs(message.payload.modelConfigs);
                    if (message.payload.performanceConfig) {
                        this.performanceSettingsView.setPerformanceConfig(message.payload.performanceConfig);
                    }
                    break;
                case 'setActiveConversation':
                    this.chatView.loadConversation(message.payload);
                    break;
                case 'updateModelConfigs':
                    this.chatView.setModelConfigs(message.payload);
                    this.settingsView.setModelConfigs(message.payload);
                    if (this.focusEditorView) {
                        this.focusEditorView.setModelConfigs(message.payload);
                    }
                    break;
                case 'updateHistory':
                    this.chatHistoryView.setConversations(message.payload);
                    break;
                case 'showFocusEditor':
                    this.navigateTo('focus-editor', message.payload);
                    break;
                case 'updateContent':
                    if (this.focusEditorView) {
                        this.focusEditorView.updateContent(message.payload.content);
                    }
                    const mainTextarea = this.chatView['bottomPanel'].querySelector('textarea');
                    if (mainTextarea && mainTextarea.value !== message.payload.content) {
                        mainTextarea.value = message.payload.content;
                        this.chatView['autoResizeInput'](mainTextarea);
                    }
                    break;
                case 'updateState':
                    if (this.focusEditorView) {
                        this.focusEditorView.updateState(message.payload);
                    }
                    if (message.payload.modelId) {
                        this.chatView['modelSelector'].value = message.payload.modelId;
                    }
                    if (message.payload.promptId) {
                        this.chatView['promptSelector'].value = message.payload.promptId;
                    }
                    break;
                case 'clearInput':
                    const textarea = this.chatView['bottomPanel'].querySelector('textarea');
                    if (textarea) {
                        textarea.value = '';
                        this.chatView['autoResizeInput'](textarea);
                    }
                    if (this.focusEditorView) {
                        this.focusEditorView.clearInput();
                    }
                    break;
                case 'focusEditorClosed':
                    this.navigateTo('chat');
                    const topToolbar = this.parent.querySelector('.top-toolbar') as HTMLElement;
                    if (topToolbar) topToolbar.style.display = 'flex';
                    this.chatView['toggleMaximizeButton'](false);
                    break;
            }
        });
    }

    public navigateTo(view: string, data?: any) {
        this.parent.querySelectorAll('.view').forEach(v => {
            (v as HTMLElement).style.display = 'none';
        });

        let activeNav = view;

        if (view === 'performance-settings') {
            activeNav = 'performance-settings';
        } else if (view === 'settings') {
            activeNav = 'settings';
        }

        if (view === 'chat' && typeof data === 'string') {
            vscode.postMessage({ command: 'loadConversation', payload: { id: data } });
        } else if (view === 'focus-editor') {
            const container = this.parent.querySelector('#view-focus-editor') as HTMLElement;
            if (!this.focusEditorView) {
                this.focusEditorView = new FocusEditorView(container, data);
            }

            // 直接从 data payload 中获取数据并设置
            if (data.modelConfigs) {
                this.focusEditorView.setModelConfigs(data.modelConfigs);
            }
            if (data.prompts) {
                this.focusEditorView.setPrompts(data.prompts);
            }

            // 每次导航时都更新内容和状态
            this.focusEditorView.updateContent(data.content);
            this.focusEditorView.updateState(data);
            container.style.display = 'flex';
            const topToolbar = this.parent.querySelector('.top-toolbar') as HTMLElement;
            if (topToolbar) topToolbar.style.display = 'none';
            return; // Skip nav update for focus editor
        }

        // 找到目标视图并显示它
        const targetView = this.parent.querySelector(`#view-${view}`);
        if (targetView) {
            // --- 确保这里是 'flex' ---
            (targetView as HTMLElement).style.display = 'flex';
        } else {
            // 如果找不到视图，打印一个错误，这有助于调试
            console.error(`NavigateTo: Could not find view with id #view-${view}`);
        }

        // 更新顶部导航栏图标的激活状态
        this.parent.querySelectorAll('.nav-icon').forEach(icon => icon.classList.remove('active'));
        const navIcon = this.parent.querySelector(`#nav-${activeNav}`);
        if (navIcon) {
            navIcon.classList.add('active');
        } else {
            console.error(`NavigateTo: Could not find nav icon with id #nav-${activeNav}`);
        }
    }

    private render(): string {
        // 更新工具栏 HTML
        return `
            <div class="top-toolbar">
                <div id="nav-new-chat" class="nav-icon" title="New Chat"><i class="codicon codicon-add"></i></div>
                <div class="nav-separator"></div>
                <div id="nav-chat" class="nav-icon" title="Chat"><i class="codicon codicon-comment-discussion"></i></div>
                <div id="nav-history" class="nav-icon" title="History"><i class="codicon codicon-history"></i></div>
                <!-- <div id="nav-prompts" class="nav-icon" title="Prompts"><i class="codicon codicon-symbol-keyword"></i></div> -->
                <div id="nav-settings" class="nav-icon" title="Model Settings"><i class="codicon codicon-server-environment"></i></div>
                <div id="nav-performance-settings" class="nav-icon" title="Performance Settings"><i class="codicon codicon-settings-gear"></i></div>
            </div>
            <div class="main-content">
                <div id="view-welcome" class="view"></div>
                <div id="view-chat" class="view"></div>
                <div id="view-history" class="view"></div>
                <!-- <div id="view-prompts" class="view"></div> -->
                <!-- <div id="view-prompt-editor" class="view"></div> -->
                <div id="view-settings" class="view"></div>
                <div id="view-performance-settings" class="view"></div>
                <div id="view-focus-editor" class="view"></div>
            </div>
        `;
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/ChatHistoryView.ts ---
import { Conversation } from "../../common/types";
import { vscode } from "../vscode";

export class ChatHistoryView {
    private conversations: Conversation[] = [];
    private historyContainer: HTMLElement;

    constructor(
        private readonly parent: HTMLElement,
        private readonly navigate: (view: string, conversationId?: string) => void
    ) {
        this.parent.innerHTML = `<div class="history-container"><h2>Chat History</h2><ul class="history-list"></ul></div>`;
        this.historyContainer = this.parent.querySelector('.history-list') as HTMLElement;
    }

    public setConversations(conversations: Conversation[]) {
        // Sort conversations by date, newest first
        this.conversations = conversations.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
        this.render();
    }

    private render() {
        this.historyContainer.innerHTML = '';
        if (this.conversations.length === 0) {
            this.historyContainer.innerHTML = `<li class="history-empty">No chat history found.</li>`;
            return;
        }

        this.conversations.forEach(conv => {
            const li = document.createElement('li');
            li.className = 'history-item';
            li.dataset.id = conv.id;
            li.addEventListener('click', () => {
                this.navigate('chat', conv.id);
            });

            const content = document.createElement('div');
            content.className = 'history-item-content';

            const timestamp = document.createElement('div');
            timestamp.className = 'history-item-timestamp';
            timestamp.textContent = this.formatDate(conv.createdAt);

            const title = document.createElement('div');
            title.className = 'history-item-title';
            title.textContent = conv.title;

            content.appendChild(timestamp);
            content.appendChild(title);

            const actions = document.createElement('div');
            actions.className = 'history-item-actions';
            
            const deleteButton = document.createElement('button');
            deleteButton.className = 'icon-button';
            deleteButton.title = 'Delete';
            deleteButton.innerHTML = `<i class="codicon codicon-trash"></i>`;
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                vscode.postMessage({ command: 'deleteConversation', payload: { id: conv.id } });
            });

            const exportButton = document.createElement('button');
            exportButton.className = 'icon-button';
            exportButton.title = 'Export';
            exportButton.innerHTML = `<i class="codicon codicon-export"></i>`;
            exportButton.addEventListener('click', (e) => {
                e.stopPropagation();
                // Placeholder for export functionality
                vscode.postMessage({ command: 'info', payload: 'Export functionality is not yet implemented.' });
            });

            actions.appendChild(deleteButton);
            actions.appendChild(exportButton);

            li.appendChild(content);
            li.appendChild(actions);

            this.historyContainer.appendChild(li);
        });
    }

    private formatDate(dateString: string): string {
        const date = new Date(dateString);
        const options: Intl.DateTimeFormatOptions = {
            month: 'long',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric',
            hour12: true
        };
        return date.toLocaleString('en-US', options).replace(',', '');
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/ChatView.ts ---
// --- file_path: webview/views/ChatView.ts ---

import { vscode } from "../vscode";
import { MessageBlock } from "../components/MessageBlock";
import { AtCommandMenu } from "../components/AtCommandMenu";
// 在文件顶部添加新的 import
import { AgentRunBlock } from "../components/AgentRunBlock";
import { Conversation, ChatMessage, ModelConfig, Prompt, AgentPlan, StepExecution, StepUpdate, StepResult, StreamChunk, AgentResult, TextChatMessage, AgentRunChatMessage, AgentRunRecord } from "../../common/types";

interface CommandLeaf {
    id: string;
    name: string;
    agentId: string;
    description: string;
}

export class ChatView {
    private activeConversationId: string | null = null;
    private messages: ChatMessage[] = [];
    private modelConfigs: ModelConfig[] = [];
    private prompts: Prompt[] = [];
    private messageContainer: HTMLElement;
    private bottomPanel: HTMLElement;
    private modelSelector: HTMLSelectElement;
    private promptSelector: HTMLSelectElement;
    private isStreaming: boolean = false;
    private editingMessageIndex: number | null = null;
    private originalMessageContent: string | null = null;
    private atCommandMenu: AtCommandMenu;
    private inputBox: HTMLElement; // 从 HTMLTextAreaElement 改为 HTMLElement
    private activeAgentRunContainer: HTMLElement | null = null;
    private activeAgentRunBlock: AgentRunBlock | null = null;
    private isAgentRunning: boolean = false;
    private activeAgentRunId: string | null = null;


    constructor(private readonly parent: HTMLElement) {
        this.parent.innerHTML = this.renderInitialLayout();
        this.messageContainer = this.parent.querySelector('.messages-list') as HTMLElement;
        this.bottomPanel = this.parent.querySelector('.chat-sticky-bottom') as HTMLElement;
        this.modelSelector = this.parent.querySelector('#model-selector') as HTMLSelectElement;
        this.promptSelector = this.parent.querySelector('#prompt-selector') as HTMLSelectElement;

        // 渲染输入框并获取其引用
        this.renderBottomInput(); 
        this.inputBox = this.bottomPanel.querySelector('.chat-input-box') as HTMLElement;
        
        // 将菜单附加到 chat-container, 以便使用相对定位
        const commandMenuContainer = this.parent.querySelector('.at-command-menu-container') as HTMLElement;
        this.atCommandMenu = new AtCommandMenu(commandMenuContainer);

        this.setupEventListeners();
    }

    public setConversations(conversations: Conversation[]) {
        if (conversations.length > 0) {
            // 找到最后一个非空对话
            const lastNonEmptyConversation = [...conversations].reverse().find(c => c.messages.length > 0);
            if (lastNonEmptyConversation) {
                this.messages = lastNonEmptyConversation.messages;
                this.activeConversationId = lastNonEmptyConversation.id;
            } else {
                // 如果所有对话都是空的，则清空当前状态
                this.messages = [];
                this.activeConversationId = null;
            }
        } else {
            this.messages = [];
        }
        this.renderMessages();
    }

    public clearChat() {
        this.messages = [];
        this.renderMessages();
        vscode.postMessage({ command: 'newChat' });
    }

    public loadConversation(conversation: Conversation) {
        this.messages = conversation.messages;
        this.activeConversationId = conversation.id; // 确保加载对话时也设置 activeConversationId
        this.handleCancelEdit(); // Ensure we exit any edit mode when loading a new conversation
        this.renderMessages();
    }

    public setModelConfigs(configs: ModelConfig[]) {
        this.modelConfigs = configs;
        this.renderModelSelector();
    }

    public setPrompts(prompts: Prompt[]) {
        this.prompts = prompts;
        this.renderPromptSelector();
    }

    private setupEventListeners() {
        // Listener for all clicks in the view
        this.parent.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            const button = target.closest('button');

            // 如果点击了输入框外部，且@菜单是可见的，则隐藏它
            if (!this.inputBox.contains(target) && !this.atCommandMenu['element'].contains(target)) {
                this.atCommandMenu.hide();
            }

            if (this.editingMessageIndex !== null) {
                const editingBlock = this.parent.querySelector('.message-block.editing');
                if (editingBlock && !editingBlock.contains(target) && !this.bottomPanel.contains(target)) {
                    this.handleCancelEdit();
                    return;
                }
            }

            if (!button) return;
            const action = button.dataset.action;
            if (!action) return;

            const messageBlock = target.closest('.message-block');
            const messageIndex = messageBlock ? parseInt((messageBlock as HTMLElement).dataset.index || '-1', 10) : -1;

            switch (action) {
                case 'send-or-save': this.handleSendOrSave(); break;
                case 'copy-content': if (messageIndex !== -1) this.handleCopy(messageIndex); break;
                case 'regenerate-response': if (messageIndex !== -1) this.handleRegenerate(messageIndex); break;
                case 'edit-message': if (messageIndex !== -1) this.handleEnterEditMode(messageIndex); break;
                case 'maximize-editor': this.handleMaximizeEditor(); break;
                case 'toggle-fold':
                    if (messageBlock) {
                        const icon = button.querySelector('i');
                        messageBlock.classList.toggle('folded');
                        if (messageBlock.classList.contains('folded')) {
                            button.title = 'Expand';
                            icon?.classList.remove('codicon-chevron-up');
                            icon?.classList.add('codicon-chevron-down');
                        } else {
                            button.title = 'Fold';
                            icon?.classList.remove('codicon-chevron-down');
                            icon?.classList.add('codicon-chevron-up');
                        }
                    }
                    break;

            }
        });

        window.addEventListener('resize', () => {

        });

        this.modelSelector.addEventListener('change', () => {
            vscode.postMessage({
                command: 'syncStateChange',
                payload: { modelId: this.modelSelector.value }
            });
        });

        this.promptSelector.addEventListener('change', () => {
            const selectedPromptId = this.promptSelector.value;
            vscode.postMessage({
                command: 'syncStateChange',
                payload: { promptId: selectedPromptId }
            });

            if (selectedPromptId) {
                const selectedPrompt = this.prompts.find(p => p.id === selectedPromptId);
                if (selectedPrompt) {
                    // 更新为操作 contenteditable div
                    if (this.inputBox) {
                        this.inputBox.innerText = selectedPrompt.content;
                        this.inputBox.focus();
                        vscode.postMessage({
                            command: 'updateWebviewContent',
                            payload: { content: this.inputBox.innerText }
                        });
                    }
                }
            }
        });

        window.addEventListener('message', event => {
            const message = event.data;
            const { command, payload } = message;
            if (command.startsWith('agent:')) {
                if (command === 'agent:planGenerated' && this.activeAgentRunContainer) {
                    const plan: AgentPlan = payload;
                    
                    // 定义执行回调
                    const onExecute = (params: Record<string, any>) => {
                        vscode.postMessage({
                            command: 'agent:execute',
                            payload: { agentId: plan.agentId, parameters: params }
                        });
                    };

                    // 定义取消回调
                    const onCancel = () => {
                        // 清理父组件的状态
                        this.activeAgentRunBlock = null;
                        this.activeAgentRunContainer = null;
                        // 重新渲染，此时会因为状态已清理而显示欢迎界面
                        this.renderMessages();
                    };
                    
                    // 创建 AgentRunBlock 实例，并传入所有回调
                    this.activeAgentRunBlock = new AgentRunBlock(
                        this.activeAgentRunContainer, 
                        plan, 
                        onExecute, 
                        onCancel // 传入新的 onCancel 回调
                    );
                    return;
                }
                
                if (this.activeAgentRunBlock) {
                    switch (command) {
                        case 'agent:stepStart':
                            if (!this.isAgentRunning) { // 第一个步骤事件，标志着运行开始
                                this.isAgentRunning = true;
                                this.activeAgentRunId = payload.runId;
                                this.updateSendButtonState();
                            }
                            this.activeAgentRunBlock.updateStepExecutionStatus(payload as StepExecution);
                            return;
                        case 'agent:stepEnd':
                            this.activeAgentRunBlock.updateStepExecutionStatus(payload as StepResult);
                            return;
                        case 'agent:stepUpdate':
                            this.activeAgentRunBlock.addStepLog(payload);
                            return;
                        case 'agent:streamChunk':
                            this.activeAgentRunBlock.appendStreamChunk(payload);
                            return;
                        case 'agent:end': { // 使用块作用域
                            this.activeAgentRunBlock.setAgentResult(payload as AgentResult);
                            
                            // 对于任何终端状态，都获取其可序列化状态
                            const runRecord = this.activeAgentRunBlock.getSerializableState();

                            if (runRecord) {
                                // --- highlight-start ---
                                // 在保存前截断长字符串
                                const truncatedRecord = this.truncateLongStrings(runRecord);
                                // --- highlight-end ---

                                const agentMessage: AgentRunChatMessage = {
                                    type: 'agent_run',
                                    role: 'assistant',
                                    run: truncatedRecord as AgentRunRecord // 使用截断后的记录
                                };
                                // 将持久化消息添加到历史记录中
                                this.messages.push(agentMessage);
                                this.saveCurrentConversation();
                            }

                            // 清理实时运行状态
                            this.isAgentRunning = false;
                            this.activeAgentRunId = null;
                            this.activeAgentRunBlock = null; 
                            this.activeAgentRunContainer = null;
                            
                            // 从更新后的 messages 数组中重新渲染整个消息列表。
                            // 这将移除旧的“实时”agent block容器，并从保存的消息中
                            // 渲染一个新的、历史性的 AgentRunBlock。
                            this.renderMessages();
                            
                            this.updateSendButtonState();

                            return;
                        }
                    }
                }
            }

            switch (message.command) {
                case 'startStreaming': this.beginStream(); break;
                case 'streamData': this.appendStreamData(message.payload); break;
                case 'streamEnd': this.finalizeStream(); break;
                case 'requestFailed': this.handleRequestFailed(message.payload.error); break;
                case 'setActiveConversation': this.loadConversation(message.payload); break;
                case 'updatePrompts': this.setPrompts(message.payload); break;
                case 'updateContent': {
                    if (this.inputBox && this.inputBox.innerText !== message.payload.content) {
                        this.inputBox.innerText = message.payload.content;
                    }
                    break;
                }
                case 'clearInput': {
                    if (this.inputBox) {
                       this.inputBox.innerHTML = '';
                    }
                    break;
                }
                case 'focusEditorClosed': this.toggleMaximizeButton(false); break;
                case 'updateState':
                    if (message.payload.modelId) {
                        this.modelSelector.value = message.payload.modelId;
                    }
                    if (message.payload.promptId) {
                        this.promptSelector.value = message.payload.promptId;
                    }
                    break;
            }
        });
    }

    // --- highlight-start ---
    /**
     * 递归地遍历一个对象，并将所有长字符串截断。
     * @param obj 要处理的对象
     * @param maxLength 最大字符串长度，默认为 500
     * @returns 处理后的新对象
     */
    private truncateLongStrings(obj: any, maxLength: number = 500): any {
        if (!obj) {
            return obj;
        }

        if (Array.isArray(obj)) {
            return obj.map(item => this.truncateLongStrings(item, maxLength));
        }

        if (typeof obj === 'object') {
            const newObj: { [key: string]: any } = {};
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    newObj[key] = this.truncateLongStrings(obj[key], maxLength);
                }
            }
            return newObj;
        }

        if (typeof obj === 'string' && obj.length > maxLength) {
            return obj.substring(0, maxLength) + '... (truncated)';
        }

        return obj;
    }
    // --- highlight-end ---

    private saveCurrentConversation() {
        if (this.activeConversationId) {
            // 这是向后端发送更新后对话的请求
            // 后端 StateManager.saveConversation 会处理它
            vscode.postMessage({
                command: 'saveConversation',
                payload: {
                    id: this.activeConversationId,
                    messages: this.messages,
                    // 其他字段（如 title, createdAt）将由后端保留
                }
            });
        } else {
             // 如果是新对话，第一个Agent运行也可能触发保存
            console.warn("Attempted to save conversation, but no activeConversationId is set.");
        }
    }

    private handleSendOrSave() {
        if (this.isAgentRunning && this.activeAgentRunId) {
            vscode.postMessage({ command: 'agent:cancel', payload: { runId: this.activeAgentRunId } });
            return;
        }
        if (this.isStreaming) {
            vscode.postMessage({ command: 'stopMessage' });
            return;
        }
        
        if (this.editingMessageIndex !== null) {
            this.handleSaveEdit(this.editingMessageIndex);
        } else {
            this.handleSendMessage();
        }
    }

    private handleSendMessage() {
        if (this.isStreaming) {
            vscode.postMessage({ command: 'stopMessage' });
            return;
        }
        
        const prompt = this.inputBox.innerText.trim();
        if (!prompt) return;

        const selectedModelId = this.modelSelector.value;
        const selectedConfig = this.modelConfigs.find(c => c.id === selectedModelId);

        if (!selectedConfig) {
            vscode.postMessage({ command: 'error', payload: 'Please select a valid model from settings.' });
            return;
        }

        const message: TextChatMessage = { type: 'text', role: 'user', content: prompt };
        this.messages.push(message);
        this.renderMessages();

        this.inputBox.innerHTML = '';
        vscode.postMessage({ command: 'sendMessage', payload: { prompt, config: selectedConfig } });
    }

    private handleCopy(index: number) {
        const message = this.messages[index];
        
        if (message.type === 'text') {
            navigator.clipboard.writeText(message.content);
            vscode.postMessage({ command: 'info', payload: 'Copied to clipboard!' });
        } else {
            // 对于 Agent 运行，可以复制其最终结果或摘要
            const summary = JSON.stringify(message.run.result, null, 2);
            navigator.clipboard.writeText(summary);
             vscode.postMessage({ command: 'info', payload: 'Copied agent result summary to clipboard!' });
        }
        
    }

    private handleRegenerate(index: number) {
        vscode.postMessage({ command: 'regenerate', payload: { messageIndex: index } });
    }

    private handleEnterEditMode(index: number) {
        if (this.editingMessageIndex === index) return;
        
        const message = this.messages[index];
        if (message.type !== 'text') {
             vscode.postMessage({ command: 'info', payload: 'Agent runs cannot be edited.' });
            return; // 不允许编辑 Agent 运行
        }
        

        if (this.editingMessageIndex !== null) {
            this.handleCancelEdit();
        }

        this.editingMessageIndex = index;
        this.originalMessageContent = message.content;

        if (this.inputBox) {
            this.inputBox.innerText = this.originalMessageContent;
            this.inputBox.focus();
        }

        this.renderMessages();
        this.updateSendButtonState();
    }


    private handleCancelEdit() {
        if (this.editingMessageIndex === null) return;

        const message = this.messages[this.editingMessageIndex];
        if (this.originalMessageContent !== null && message.type === 'text') {
            message.content = this.originalMessageContent;
        }

        this.editingMessageIndex = null;
        this.originalMessageContent = null;

        if (this.inputBox) {
            this.inputBox.innerHTML = '';
        }

        this.renderMessages();
        this.updateSendButtonState();
    }

    private handleSaveEdit(index: number) {
        if (!this.inputBox) return;
        const newContent = this.inputBox.innerText.trim();
        const message = this.messages[index];
        if (newContent && message.type === 'text') {
            message.content = newContent;
            vscode.postMessage({ command: 'editMessage', payload: { messageIndex: index, content: newContent } });
        }

        this.editingMessageIndex = null;
        this.originalMessageContent = null;

        this.inputBox.innerHTML = '';

        this.renderMessages();
        this.updateSendButtonState();
    }

    private beginStream() {
        this.isStreaming = true;
        
        const assistantMessage: TextChatMessage = { type: 'text', role: 'assistant', content: '' };
        
        this.messages.push(assistantMessage);
        this.renderMessages();
        this.updateSendButtonState();
    }

    private appendStreamData(chunk: string) {
        const lastMessage = this.messages[this.messages.length - 1];
        
        if (lastMessage?.type === 'text' && lastMessage?.role === 'assistant') {
            lastMessage.content += chunk;
            this.renderMessages();
        }
        
    }


    private finalizeStream(stopped = false) {
        this.isStreaming = false;
        const lastMessage = this.messages[this.messages.length - 1];
        if (stopped && lastMessage?.type === 'text' && lastMessage?.role === 'assistant') {
            lastMessage.content += ' (Stopped)';
        }
        this.renderMessages();
        this.updateSendButtonState();
    }

    private handleRequestFailed(error: string) {
        this.finalizeStream();
        this.messages.pop();
        const lastUserMessage = this.messages.pop();

        this.renderMessages();

        if (lastUserMessage && lastUserMessage.type === 'text') {
            if (this.inputBox) this.inputBox.innerText = lastUserMessage.content;
        }

        const errorElement = document.createElement('div');
        errorElement.className = 'message-block assistant error';
        errorElement.textContent = `Error: ${error}`;
        this.messageContainer.appendChild(errorElement);
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
    }

    private handleMaximizeEditor() {
        if (this.inputBox) {
            vscode.postMessage({
                command: 'openFocusEditor',
                payload: {
                    content: this.inputBox.innerText,
                    modelId: this.modelSelector.value,
                    promptId: this.promptSelector.value
                }
            });
            this.toggleMaximizeButton(true);
        }
    }

    private toggleMaximizeButton(isMaximized: boolean) {
        const button = this.bottomPanel.querySelector('button[data-action="maximize-editor"]') as HTMLButtonElement;
        if (button) {
            if (isMaximized) {
                button.innerHTML = `<i class="codicon codicon-screen-normal"></i>`;
                button.title = '恢复至侧边栏';
            } else {
                button.innerHTML = `<i class="codicon codicon-screen-full"></i>`;
                button.title = '最大化编辑';
            }
        }
    }

    private renderMessages() {
        this.messageContainer.innerHTML = '';

        // 检查是否应该显示空状态
        if (this.messages.length === 0 && !this.activeAgentRunContainer) {
            this.messageContainer.innerHTML = this.renderEmptyState();
            return; // 显示空状态后直接返回
        }

        this.messages.forEach((msg, index) => {
            
            if (msg.type === 'agent_run') {
                // 渲染一个 AgentRunBlock
                const agentContainer = document.createElement('div');
                this.messageContainer.appendChild(agentContainer);
                // 使用 AgentRunBlock 的构造函数从历史记录中恢复
                new AgentRunBlock(agentContainer, msg.run);
            } else {
                // 渲染一个标准的 MessageBlock
                const element = new MessageBlock(msg, index).render();
                if (this.editingMessageIndex === index) {
                    element.classList.add('editing');
                }
                this.messageContainer.appendChild(element);
            }
            
        });
        
        // 如果当前有正在运行但尚未保存到 messages 数组的 Agent，它的容器也需要被处理
        if (this.activeAgentRunContainer && !this.messageContainer.contains(this.activeAgentRunContainer)) {
             this.messageContainer.appendChild(this.activeAgentRunContainer);
        }

        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
    }

    /**
     * 新增：渲染聊天视图的空状态（欢迎和引导信息）。
     * @returns 返回包含空状态内容的 HTML 字符串。
     */
    private renderEmptyState(): string {
        return `
            <div class="chat-empty-state">
                <div class="empty-state-icon">
                    <i class="codicon codicon-book"></i>
                </div>
                <h1>CodeWiki</h1>
                <h3>您的智能软件设计助手</h3>
                <div class="example-prompts">
                    <div class="example-prompt-title">您可以尝试这样开始：</div>
                    <div class="example-prompt">使用 <code>@DocGen->DocGen-Project</code> 为当前项目生成一份软件实现设计文档</div>
                    <div class="example-prompt">使用 <code>@DocGen->DocGen-Module-Direct</code> 为模块生成详细实现设计文档</div>
                    <div class="example-prompt">使用 <code>@DocGen->DocGen-Module-MapReduce</code> 用摘要总结迭代多轮的方式，为模块生成详细实现设计文档</div>
                </div>
            </div>
        `;
    }

    private renderBottomInput() {
        const container = this.bottomPanel.querySelector('.chat-input-box-container');
        if (!container) return;

        // 关键改动：使用 contenteditable div 替换 textarea
        container.innerHTML = `<div class="chat-input-box" contenteditable="true" placeholder="输入消息，或用'@'触发命令..."></div>`;
        const inputBox = container.querySelector('.chat-input-box') as HTMLElement;

        inputBox.addEventListener('keydown', (e) => {
            if (this.atCommandMenu.isVisible()) {
                this.atCommandMenu.handleKeyDown(e);
                return; // 阻止后续的 Enter 发送等行为
            }

            // 优化 Backspace 处理逻辑，使其更健壮
            if (e.key === 'Backspace') {
                const sel = window.getSelection();
                if (sel && sel.isCollapsed) {
                    const range = sel.getRangeAt(0);
                    // 此条件适用于光标位于输入框容器内，且其前方有节点（例如，在Pill之后）
                    if (range.startContainer === inputBox && range.startOffset > 0) {
                        const nodeToDelete = inputBox.childNodes[range.startOffset - 1];
                        // 检查待删除的节点是否是Pill
                        if (nodeToDelete && nodeToDelete.nodeName === 'SPAN' && (nodeToDelete as HTMLElement).classList.contains('content-pill')) {
                            e.preventDefault();
                            nodeToDelete.remove();
                            return; // 阻止默认的Backspace行为
                        }
                    }
                }
            }

            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.handleSendOrSave();
            }
        });

        inputBox.addEventListener('input', () => {
            this.handleInputForAtCommand(inputBox);
            vscode.postMessage({
                command: 'updateWebviewContent',
                payload: { content: inputBox.innerText }
            });
        });

        // 如果输入框为空，显示 placeholder
        inputBox.addEventListener('focus', () => {
             if (inputBox.getAttribute('placeholder')) {
                inputBox.removeAttribute('placeholder');
             }
        });
        inputBox.addEventListener('blur', () => {
            if (!inputBox.textContent) {
                 inputBox.setAttribute('placeholder', "输入消息，或用'@'触发命令...");
            }
        });

        this.updateSendButtonState();
    }

    /**
     * 处理输入事件，用于触发 @ 命令菜单
     */
    private handleInputForAtCommand(inputBox: HTMLElement) {
        // 1. 如果输入框中已经存在一个Pill，则不应触发@命令菜单。
        if (inputBox.querySelector('.content-pill')) {
            this.atCommandMenu.hide();
            return;
        }

        // 2. 获取整个输入框的纯文本内容。
        const text = inputBox.innerText;

        // 3. 仅当文本以 '@' 字符开头时才显示菜单。
        //    这避免了在文本中间输入'@'时触发菜单。
        if (text.startsWith('@')) {
            // 传递@后面的部分，供菜单内部使用（即使当前过滤已禁用）
            const filter = text.substring(1);
            this.atCommandMenu.show(
                filter,
                (command) => { 
                    this.handleAgentCommandSelected(command); 
                }
            );
        } else {
            this.atCommandMenu.hide();
        }
    }

    /**
     * 新增方法：处理从 @ 菜单中选择 Agent 命令的逻辑
     * @param command 选中的 CommandLeaf 对象
     */
    private handleAgentCommandSelected(command: CommandLeaf) {
        // 1. 清空输入框
        this.inputBox.innerHTML = '';
        this.atCommandMenu.hide();

        // 2. 在消息列表中创建一个新的 div 容器，作为 AgentRunBlock 的占位符
        this.activeAgentRunContainer = document.createElement('div');
        
        // 3. 关键：立即调用 renderMessages() 来更新视图
        //    这将根据新的 activeAgentRunContainer 状态清除欢迎界面
        this.renderMessages();
        
        // 确保视图滚动到底部，以便用户能看到新创建的容器
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;

        // 4. 向后端发送消息，请求这个 Agent 的执行计划
        vscode.postMessage({
            command: 'agent:getPlan',
            payload: {
                agentId: command.agentId
            }
        });
    }

    /**
     * 将选中的 Agent 命令作为 "Pill" 插入到输入框中
     */
    // 更新方法签名以接收完整的 CommandLeaf 对象
    private insertAgentPill(command: { agentId: string, name: string }) {
        // 使用更具描述性的 Pill 内容
        const pillHtml = `<span class="content-pill" contenteditable="false" data-agent-id="${command.agentId}">@${command.name}</span> `;
        
        // 清空输入框并插入 Pill
        this.inputBox.innerHTML = pillHtml;
        this.inputBox.focus();

        // 移动光标到最后
        const selection = window.getSelection();
        if (selection) {
            const range = document.createRange();
            range.selectNodeContents(this.inputBox);
            range.collapse(false); // false 表示折叠到末尾
            selection.removeAllRanges();
            selection.addRange(range);
        }

        this.atCommandMenu.hide();
    }

    private updateSendButtonState() {
        const sendButton = this.bottomPanel.querySelector<HTMLButtonElement>('button[data-action="send-or-save"]');
        if (sendButton) {
            if (this.isAgentRunning || this.isStreaming) {
                sendButton.innerHTML = `<i class="codicon codicon-stop-circle"></i> Stop`;
                sendButton.classList.add('streaming');
                sendButton.title = 'Stop Generation';
            } 
            else if (this.editingMessageIndex !== null) {
                sendButton.textContent = 'Save';
                sendButton.classList.remove('streaming');
                sendButton.title = 'Save Changes';
            } else {
                sendButton.textContent = 'Send';
                sendButton.classList.remove('streaming');
                sendButton.title = 'Send Message';
            }
        }
    }

    private renderInitialLayout(): string {
        return `
            <div class="chat-container">
                <div class="messages-list"></div>
                <div class="chat-sticky-bottom">
                    <div class="at-command-menu-container"></div>
                    <div class="chat-quick-actions">
                        <label for="model-selector">Model:</label>
                        <select id="model-selector"></select>
                        <label for="prompt-selector">Prompt:</label>
                        <select id="prompt-selector"></select>
                        <button data-action="maximize-editor" title="最大化编辑">
                            <i class="codicon codicon-screen-full"></i>
                        </button>
                        <button data-action="send-or-save">Send</button>
                    </div>
                    <div class="chat-input-box-container"></div>
                </div>
            </div>
        `;
    }

    private renderModelSelector() {
        this.modelSelector.innerHTML = '';
        const defaultModel = this.modelConfigs.find(c => c.isDefault);
        this.modelConfigs.forEach(config => {
            const option = document.createElement('option');
            option.value = config.id;
            option.textContent = config.name;
            if (defaultModel && config.id === defaultModel.id) {
                option.selected = true;
            }
            this.modelSelector.appendChild(option);
        });
    }

    private renderPromptSelector() {
        this.promptSelector.innerHTML = '<option value="">Select a prompt...</option>';
        this.prompts.forEach(prompt => {
            const option = document.createElement('option');
            option.value = prompt.id;
            option.textContent = prompt.title;
            this.promptSelector.appendChild(option);
        });
    }

    private autoResizeInput(textarea: HTMLTextAreaElement) {
        textarea.style.height = 'auto';
        const scrollHeight = textarea.scrollHeight;
        const maxHeight = 250; // Synced with main.css

        if (scrollHeight > maxHeight) {
            textarea.style.height = `${maxHeight}px`;
            textarea.style.overflowY = 'auto';
        } else {
            textarea.style.height = `${scrollHeight}px`;
            textarea.style.overflowY = 'hidden';
        }
    }
    
    // --- 新增：模拟后端处理器 ---
    private mockBackendHandler(agentId: string, agentName: string) {
        // 1. 创建 AgentRunBlock 的容器并添加到聊天列表中
        const agentRunContainer = document.createElement('div');
        this.messageContainer.appendChild(agentRunContainer);
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;

        // 2. 定义模拟的 AgentPlan 数据
        const mockPlan: AgentPlan = {
            agentId: 'docgen-project',
            agentName: '项目级文档生成',
            steps: [
                { name: "规划: 分析项目结构", description: "分析文件树，规划需要分析的核心模块。", promptFiles: ['project_planner.yml'] },
                { name: "执行: 并行分析所有模块", description: "为每个已规划的模块生成详细的文档。", promptFiles: ['module_analysis_direct.yml', 'module_analysis_mapreduce.yml']},
                { name: "综合: 生成最终文档", description: "将所有模块分析结果汇编成最终的项目设计文档。", promptFiles: ['project_synthesis.yml'] }
            ],
            parameters: [] // 项目级文档生成不需要参数
        };


        // 3. 定义执行回调，当用户点击“开始执行”时触发
        const onExecute = (params: Record<string, any>) => {
            console.log("Mock backend received execute command with params:", params);
            this.runMockExecution(agentBlock, mockPlan);
        };

        // 4. 创建 AgentRunBlock 实例，传入容器、计划和回调
        const agentBlock = new AgentRunBlock(agentRunContainer, mockPlan, onExecute);
    }
    
    // --- 新增：模拟执行流程 ---
    private runMockExecution(agentBlock: AgentRunBlock, plan: AgentPlan) {
        const runId = `run_${Date.now()}`;
        let eventIndex = 0;
        
        // 模拟从 plan.json 读取到的模块列表
        const plannedModules = [
            { name: "核心业务模块", path: "agile-boot/agile-spring-boot-starter" },
            { name: "前端控制台工具", path: "agile-boot/agile-console" },
            { name: "后台管理服务", path: "agile-boot/agile-serve-admin" },
            { name: "文件上传服务", path: "agile-boot/agile-spring-upload" },
            { name: "RESTful接口服务", path: "agile-boot/agile-serve-restful" },
            { name: "验证码服务", path: "agile-boot/agile-spring-captcha" }
        ];

        // 高保真模拟事件流
        const mockEventStream: (StepExecution | StepUpdate | StreamChunk | AgentResult)[] = [
            // === 阶段 1: 规划 ===
            { runId, taskId: 'task_plan', stepName: "规划: 分析项目结构", status: 'running' } as StepExecution,
            { runId, taskId: 'task_plan', type: 'llm-request', data: { name: '规划请求' }, metadata: { type: 'file', path: '.codewiki/runs/.../01_planning_request.txt' } } as StepUpdate,
            { runId, taskId: 'task_plan', type: 'output', data: { name: '规划响应' }, metadata: { type: 'file', path: '.codewiki/runs/.../01_planning_response.txt' } } as StepUpdate,
            { runId, taskId: 'task_plan', stepName: "规划: 分析项目结构", status: 'completed' } as StepExecution,

            // === 阶段 2: 并行分析 (父任务启动) ===
            { runId, taskId: 'task_parallel_parent', stepName: "执行: 并行分析所有模块", status: 'running' } as StepExecution,
            
            // --- 模拟所有子任务的创建 ---
            { runId, taskId: 'task_mod_1', stepName: "分析模块: '核心业务模块'", status: 'running' } as StepExecution,
            { runId, taskId: 'task_mod_2', stepName: "分析模块: '前端控制台工具'", status: 'running' } as StepExecution,
            { runId, taskId: 'task_mod_3', stepName: "分析模块: '后台管理服务'", status: 'running' } as StepExecution,
            // ... 其他模块也在这里启动

            // --- 模块 1 的完整生命周期 ---
            { runId, taskId: 'task_mod_1', type: 'llm-request', data: { name: '核心业务模块分析请求' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_agile-spring-boot-starter/llm_request.txt' } } as StepUpdate,
            // (此时UI应显示等待动画)
            { runId, taskId: 'task_mod_1', content: '### 核心业务模块\n\n该模块是系统的核心...' } as StreamChunk,
            { runId, taskId: 'task_mod_1', content: '它包含了主要的业务逻辑和实体定义。' } as StreamChunk,
            { runId, taskId: 'task_mod_1', type: 'output', data: { name: '模块文档' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_核心业务模块.md' } } as StepUpdate,
            { runId, taskId: 'task_mod_1', stepName: "分析模块: '核心业务模块'", status: 'completed' } as StepExecution,

            // --- 模块 2 的完整生命周期 ---
            { runId, taskId: 'task_mod_2', type: 'llm-request', data: { name: '前端控制台工具分析请求' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_agile-console/llm_request.txt' } } as StepUpdate,
            // (UI显示等待)
            { runId, taskId: 'task_mod_2', content: '### 前端控制台工具\n\n提供了命令行工具...' } as StreamChunk,
            { runId, taskId: 'task_mod_2', type: 'output', data: { name: '模块文档' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_前端控制台工具.md' } } as StepUpdate,
            { runId, taskId: 'task_mod_2', stepName: "分析模块: '前端控制台工具'", status: 'completed' } as StepExecution,

            // ... (模块3 及以后同理)
            { runId, taskId: 'task_mod_3', type: 'llm-request', data: { name: '后台管理服务分析请求' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_agile-serve-admin/llm_request.txt' } } as StepUpdate,
            { runId, taskId: 'task_mod_3', type: 'output', data: { name: '模块文档' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_后台管理服务.md' } } as StepUpdate,
            { runId, taskId: 'task_mod_3', stepName: "分析模块: '后台管理服务'", status: 'completed' } as StepExecution,


            // === 阶段 2: 并行分析 (父任务完成) ===
            { runId, taskId: 'task_parallel_parent', stepName: "执行: 并行分析所有模块", status: 'completed' } as StepExecution,
            
            // === 阶段 3: 综合 (也遵循完整周期) ===
            { runId, taskId: 'task_synthesis', stepName: "综合: 生成最终文档", status: 'running' } as StepExecution,
            { runId, taskId: 'task_synthesis', type: 'llm-request', data: { name: '综合请求' }, metadata: { type: 'file', path: '.codewiki/runs/.../03_synthesis_request.txt' } } as StepUpdate,
            // (UI显示等待)
            { runId, taskId: 'task_synthesis', content: '# Agile-Boot 项目总体设计文档\n\n' } as StreamChunk,
            { runId, taskId: 'task_synthesis', content: '本文档旨在提供Agile-Boot项目的整体架构...' } as StreamChunk,
            { runId, taskId: 'task_synthesis', stepName: "综合: 生成最终文档", status: 'completed' } as StepExecution,

            // === 最终结果 ===
            { runId, status: 'completed', finalOutput: "项目总体设计文档.md 已生成。" } as AgentResult
        ];


        const intervalId = setInterval(() => {
            if (eventIndex >= mockEventStream.length) {
                clearInterval(intervalId);
                return;
            }

            const event = mockEventStream[eventIndex++];
            
            
            // 更稳健的类型检查和派发，修复了原有逻辑错误
            if ('stepName' in event && 'status' in event && 'runId' in event) {
                // 这是 StepExecution 事件
                agentBlock.updateStepExecutionStatus(event as StepExecution | StepResult); 
            } else if ('status' in event && 'runId' in event && !('stepName' in event)) {
                // 这是 AgentResult 事件
                 agentBlock.setAgentResult(event as AgentResult);
            } else if ('type' in event && 'data' in event) {
                // 这是 StepUpdate 事件
                agentBlock.addStepLog(event as StepUpdate);
            } else if ('content' in event && !('role' in event)) {
                // 这是 StreamChunk 事件
                 agentBlock.appendStreamChunk(event as StreamChunk);
            }
            

        }, 3000); // 每 800 毫秒发送一个事件
    }
}

--------------------------------------------------------------------------------

--- file_path: webview/views/FocusEditorView.ts ---
import { vscode } from "../vscode";
import { ModelConfig, Prompt } from "../../common/types";

export class FocusEditorView {
    private parent: HTMLElement;
    private modelConfigs: ModelConfig[] = [];
    private prompts: Prompt[] = [];
    private modelSelector: HTMLSelectElement;
    private promptSelector: HTMLSelectElement;
    private textarea: HTMLTextAreaElement;

    constructor(container: HTMLElement, initialData: { content: string, modelId?: string, promptId?: string }) {
        this.parent = container;
        this.parent.innerHTML = this.render();
        
        this.modelSelector = this.parent.querySelector('#model-selector') as HTMLSelectElement;
        this.promptSelector = this.parent.querySelector('#prompt-selector') as HTMLSelectElement;
        this.textarea = this.parent.querySelector('textarea') as HTMLTextAreaElement;

        this.textarea.value = initialData.content;
        if (initialData.modelId) {
            this.modelSelector.value = initialData.modelId;
        }
        if (initialData.promptId) {
            this.promptSelector.value = initialData.promptId;
        }

        this.setupEventListeners();
    }

    public render(): string {
        return `
            <div class="focus-editor-container">
                <div class="chat-quick-actions">
                    <label for="model-selector">Model:</label>
                    <select id="model-selector"></select>
                    <label for="prompt-selector">Prompt:</label>
                    <select id="prompt-selector"></select>
                    <button data-action="minimize-editor" title="恢复至侧边栏">
                        <i class="codicon codicon-screen-normal"></i>
                    </button>
                    <button data-action="send-message">Send</button>
                </div>
                <div class="chat-input-box-container">
                     <textarea placeholder="输入消息，或从下拉菜单选择提示词..."></textarea>
                </div>
            </div>
        `;
    }

    private setupEventListeners() {
        this.parent.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            const button = target.closest('button');
            if (!button) return;

            const action = button.dataset.action;
            switch (action) {
                case 'send-message':
                    this.handleSendMessage();
                    break;
                case 'minimize-editor':
                    vscode.postMessage({ command: 'closeFocusEditor' });
                    break;
            }
        });

        this.modelSelector.addEventListener('change', () => {
            vscode.postMessage({
                command: 'syncStateChange',
                payload: { modelId: this.modelSelector.value }
            });
        });

        this.promptSelector.addEventListener('change', () => {
            const selectedPromptId = this.promptSelector.value;
            vscode.postMessage({
                command: 'syncStateChange',
                payload: { promptId: selectedPromptId }
            });
        });

        this.textarea.addEventListener('input', () => {
            vscode.postMessage({
                command: 'updateWebviewContent',
                payload: { content: this.textarea.value }
            });
        });

        this.textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.handleSendMessage();
            }
        });

        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.command) {
                case 'updateState':
                    this.updateState(message.payload);
                    break;
                case 'updatePrompts':
                    this.setPrompts(message.payload);
                    break;
                case 'updateContent':
                    this.updateContent(message.payload.content);
                    break;
            }
        });
    }

    public setModelConfigs(configs: ModelConfig[]) {
        this.modelConfigs = configs;
        const currentVal = this.modelSelector.value;
        this.renderModelSelector();
        this.modelSelector.value = currentVal;
    }

    public setPrompts(prompts: Prompt[]) {
        this.prompts = prompts;
        const currentVal = this.promptSelector.value;
        this.renderPromptSelector();
        this.promptSelector.value = currentVal;
    }

    public updateContent(content: string) {
        if (this.textarea.value !== content) {
            this.textarea.value = content;
        }
    }

    public updateState(state: { modelId?: string, promptId?: string }) {
        if (state.modelId) {
            this.modelSelector.value = state.modelId;
        }
        if (state.promptId) {
            this.promptSelector.value = state.promptId;
        }
    }

    public clearInput() {
        this.textarea.value = '';
    }

    private handleSendMessage() {
        const prompt = this.textarea.value.trim();
        if (prompt) {
            const selectedModelId = this.modelSelector.value;
            const selectedConfig = this.modelConfigs.find(c => c.id === selectedModelId);

            if (!selectedConfig) {
                vscode.postMessage({ command: 'error', payload: 'Please select a valid model from settings.' });
                return;
            }
            
            vscode.postMessage({ command: 'sendMessage', payload: { prompt, config: selectedConfig } });
            this.clearInput();
        }
    }

    private renderModelSelector() {
        this.modelSelector.innerHTML = '';
        const defaultModel = this.modelConfigs.find(c => c.isDefault);
        this.modelConfigs.forEach(config => {
            const option = document.createElement('option');
            option.value = config.id;
            option.textContent = config.name;
            if (defaultModel && config.id === defaultModel.id) {
                option.selected = true;
            }
            this.modelSelector.appendChild(option);
        });
    }

    private renderPromptSelector() {
        this.promptSelector.innerHTML = '<option value="">Select a prompt...</option>';
        this.prompts.forEach(prompt => {
            const option = document.createElement('option');
            option.value = prompt.id;
            option.textContent = prompt.title;
            this.promptSelector.appendChild(option);
        });
    }

}


--------------------------------------------------------------------------------

--- file_path: webview/views/PerformanceSettingsView.ts ---
// --- file_path: webview/views/PerformanceSettingsView.ts ---
import { PerformanceConfig } from "../../common/types";
import { vscode } from "../vscode";

export class PerformanceSettingsView {
    private config: PerformanceConfig | null = null;

    constructor(private readonly parent: HTMLElement) {
        // 初始渲染为空，等待数据
        this.parent.innerHTML = '';
        this.setupEventListeners();
    }

    public setPerformanceConfig(config: PerformanceConfig) {
        this.config = config;
        this.render();
    }

    private setupEventListeners() {
        this.parent.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            const button = target.closest('button');
            if (!button || !button.matches('.btn-save-perf')) return;

            this.saveConfig();
        });
    }

    private saveConfig() {
        const form = this.parent.querySelector('#perf-config-form') as HTMLFormElement;
        if (!form || !this.config) return;

        const newConfig: PerformanceConfig = {
            concurrencyLimit: parseInt((form.querySelector('input[name="concurrencyLimit"]') as HTMLInputElement).value, 10) || this.config.concurrencyLimit,
            minInterval: parseInt((form.querySelector('input[name="minInterval"]') as HTMLInputElement).value, 10) || this.config.minInterval,
            maxTokensPerBatch: parseInt((form.querySelector('input[name="maxTokensPerBatch"]') as HTMLInputElement).value, 10) || this.config.maxTokensPerBatch,
            maxTokensForDirectAnalysis: parseInt((form.querySelector('input[name="maxTokensForDirectAnalysis"]') as HTMLInputElement).value, 10) || this.config.maxTokensForDirectAnalysis,
        };

        vscode.postMessage({ command: 'savePerformanceConfig', payload: newConfig });
        vscode.postMessage({ command: 'info', payload: 'Performance settings saved.' });
    }

    private render() {
        if (!this.config) {
            this.parent.innerHTML = `<p>Loading performance settings...</p>`;
            return;
        }

        this.parent.innerHTML = `
            <div class="settings-container">
                <div class="view-header">
                    <h2>性能与限制设置</h2>
                </div>
                <form class="config-form" id="perf-config-form">
                    <div class="form-group">
                        <label for="concurrencyLimit">LLM 最大并发请求数</label>
                        <input type="number" id="concurrencyLimit" name="concurrencyLimit" value="${this.config.concurrencyLimit}">
                        <div class="form-group-description">同时向语言模型发送的最大请求数量。较低的值可以避免超出 API 速率限制。</div>
                    </div>
                    <div class="form-group">
                        <label for="minInterval">LLM 请求最小间隔 (毫秒)</label>
                        <input type="number" id="minInterval" name="minInterval" value="${this.config.minInterval}">
                        <div class="form-group-description">两次连续的 LLM 请求之间的最小时间间隔，用于控制请求频率。</div>
                    </div>
                    <div class="form-group">
                        <label for="maxTokensPerBatch">Map-Reduce 每批最大 Token 数</label>
                        <input type="number" id="maxTokensPerBatch" name="maxTokensPerBatch" value="${this.config.maxTokensPerBatch}">
                        <div class="form-group-description">在使用 Map-Reduce 策略分析大模块时，每个批次包含的最大 Token 数量。</div>
                    </div>
                    <div class="form-group">
                        <label for="maxTokensForDirectAnalysis">直接分析最大 Token 阈值</label>
                        <input type="number" id="maxTokensForDirectAnalysis" name="maxTokensForDirectAnalysis" value="${this.config.maxTokensForDirectAnalysis}">
                        <div class="form-group-description">当模块总 Token 数低于此值时，将使用直接分析策略，否则切换到 Map-Reduce。</div>
                    </div>
                    <div class="form-actions">
                        <button type="button" class="btn-save-perf">保存设置</button>
                    </div>
                </form>
            </div>
        `;
    }
}

--------------------------------------------------------------------------------

--- file_path: webview/views/PromptEditorView.ts ---
import { Prompt } from '../../common/types';
import { vscode } from '../vscode';

export class PromptEditorView {
    private element: HTMLElement;
    private prompt: Prompt | null = null;
    private isDirty = false;

    constructor(private readonly parent: HTMLElement) {
        this.element = document.createElement('div');
        this.element.className = 'prompt-editor-view';
        this.parent.appendChild(this.element);
    }

    public show(prompt?: Prompt) {
        this.prompt = prompt ? { ...prompt } : null;
        this.isDirty = false;
        this.render();
        this.addEventListeners();
        this.element.style.display = 'flex';
    }

    public hide() {
        if (this.isDirty) {
            const confirmation = window.confirm('您有未保存的更改，确定要放弃吗？');
            if (!confirmation) {
                return;
            }
        }
        this.element.style.display = 'none';
        this.element.innerHTML = '';
        // Let the extension handle the navigation
        vscode.postMessage({ command: 'cancelPromptEdit' });
    }

    private render() {
        const title = this.prompt?.title ?? '';
        const content = this.prompt?.content ?? '';
        const headerTitle = this.prompt ? `编辑: ${title}` : '新建提示词';

        this.element.innerHTML = `
            <div class="view-header">
                <h3>${headerTitle}</h3>
                <div class="actions">
                    <button id="save-prompt-btn" class="codicon-btn">
                        <i class="codicon codicon-save"></i>
                        <span>保存</span>
                    </button>
                    <button id="cancel-prompt-edit-btn" class="codicon-btn secondary">
                        <i class="codicon codicon-close"></i>
                        <span>取消</span>
                    </button>
                </div>
            </div>
            <div class="prompt-editor-form">
                <div class="form-group">
                    <label for="prompt-title">标题</label>
                    <input type="text" id="prompt-title" value="${title}" required>
                </div>
                <div class="form-group">
                    <label for="prompt-content">内容</label>
                    <textarea id="prompt-content" rows="15">${content}</textarea>
                </div>
            </div>
        `;
    }

    private addEventListeners() {
        const saveBtn = this.element.querySelector('#save-prompt-btn');
        const cancelBtn = this.element.querySelector('#cancel-prompt-edit-btn');
        const titleInput = this.element.querySelector('#prompt-title') as HTMLInputElement;
        const contentTextArea = this.element.querySelector('#prompt-content') as HTMLTextAreaElement;

        const markDirty = () => { this.isDirty = true; };
        titleInput.addEventListener('input', markDirty);
        contentTextArea.addEventListener('input', markDirty);

        if (saveBtn) {
            saveBtn.addEventListener('click', () => {
                if (!titleInput.value.trim()) {
                    vscode.postMessage({ command: 'showError', payload: '标题不能为空。' });
                    return;
                }

                const now = new Date().toISOString();
                const promptToSave: Prompt = {
                    id: this.prompt?.id || `prompt_${Date.now()}`,
                    title: titleInput.value.trim(),
                    content: contentTextArea.value,
                    createdAt: this.prompt?.createdAt || now,
                    updatedAt: now,
                };

                vscode.postMessage({ command: 'savePrompt', payload: promptToSave });
                this.isDirty = false;
            });
        }

        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                this.hide();
            });
        }
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/PromptManagerView.ts ---
import { Prompt } from '../../common/types';
import { vscode } from '../vscode';

export class PromptManagerView {
    private prompts: Prompt[] = [];
    private filteredPrompts: Prompt[] = [];
    private element: HTMLElement;

    constructor(private readonly parent: HTMLElement) {
        this.element = document.createElement('div');
        this.element.className = 'prompt-manager-view';
        this.parent.appendChild(this.element);
        this.render();
        this.addEventListeners();
    }

    public update(prompts: Prompt[]) {
        this.prompts = prompts.sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
        this.filteredPrompts = [...this.prompts];
        this.render();
        this.addEventListeners();
    }

    public getPrompts(): Prompt[] {
        return this.prompts;
    }

    private render() {
        this.element.innerHTML = `
            <div class="view-header">
                <div class="search-bar">
                    <i class="codicon codicon-search"></i>
                    <input type="text" id="prompt-search-input" placeholder="搜索提示词...">
                </div>
                <button id="new-prompt-btn" class="codicon-btn">
                    <i class="codicon codicon-add"></i>
                    <span>新建提示词</span>
                </button>
            </div>
            <div class="prompt-list-container">
                ${this.filteredPrompts.length > 0 ? this.renderList() : this.renderEmptyState()}
            </div>
        `;
    }

    private renderList(): string {
        return `
            <ul class="prompt-list">
                ${this.filteredPrompts.map(prompt => this.renderListItem(prompt)).join('')}
            </ul>
        `;
    }

    private renderListItem(prompt: Prompt): string {
        const summary = prompt.content.substring(0, 100) + (prompt.content.length > 100 ? '...' : '');
        const lastUpdated = new Date(prompt.updatedAt).toLocaleString();

        return `
            <li class="prompt-list-item" data-id="${prompt.id}">
                <div class="prompt-item-main">
                    <div class="prompt-item-title">${prompt.title}</div>
                    <div class="prompt-item-summary">${summary}</div>
                </div>
                <div class="prompt-item-meta">
                    <div class="prompt-item-time">${lastUpdated}</div>
                    <div class="prompt-item-actions">
                        <button class="icon-btn edit-prompt-btn" data-id="${prompt.id}" title="编辑">
                            <i class="codicon codicon-edit"></i>
                        </button>
                        <button class="icon-btn delete-prompt-btn" data-id="${prompt.id}" title="删除">
                            <i class="codicon codicon-trash"></i>
                        </button>
                    </div>
                </div>
            </li>
        `;
    }

    private renderEmptyState(): string {
        return `
            <div class="empty-state">
                <p>您还没有任何提示词模板，点击“新建提示词”来创建第一个吧！</p>
                <button id="new-prompt-btn-empty" class="highlighted-btn">新建提示词</button>
            </div>
        `;
    }

    private addEventListeners() {
        // New prompt button
        const newPromptBtn = this.element.querySelector('#new-prompt-btn');
        if (newPromptBtn) {
            newPromptBtn.addEventListener('click', () => {
                vscode.postMessage({ command: 'newPrompt' });
            });
        }
        const newPromptBtnEmpty = this.element.querySelector('#new-prompt-btn-empty');
        if (newPromptBtnEmpty) {
            newPromptBtnEmpty.addEventListener('click', () => {
                vscode.postMessage({ command: 'newPrompt' });
            });
        }

        // Search input
        const searchInput = this.element.querySelector('#prompt-search-input') as HTMLInputElement;
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                const searchTerm = (e.target as HTMLInputElement).value.toLowerCase();
                this.filteredPrompts = this.prompts.filter(p => 
                    p.title.toLowerCase().includes(searchTerm) || 
                    p.content.toLowerCase().includes(searchTerm)
                );
                this.render();
                this.addEventListeners();
            });
        }

        // List item clicks
        this.element.querySelectorAll('.prompt-list-item').forEach(item => {
            item.addEventListener('click', (e) => {
                const target = e.target as HTMLElement;
                // Don't trigger edit if clicking on a button
                if (!target.closest('button')) {
                    const promptId = item.getAttribute('data-id');
                    if (promptId) {
                        vscode.postMessage({ command: 'editPrompt', payload: { id: promptId } });
                    }
                }
            });
        });

        // Edit buttons
        this.element.querySelectorAll('.edit-prompt-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const promptId = (btn as HTMLElement).dataset.id;
                if (promptId) {
                    vscode.postMessage({ command: 'editPrompt', payload: { id: promptId } });
                }
            });
        });

        // Delete buttons
        this.element.querySelectorAll('.delete-prompt-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const promptId = (btn as HTMLElement).dataset.id;
                if (promptId) {
                    vscode.postMessage({ command: 'deletePrompt', payload: { id: promptId } });
                }
            });
        });
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/SettingsView.ts ---
import { ModelConfig } from "../../common/types";
import { vscode } from "../vscode";

export class SettingsView {
    private configs: ModelConfig[] = [];

    constructor(private readonly parent: HTMLElement) {
        this.render();
        this.setupEventListeners();
    }

    public setModelConfigs(configs: ModelConfig[]) {
        this.configs = configs;
        this.render();
    }

    public getModelConfigs(): ModelConfig[] {
        return this.configs;
    }

    private setupEventListeners() {
        this.parent.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            const button = target.closest('button');
            if (!button) return;

            const id = button.dataset.id;
            if (button.matches('.btn-add-model')) {
                this.addEmptyConfigForm();
            } else if (button.matches('.btn-save-model')) {
                this.saveConfig(id);
            } else if (button.matches('.btn-delete-model')) {
                this.deleteConfig(id);
            } else if (button.matches('.btn-set-default')) {
                this.setDefault(id);
            }
        });
    }

    private addEmptyConfigForm() {
        const newConfig: ModelConfig = { 
            id: `new-${Date.now()}`, 
            name: '', 
            baseUrl: '', 
            apiKey: '', 
            modelId: '',
            isDefault: this.configs.length === 0 
        };
        this.configs.push(newConfig);
        this.render();
    }

    private saveAllConfigs() {
        vscode.postMessage({ command: 'saveModelConfigs', payload: this.configs });
    }

    private setDefault(id?: string) {
        if (!id) return;
        this.configs.forEach(c => c.isDefault = c.id === id);
        this.saveAllConfigs();
        this.render();
    }

    private saveConfig(id?: string) {
        if (!id) return;
        const form = this.parent.querySelector(`#config-form-${id}`) as HTMLFormElement;
        if (!form) return;

        const name = (form.querySelector('input[name="name"]') as HTMLInputElement).value;
        const baseUrl = (form.querySelector('input[name="baseUrl"]') as HTMLInputElement).value;
        const apiKey = (form.querySelector('input[name="apiKey"]') as HTMLInputElement).value;
        const modelId = (form.querySelector('input[name="modelId"]') as HTMLInputElement).value;

        const index = this.configs.findIndex(c => c.id === id);
        if (index === -1) return;

        const isNew = id.startsWith('new-');
        const newId = isNew ? `model-${Date.now()}` : id;
        
        this.configs[index] = { ...this.configs[index], id: newId, name, baseUrl, apiKey, modelId };
        
        this.saveAllConfigs();
    }

    private deleteConfig(id?: string) {
        if (!id) return;
        this.configs = this.configs.filter(c => c.id !== id);
        // If the deleted model was the default, make the first one default
        if (this.configs.length > 0 && !this.configs.some(c => c.isDefault)) {
            this.configs[0].isDefault = true;
        }
        this.saveAllConfigs();
    }

    private render() {
        this.parent.innerHTML = `
            <div class="settings-container">
                <div class="view-header">
                    <h2>Model Settings</h2>
                    <button class="btn-add-model add-btn" title="Add new model configuration">
                        <i class="codicon codicon-add"></i>
                    </button>
                </div>
                <div id="model-configs-list">
                    ${this.configs.map(config => this.renderConfigForm(config)).join('')}
                </div>
            </div>
        `;
    }

    private renderConfigForm(config: ModelConfig): string {
        return `
            <form class="config-form" id="config-form-${config.id}" data-id="${config.id}">
                <div class="form-header">
                    <strong class="form-title">${config.name || 'New Model'}</strong>
                    ${config.isDefault ? '<span class="default-badge">Default</span>' : ''}
                </div>
                <div class="form-group">
                    <label for="name-${config.id}">Model Name</label>
                    <input type="text" id="name-${config.id}" name="name" placeholder="e.g., GPT-4o" value="${config.name}">
                </div>
                <div class="form-group">
                    <label for="baseUrl-${config.id}">Base URL</label>
                    <input type="text" id="baseUrl-${config.id}" name="baseUrl" placeholder="https://api.openai.com/v1" value="${config.baseUrl}">
                </div>
                <div class="form-group">
                    <label for="apiKey-${config.id}">API Key</label>
                    <input type="password" id="apiKey-${config.id}" name="apiKey" placeholder="sk-..." value="${config.apiKey}">
                </div>
                <div class="form-group">
                    <label for="modelId-${config.id}">Model ID</label>
                    <input type="text" id="modelId-${config.id}" name="modelId" placeholder="gpt-4o" value="${config.modelId}">
                </div>
                <div class="form-actions">
                    <button type="button" class="btn-save-model" data-id="${config.id}">Save</button>
                    <button type="button" class="btn-delete-model" data-id="${config.id}">Delete</button>
                    ${!config.isDefault ? `<button type="button" class="btn-set-default" data-id="${config.id}">Set as Default</button>` : ''}
                </div>
            </form>
        `;
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/WelcomeView.ts ---
export class WelcomeView {
    constructor(private readonly parent: HTMLElement) {
        this.parent.innerHTML = this.render();
    }

    private render(): string {
        return `
            <div class="welcome-container">
                <h2>Welcome to CodeWiki</h2>
                <p>Your intelligent assistant for software design.</p>
                <button id="btn-new-chat">New Chat</button>
            </div>
        `;
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/vscode.ts ---
import type { PostMessage } from '../common/types';

/**
 * A typed wrapper around the VS Code API that is exposed to the webview.
 */
interface VsCodeApi {
    postMessage(message: PostMessage): void;
    getState(): any;
    setState(newState: any): void;
}

declare const acquireVsCodeApi: () => VsCodeApi;

export const vscode = acquireVsCodeApi();

>>>>>>> df11cf891b83c29b010f368ccfeadfd9a68d007b

--------------------------------------------------------------------------------

--- file_path: extension/extension.ts ---
// src/extension/extension.ts (修改后完整文件)

import * as vscode from 'vscode';
import { CodeWikiViewProvider } from './CodeWikiViewProvider';
import { StateManager } from './StateManager';
import { LLMService } from './services/LLMService';
import { AgentService } from './services/AgentService';
import { init } from 'tiktoken/init';

/**
 * 检查并确保提示词文件已复制到用户工作区的 .codewiki 目录中。
 * 如果 .codewiki 目录或其中的提示词文件不存在，则会创建它们。
 * @param context 扩展上下文，用于获取插件的安装路径。
 */
async function ensurePromptsAreCopied(context: vscode.ExtensionContext): Promise<void> {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders || workspaceFolders.length === 0) {
        // 没有打开的工作区，无需执行任何操作
        return;
    }
    const workspaceRoot = workspaceFolders[0].uri;
    const codewikiDir = vscode.Uri.joinPath(workspaceRoot, '.codewiki');
    const sourcePromptsDir = vscode.Uri.joinPath(context.extensionUri, 'dist', 'prompts');

    try {
        // 检查 .codewiki 目录是否存在
        await vscode.workspace.fs.stat(codewikiDir);
    } catch (error) {
        // 如果目录不存在 (FileNotFound error)，则创建它
        if (error instanceof vscode.FileSystemError && error.code === 'FileNotFound') {
            console.log("'.codewiki' directory not found. Creating it and copying prompts...");
            await vscode.workspace.fs.createDirectory(codewikiDir);
        } else {
            // 对于其他错误，打印并重新抛出
            console.error("Error checking .codewiki directory:", error);
            throw error;
        }
    }

    // 无论目录是已存在还是刚创建，都检查并复制所有提示词文件
    try {
        const bundledPromptFiles = await vscode.workspace.fs.readDirectory(sourcePromptsDir);
        for (const [fileName, fileType] of bundledPromptFiles) {
            if (fileType === vscode.FileType.File) {
                const sourceUri = vscode.Uri.joinPath(sourcePromptsDir, fileName);
                const targetUri = vscode.Uri.joinPath(codewikiDir, fileName);

                try {
                    // 尝试访问目标文件，如果不存在则会抛出错误
                    await vscode.workspace.fs.stat(targetUri);
                } catch {
                    // 文件不存在，执行复制操作
                    console.log(`Prompt file '${fileName}' not found in .codewiki. Copying...`);
                    await vscode.workspace.fs.copy(sourceUri, targetUri);
                }
            }
        }
    } catch (e) {
        console.error("Failed to copy prompt files:", e);
        vscode.window.showErrorMessage("CodeWiki: Failed to initialize required prompt files. Please try reloading the window.");
    }
}

// --- 新增：tiktoken 初始化函数 ---
async function initializeTiktoken(context: vscode.ExtensionContext): Promise<void> {
    try {
        // 构建 WASM 文件在扩展安装目录中的绝对路径
        const wasmUri = vscode.Uri.joinPath(context.extensionUri, 'dist', 'tiktoken_bg.wasm');
        
        // 读取 WASM 文件的二进制内容
        const wasmBytes = await vscode.workspace.fs.readFile(wasmUri);

        // 初始化 tiktoken
        await init((imports) => WebAssembly.instantiate(wasmBytes, imports));
        console.log("tiktoken initialized successfully.");

    } catch (err) {
        console.error("Failed to initialize tiktoken:", err);
        // 这是一个严重错误，可以考虑向用户显示一个错误消息
        vscode.window.showErrorMessage("CodeWiki: Failed to load a critical component (tiktoken). Token counting will not work.");
        // 你可以选择在这里抛出错误，以阻止插件继续加载
        throw err;
    }
}


export async function activate(context: vscode.ExtensionContext) {
    // --- 新增：最先执行 tiktoken 初始化 ---
    await initializeTiktoken(context);

    // --- 新增：在所有服务初始化之前，确保提示词已就绪 ---
    await ensurePromptsAreCopied(context);
    // --------------------------------------------------

    // --- 服务初始化 ---
    const stateManager = new StateManager(context.globalState);
    const llmService = new LLMService();
    const agentService = new AgentService(llmService, stateManager); 

    // 获取默认模型并初始化服务
    const modelConfigs = await stateManager.getModelConfigs();
    const defaultConfig = modelConfigs.find(c => c.isDefault) || modelConfigs[0];
    if (defaultConfig) {
        await agentService.initialize(defaultConfig);
    } else {
        console.warn("No default model config found. Agent Service might not function correctly.");
    }
    // --- 结束服务初始化 ---

    // 首次激活时，也应用一次性能配置
    const perfConfig = await stateManager.getPerformanceConfig();
    llmService.concurrencyLimit = perfConfig.concurrencyLimit;
    llmService.minInterval = perfConfig.minInterval;

    const provider = new CodeWikiViewProvider(context.extensionUri, context, agentService); // <-- 注入 AgentService

    context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(CodeWikiViewProvider.viewType, provider)
    );

    // --- 命令注册 ---
    const generateProjectDocDisposable = vscode.commands.registerCommand('codewiki.generateProjectDocumentation', async () => {
        const modelConfigs = await stateManager.getModelConfigs();
        const defaultConfig = modelConfigs.find(c => c.isDefault) || modelConfigs[0];
            
        if (!defaultConfig) {
            vscode.window.showErrorMessage("No default model configuration found. Please configure a model in the CodeWiki settings.");
            return;
        }

        // 调用变得非常简单
        await agentService.runProjectDocumentation(defaultConfig);
    });
    
    context.subscriptions.push(generateProjectDocDisposable);

    // 移除了旧的 codewiki.runAgent 命令，因为它的逻辑已经被新的架构和Webview触发器所取代。
}

export function deactivate() {}

--------------------------------------------------------------------------------

--- file_path: extension/services/AgentService.ts ---
// src/extension/services/AgentService.ts (完整文件)

import * as vscode from 'vscode';
import { v4 as uuidv4 } from 'uuid';
import { ModelConfig, AgentPlan, PerformanceConfig } from '../../common/types';
import { StateManager } from '../StateManager';
import { AgentContext } from '../agents/AgentContext';
import { ProjectDocumentationOrchestrator } from '../agents/orchestrators/ProjectDocumentationOrchestrator';
import { ToolChainExecutor } from '../agents/executors/ToolChainExecutor';
import { MapReduceExecutor } from '../agents/executors/MapReduceExecutor';
import { AgentLogger, VscodeOutputChannelLogger, WebviewLogger } from './logging';
import { LLMService } from './LLMService';
import { ToolRegistry } from './ToolRegistry';
import { StatsTracker } from './StatsTracker';

// 在文件顶部或一个新文件中定义Agent元数据
/**
 * Agent元数据定义。
 * 这是所有可用Agent的“注册表”，定义了它们的ID、名称、步骤和所需参数。
 */
const AGENT_DEFINITIONS: Record<string, AgentPlan> = {
    'docgen-project': {
        agentId: 'docgen-project',
        agentName: '项目级文档生成',
        steps: [
            { name: "规划: 分析项目结构", description: "使用LLM分析文件树，识别核心模块。", promptFiles: ['project_planner.yml'] },
            { name: "分析: 并行处理模块", description: "对每个模块进行深入分析，可能使用直接或Map-Reduce策略。", promptFiles: ['module_analysis_direct.yml', 'module_analysis_mapreduce.yml'] },
            { name: "综合: 生成最终文档", description: "将所有模块的分析结果汇编成一篇完整的技术文档。", promptFiles: ['project_synthesis.yml'] }
        ],
        parameters: [
            { 
                name: 'source_path', 
                description: '要分析的源代码根目录（相对于工作区根目录）', 
                type: 'path',
                value: '.' // 默认值为项目根目录
            }
        ]
    },
    'docgen-module-direct': {
        agentId: 'docgen-module-direct',
        agentName: '模块级文档 (直接分析)',
        steps: [
            { name: "执行工具", description: "按顺序执行文件读取和分析工具。", promptFiles: ['module_analysis_direct.yml'] },
            { name: "生成最终响应", description: "使用LLM整合工具输出，生成模块文档。" }
        ],
        parameters: [
            { name: 'module_path', description: '需要分析的模块/文件夹路径', type: 'path' }
        ]
    },
    'docgen-module-mapreduce': {
        agentId: 'docgen-module-mapreduce',
        agentName: '模块级文档 (摘要总结)',
        steps: [
            { name: "解析与准备", description: "扫描指定路径下的所有文件并根据Token限制进行分批。" },
            { name: "Map阶段: 并行分析", description: "并行调用LLM为每个文件批次生成摘要。", promptFiles: ['module_analysis_mapreduce.yml'] },
            { name: "Reduce阶段: 综合摘要", description: "将所有批次的摘要合并，并由LLM生成最终的模块文档。" }
        ],
        parameters: [
            { name: 'module_path', description: '需要分析的模块/文件夹路径', type: 'path' }
        ]
    }
};

// 辅助函数：用于加载外部YAML文件
async function loadPromptFile(workspaceRoot: vscode.Uri, fileName: string): Promise<string> {
    const promptUri = vscode.Uri.joinPath(workspaceRoot, '.codewiki', fileName);
    try {
        const fileContent = await vscode.workspace.fs.readFile(promptUri);
        return Buffer.from(fileContent).toString('utf-8');
    } catch (e) {
        throw new Error(`无法加载提示词文件: ${fileName}。请确保它存在于 '.codewiki' 目录中。`);
    }
}


/**
 * AgentService 是UI层（如Commands, Webviews）与后台Agent执行逻辑之间的唯一接口。
 * 它负责组装Agent运行所需的一切，并启动它们。
 */
export class AgentService {
    private toolRegistry: ToolRegistry;
    private activeRuns = new Map<string, { logger: AgentLogger }>();

    // 注入 StateManager 以获取配置
    constructor(private llmService: LLMService, private stateManager: StateManager) {
        this.toolRegistry = new ToolRegistry(this.llmService);
    }

    public async initialize(defaultModelConfig: ModelConfig): Promise<void> {
        await this.toolRegistry.initialize(defaultModelConfig);
        console.log("AgentService initialized successfully.");
    }

    /**
     * 根据 Agent ID 获取其预定义的计划（元数据）。
     * @param agentId Agent的唯一标识符。
     * @returns 返回 AgentPlan 对象，如果未找到则返回 null。
     */
    public getAgentPlan(agentId: string): AgentPlan | null {
        const plan = AGENT_DEFINITIONS[agentId];
        return plan ? { ...plan } : null; // 返回一个副本以避免意外修改
    }

    /**
     * 取消一个正在运行的 Agent。
     * @param runId 要取消的运行的ID。
     */
    public async cancelAgentRun(runId: string) {
        const run = this.activeRuns.get(runId);
        if (run) {
            console.log(`Cancelling agent run ${runId}`);
            // 发送一个 "cancelled" 状态的最终事件
            run.logger.onAgentEnd({
                runId,
                status: 'cancelled',
                error: 'Agent run was cancelled by the user.'
            });
            // 从活动运行中移除，以防止后续的 'completed' 或 'failed' 事件被发送
            this.activeRuns.delete(runId);
        }
    }

    public async prepareAndRunAgent(
        agentId: string,
        userInputs: Record<string, any>,
        modelConfig: ModelConfig,
        logger: AgentLogger
    ) {
        const runId = uuidv4();
        const agentPlan = this.getAgentPlan(agentId);

        if (!agentPlan) {
            const errorMsg = `Agent with ID "${agentId}" not found.`;
            logger.onAgentEnd({ runId, status: 'failed', error: errorMsg });
            return;
        }

        // 填充从前端接收到的参数值
        agentPlan.parameters.forEach(param => {
            if (userInputs[param.name] !== undefined) {
                param.value = userInputs[param.name];
            }
        });

        // 从 StateManager 获取最新的性能配置
        const performanceConfig = await this.stateManager.getPerformanceConfig();

        // 在运行前更新 LLMService 的参数
        this.llmService.concurrencyLimit = performanceConfig.concurrencyLimit;
        this.llmService.minInterval = performanceConfig.minInterval;

        const statsTracker = new StatsTracker();

        const context: AgentContext = {
            logger,
            llmService: this.llmService,
            toolRegistry: this.toolRegistry,
            modelConfig,
            statsTracker,
            performanceConfig  // 注入到上下文中

        };

        const workspaceRoot = vscode.workspace.workspaceFolders?.[0].uri;
        if (!workspaceRoot) {
            logger.onAgentEnd({ runId, status: 'failed', error: 'No workspace folder open.' });
            return;
        }

        // --- 核心逻辑重构 ---
        let finalOutput: any = "执行成功"; // 默认成功消息

        try {
            this.activeRuns.set(runId, { logger }); // 注册运行

            switch (agentId) {
                case 'docgen-project': {
                    const projPrompts = {
                        plannerPrompt: await loadPromptFile(workspaceRoot, 'project_planner.yml'),
                        directAnalysisPrompt: await loadPromptFile(workspaceRoot, 'module_analysis_direct.yml'),
                        mapReduceAnalysisPrompt: await loadPromptFile(workspaceRoot, 'module_analysis_mapreduce.yml'),
                        synthesisPrompt: await loadPromptFile(workspaceRoot, 'project_synthesis.yml'),
                    };
                    const sourcePathParam = agentPlan.parameters.find(p => p.name === 'source_path');
                    const sourcePath = (sourcePathParam?.value as string) || '.'; // 如果未提供，则回退到默认值
                    const orchestrator = new ProjectDocumentationOrchestrator(context, projPrompts);
                    // Orchestrator 只负责执行，不负责上报最终状态
                    await orchestrator.run(runId, sourcePath);
                    break;
                }

                case 'docgen-module-direct': {
                    const directPromptYaml = await loadPromptFile(workspaceRoot, 'module_analysis_direct.yml');
                    const modulePathParam = agentPlan.parameters.find(p => p.name === 'module_path');
                    if (!modulePathParam || !modulePathParam.value) {
                        throw new Error("Missing required parameter: module_path");
                    }
                    const directInputs = { module_path: modulePathParam.value };

                    const toolchainExecutor = new ToolChainExecutor(context);
                    // 捕获执行器的结果作为 finalOutput
                    finalOutput = await toolchainExecutor.run(runId, directPromptYaml, directInputs);
                    break;
                }

                case 'docgen-module-mapreduce': {
                    const mapreducePromptYaml = await loadPromptFile(workspaceRoot, 'module_analysis_mapreduce.yml');
                    const modulePathParam = agentPlan.parameters.find(p => p.name === 'module_path');
                    if (!modulePathParam || !modulePathParam.value) {
                        throw new Error("Missing required parameter: module_path");
                    }
                    const mapreduceInputs = { module_path: modulePathParam.value };

                    const mapReduceExecutor = new MapReduceExecutor(context);
                    // 捕获执行器的结果作为 finalOutput
                    finalOutput = await mapReduceExecutor.run(runId, mapreducePromptYaml, mapreduceInputs);
                    break;
                }

                default:
                    throw new Error(`Execution for agent "${agentId}" is not yet implemented.`);
            }

            // 只有在运行没有被取消的情况下，才发送 'completed' 事件
            if (this.activeRuns.has(runId)) {
                const finalStats = statsTracker.getFinalStats();
                logger.onAgentEnd({ runId, status: 'completed', finalOutput, stats: finalStats });
            }

        } catch (error: any) {
            // 只有在运行没有被取消的情况下，才发送 'failed' 事件
            if (this.activeRuns.has(runId)) {
                const finalStats = statsTracker.getFinalStats();
                const errorMessage = error instanceof Error ? error.message : String(error);
                logger.onAgentEnd({ runId, status: 'failed', error: errorMessage, stats: finalStats });
            }
        } finally {
            this.activeRuns.delete(runId); // 确保在所有路径上都取消注册
        }
    }

    public async runProjectDocumentation(modelConfig: ModelConfig) {
        const logger = new VscodeOutputChannelLogger("CodeWiki Project Documentation");
        await this.prepareAndRunAgent('docgen-project', {}, modelConfig, logger);
    }

    public async runActionFromWebview(
        yamlContent: string,
        userInputs: Record<string, any>,
        modelConfig: ModelConfig,
        webview: vscode.Webview
    ) {
        const logger = new WebviewLogger(webview);
        const statsTracker = new StatsTracker(); // <-- 为 webview action 也创建 tracker
        const performanceConfig = await this.stateManager.getPerformanceConfig();

        // 在运行前更新 LLMService 的参数
        this.llmService.concurrencyLimit = performanceConfig.concurrencyLimit;
        this.llmService.minInterval = performanceConfig.minInterval;
        
        const context: AgentContext = {
            logger,
            llmService: this.llmService,
            toolRegistry: this.toolRegistry,
            modelConfig,
            statsTracker,
            performanceConfig, // <-- 将获取到的配置添加到上下文中
        };

        const runId = uuidv4();

        try {

            this.activeRuns.set(runId, { logger });

            const executor = new ToolChainExecutor(context);
            const result = await executor.run(runId, yamlContent, userInputs);


            if (this.activeRuns.has(runId)) {
                const finalStats = statsTracker.getFinalStats();
                logger.onAgentEnd({ runId, status: 'completed', finalOutput: result, stats: finalStats });
            }


        } catch (error: any) {

            if (this.activeRuns.has(runId)) {
                const finalStats = statsTracker.getFinalStats();
                const errorMessage = error instanceof Error ? error.message : String(error);
                logger.onAgentEnd({ runId, status: 'failed', error: errorMessage, stats: finalStats });
            }

        } finally {

            this.activeRuns.delete(runId);

        }
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/services/LLMService.ts ---
// src/extension/services/LLMService.ts (修改后完整文件)

import vscode from 'vscode';

import { ChatMessage, ModelConfig, TextChatMessage } from '../../common/types';

import { ChatOpenAI } from '@langchain/openai';
import { HumanMessage, AIMessage, BaseMessage } from '@langchain/core/messages';
import { BaseChatModel } from '@langchain/core/language_models/chat_models';
import { ChatGoogleGenerativeAI } from '@langchain/google-genai';

const USE_GEMINI = false;

export interface CreateModelOptions {
    modelConfig: ModelConfig;
    temperature?: number;
    streaming?: boolean;
}

/**
 * 定义一个可以放入队列的LLM任务。
 * 它包含一个返回Promise的函数，以及用于解决该Promise的resolver和rejecter。
 */
type LlmTask<T> = {
    task: () => Promise<T>;
    resolve: (value: T) => void;
    reject: (reason?: any) => void;
};

async function getGoogleApiKey(): Promise<string | undefined> {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) return undefined;
    const workspaceRoot = workspaceFolders[0].uri;
    const envPath = vscode.Uri.joinPath(workspaceRoot, '.codewiki', '.env');
    try {
        const contentBytes = await vscode.workspace.fs.readFile(envPath);
        const content = Buffer.from(contentBytes).toString('utf-8');
        const lines = content.split('\n');
        for (const line of lines) {
            const trimmedLine = line.trim();
            if (trimmedLine.startsWith('GOOGLE_API_KEY=')) {
                return trimmedLine.substring('GOOGLE_API_KEY='.length).trim();
            }
        }
    } catch (error) {
        if (!(error instanceof vscode.FileSystemError && error.code === 'FileNotFound')) {
            console.error("Error reading .codewiki/.env file:", error);
        }
    }
    return undefined;
}

export class LLMService {
    private _abortController: AbortController | null = null;

    // --- 新的并行速率限制器属性 ---
    private requestQueue: LlmTask<any>[] = [];
    private activeRequests = 0;
    private isProcessing = false;
    private lastRequestTime = 0;

    // --- 配置 ---
    public minInterval: number;
    public concurrencyLimit: number;

    constructor() {
        // 在构造函数中设置一个临时的默认值，它们将被 StateManager 的值覆盖
        this.minInterval = 10000;
        this.concurrencyLimit = 10;
    }


    public async createModel(options: CreateModelOptions): Promise<BaseChatModel> {
        const { modelConfig, temperature = 0.7, streaming = false } = options;
        if (USE_GEMINI) {
            console.log("[LLMService] Creating model using Google Gemini.");
            const apiKey = await getGoogleApiKey();
            if (!apiKey) throw new Error("Gemini execution failed: 'GOOGLE_API_KEY' not found in your .codewiki/.env file.");
            return new ChatGoogleGenerativeAI({ model: "gemini-1.5-flash-latest", apiKey, temperature });
        }

        const url = new URL(modelConfig.baseUrl);
        if (!url.pathname.includes('/v1')) {
            url.pathname = ('/v1' + url.pathname).replace(/\/+/g, '/');
        }
        const finalBaseUrl = url.toString().replace(/\/$/, '');

        return new ChatOpenAI({
            modelName: modelConfig.modelId,
            apiKey: modelConfig.apiKey,
            streaming,
            temperature,
            configuration: { baseURL: finalBaseUrl }
        });
    }

    /**
     * 新增：对LLM的响应进行后处理，移除思考过程标签。
     * @param content 从LLM收到的原始字符串内容。
     * @returns 清理后的字符串。
     */
    private _postProcessResponse(content: string): string {
        if (typeof content !== 'string') {
            return content;
        }
        // 查找最后一个 </think> 或 </thinking> 标签
        const thinkEndTagRegex = /<\/think(ing)?>/gi;
        let lastIndex = -1;
        let match;

        // 循环找到最后一个匹配项的索引
        while ((match = thinkEndTagRegex.exec(content)) !== null) {
            lastIndex = match.index + match[0].length;
        }

        // 如果找到了结束标签，则截取它之后的内容
        if (lastIndex !== -1) {
            return content.substring(lastIndex).trim();
        }

        // 如果没有找到结束标签，返回原始内容
        return content;
    }

    /**
     * 将一个非流式的LLM调用任务加入队列，并由并行的速率限制调度器执行。
     * @param task 一个返回LLM调用Promise的函数，例如 `() => llm.invoke(messages)`
     * @returns 一个在任务完成时解析的Promise
     */
    public scheduleLlmCall<T>(task: () => Promise<T>): Promise<T> {
        console.log(`[LLMService] ${new Date().toISOString()} A new call was scheduled. Queue size: ${this.requestQueue.length + 1}`);
        return new Promise<T>((resolve, reject) => {
            const resolvingPostProcessor = (result: T) => {
                if (typeof result === 'string') {
                    const processedResult = this._postProcessResponse(result);
                    resolve(processedResult as T);
                } else if (result instanceof BaseMessage) {
                    if (typeof result.content === 'string') {
                        const processedContent = this._postProcessResponse(result.content);
                        // --- highlight-start ---
                        // 修复：不再使用 .copy()，而是创建一个新的 AIMessage 实例。
                        // 这更明确，并且能解决 TypeScript 的类型推断问题。
                        // 我们将原始消息的其他属性（如 tool_calls）也传递过去。
                        const newResult = new AIMessage({
                            ...result, // 展开原始 result 的所有属性
                            content: processedContent, // 覆盖 content 属性
                        });
                        resolve(newResult as T);
                        // --- highlight-end ---
                    } else {
                        resolve(result);
                    }
                } else {
                    resolve(result);
                }
            };
            this.requestQueue.push({ task, resolve: resolvingPostProcessor, reject });
            this.processQueue();
        });
    }

    // 简化和修复 processQueue 逻辑
    private processQueue() {
        // 循环检查，直到无法再派发新任务
        while (this.requestQueue.length > 0 && this.activeRequests < this.concurrencyLimit) {
            const now = Date.now();
            const elapsed = now - this.lastRequestTime;
            const delay = Math.max(0, this.minInterval - elapsed);

            // 如果需要延迟，则设置一个定时器来重新触发 processQueue，然后退出循环
            if (delay > 0) {
                setTimeout(() => this.processQueue(), delay);
                return; // 退出当前循环，等待延迟结束
            }

            // 如果不需要延迟，立即派发一个任务
            const { task, resolve, reject } = this.requestQueue.shift()!;

            this.lastRequestTime = Date.now();
            this.activeRequests++;

            console.log(`[LLMService] ${new Date().toISOString()} Executing call. Active: ${this.activeRequests}, Queue: ${this.requestQueue.length}`);

            // 异步执行任务
            task()
                .then(resolve)
                .catch(reject)
                .finally(() => {
                    this.activeRequests--;
                    console.log(`[LLMService] ${new Date().toISOString()} Call finished. Active: ${this.activeRequests}, Queue: ${this.requestQueue.length}`);
                    // 任务完成后，再次尝试处理队列，以防有任务在等待
                    this.processQueue();
                });
        }
        // 如果循环结束（队列为空或达到并发上限），则函数自然返回。
    }

    public async getCompletion(
        messages: ChatMessage[],
        config: ModelConfig,
        onData: (chunk: string) => void,
        onEnd: () => void,
        onError: (error: any) => void
    ): Promise<void> {
        this._abortController = new AbortController();
        const signal = this._abortController.signal;
        let llm: BaseChatModel;

        try {
            llm = await this.createModel({ modelConfig: config, streaming: true, temperature: 0.7 });

            // Filter for text messages only and then map them
            const langchainMessages: BaseMessage[] = messages
                .filter((msg): msg is TextChatMessage => msg.type === 'text')
                .map(msg => msg.role === 'user' ? new HumanMessage(msg.content) : new AIMessage(msg.content));

            const stream = await llm.stream(langchainMessages, { signal });
            for await (const chunk of stream) {
                if (chunk.content) {
                    onData(chunk.content as string);
                }
            }
        } catch (error: any) {
            if (signal.aborted) {
                console.log('Request aborted by user.');
            } else {
                console.error("--- LANGCHAIN REQUEST FAILED ---");
                if (error instanceof Error) {
                    console.error("Full Error Object:", error);
                    onError(error);
                } else {
                    console.error("Unknown Error:", error);
                    onError(new Error(String(error)));
                }
                console.error("--- END OF ERROR ---");
            }
        } finally {
            onEnd();
            this._abortController = null;
        }
    }

    public abortRequest() {
        if (this._abortController) {
            this._abortController.abort();
        }
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/services/StatsTracker.ts ---
// src/extension/services/StatsTracker.ts
import { get_encoding, Tiktoken } from "tiktoken";

export interface AgentRunStats {
    duration: string;
    totalTokens: number;
    promptTokens: number;
    completionTokens: number;
}

/**
 * 在单次 Agent 运行期间跟踪和计算统计信息。
 */
export class StatsTracker {
    private startTime: number;
    private totalPromptTokens: number = 0;
    private totalCompletionTokens: number = 0;
    private tokenizer: Tiktoken;

    constructor() {
        this.startTime = Date.now();
        // 使用一个通用的编码器来估算，cl100k_base 适用于大多数现代 OpenAI 模型
        this.tokenizer = get_encoding("cl100k_base");
    }

    /**
     * 记录一次LLM调用的Token消耗。
     * @param prompt - 发送给模型的完整提示文本。
     * @param completion - 从模型接收到的完整响应文本。
     */
    public add(prompt: string, completion: string): void {
        try {
            const promptTokens = this.tokenizer.encode(prompt).length;
            const completionTokens = this.tokenizer.encode(completion).length;
            
            this.totalPromptTokens += promptTokens;
            this.totalCompletionTokens += completionTokens;
        } catch (e) {
            console.error("Token counting failed:", e);
        }
    }

    /**
     * 计算并返回最终的统计数据。
     * @returns {AgentRunStats} 最终的统计对象。
     */
    public getFinalStats(): AgentRunStats {
        const endTime = Date.now();
        const durationMs = endTime - this.startTime;
        const durationSec = (durationMs / 1000).toFixed(2);
        
        // 释放 tokenizer 资源
        this.tokenizer.free();

        return {
            duration: `${durationSec}s`,
            promptTokens: this.totalPromptTokens,
            completionTokens: this.totalCompletionTokens,
            totalTokens: this.totalPromptTokens + this.totalCompletionTokens,
        };
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/services/ToolRegistry.ts ---
// src/extension/services/ToolRegistry.ts (完整文件)

import { StructuredTool } from '@langchain/core/tools';
import { ModelConfig } from '../../common/types';
import { GetFileSummariesTool, GetFilesContentByListTool, GetAllFilesContentTool, GetDirectoryTreeTool } from '../tools/fileSystemTools';
import { createFileSelectorLLMTool } from '../tools/llmTools';
import { LLMService } from './LLMService';

/**
 * 负责在扩展启动时初始化所有工具，并按需提供。
 * 这是一个集中管理工具的单例服务。
 */
export class ToolRegistry {
    private tools = new Map<string, StructuredTool>();

    constructor(private llmService: LLMService) {}

    /**
     * 初始化所有工具，特别是那些需要LLM实例的工具。
     * @param defaultModelConfig 用于创建工具内部LLM的默认模型配置。
     */
    public async initialize(defaultModelConfig: ModelConfig): Promise<void> {
        // 为工具创建一个专用的、非流式的LLM实例
        const toolLlm = await this.llmService.createModel({
            modelConfig: defaultModelConfig,
            temperature: 0.1,
            streaming: false,
        });

        const allTools: StructuredTool[] = [
            new GetFileSummariesTool(),
            new GetFilesContentByListTool(),
            new GetAllFilesContentTool(),
            new GetDirectoryTreeTool(),
            createFileSelectorLLMTool(toolLlm, this.llmService),
        ];

        for (const tool of allTools) {
            this.tools.set(tool.name, tool);
        }
        console.log("ToolRegistry initialized with tools:", Array.from(this.tools.keys()));
    }

    /**
     * 根据名称获取单个工具。
     * @param name 工具的名称。
     * @returns 返回工具实例，如果找不到则返回undefined。
     */
    public getTool(name: string): StructuredTool | undefined {
        return this.tools.get(name);
    }
    
    /**
     * 根据名称列表获取一组工具。
     * @param names 工具名称的数组。
     * @returns 返回工具实例的数组。
     * @throws 如果有任何一个工具找不到，则抛出错误。
     */
    public getTools(names: string[]): StructuredTool[] {
         return names.map(name => {
             const tool = this.getTool(name);
             if (!tool) {
                 throw new Error(`Tool "${name}" not found in registry.`);
             }
             return tool;
         });
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/services/logging.ts ---
// src/extension/services/logging.ts (修改后完整文件)

import * as vscode from 'vscode';
import { AgentPlan, StepExecution, StepUpdate, StepResult, StreamChunk, AgentResult } from '../../common/types';
import * as path from 'path'; // 引入 path 模块

/**
 * Agent 执行过程中的通用日志记录器接口。
 * 这使得核心逻辑可以与具体的UI（如OutputChannel或Webview）解耦。
 */
export interface AgentLogger {
    info(message: string): void;
    warn(message:string): void;
    error(message: string, error?: Error): void;
    log(message: string): void; // 用于原始输出，如LLM的流式数据
    logLine(message: string): void; // 新增：用于打印带换行的详细日志
    show(preserveFocus?: boolean): void; // 可选，用于显示日志面板

    // --- 新增的结构化事件方法 ---
    onPlanGenerated(plan: AgentPlan): void;
    onStepStart(step: StepExecution): void;
    onStepUpdate(update: StepUpdate): void;
    onStepEnd(result: StepResult): void;
    onStreamChunk(chunk: StreamChunk): void;
    onAgentEnd(result: AgentResult): void;
}

/**
 * AgentLogger接口的一个实现，它将日志写入VS Code的Output Channel。
 */
export class VscodeOutputChannelLogger implements AgentLogger {
    private readonly channel: vscode.OutputChannel;
    private streamBuffer: { [key: string]: string } = {}; // 用于缓存流式数据

    constructor(channelName: string) {
        this.channel = vscode.window.createOutputChannel(channelName);
    }

    public info(message: string): void {
        this.channel.appendLine(`[INFO] ${message}`);
    }

    public warn(message: string): void {
        this.channel.appendLine(`[WARN] ${message}`);
    }

    public error(message: string, error?: Error): void {
        this.channel.appendLine(`[ERROR] ${message}`);
        if (error?.stack) {
            this.channel.appendLine(error.stack);
        }
    }

    public log(message: string): void {
        // 对于原始日志，我们不添加前缀，直接追加
        this.channel.append(message);
    }
    
    public logLine(message: string): void {
        this.channel.appendLine(message);
    }

    public show(preserveFocus: boolean = true): void {
        this.channel.show(preserveFocus);
    }

     /**
     * 新接口方法的优化实现
     */
    public onPlanGenerated(plan: AgentPlan): void {
        this.channel.appendLine(`[PLAN] Agent "${plan.agentName}" is ready.`);
        plan.steps.forEach((step, i) => {
            this.channel.appendLine(`  [Step ${i+1}] ${step.name}: ${step.description}`);
        });
    }

    public onStepStart(step: StepExecution): void {
        const id = step.taskId ? `${step.stepName} (Task: ${step.taskId})` : step.stepName;
        this.channel.appendLine(`\n--- [START] ${id} ---`);
        // 初始化当前任务的流式缓存
        if (step.taskId) {
            this.streamBuffer[step.taskId] = '';
        }
    }
    
    /**
     * 核心修改：对 onStepUpdate 的内容进行审查和简化
     */
    public onStepUpdate(update: StepUpdate): void {
        if (update.type === 'output') {
            // 检查元数据中是否包含文件路径信息
            if (update.metadata?.type === 'file' && typeof update.metadata.path === 'string') {
                // 如果是文件输出，只打印文件名
                const fileName = path.basename(update.metadata.path);
                this.channel.appendLine(`[OUTPUT] Generated file: ${fileName}`);
            } else {
                // 对于其他输出，提取内容并进行长度限制
                let outputStr = '';
                if (typeof update.data === 'object' && update.data !== null && 'content' in update.data) {
                    outputStr = String(update.data.content);
                } else {
                    outputStr = typeof update.data === 'string' ? update.data : JSON.stringify(update.data);
                }
                
                // // 如果内容过长，只打印摘要信息，否则打印完整内容
                // const MAX_LENGTH = 150;
                // if (outputStr.length > MAX_LENGTH) {
                //     this.channel.appendLine(`[OUTPUT] ${outputStr.substring(0, MAX_LENGTH)}... (Content too long)`);
                // } else {
                //     this.channel.appendLine(`[OUTPUT] ${outputStr}`);
                // }
            }
        }
        // 其他类型的 update (input, llm-request) 将被忽略，不打印
    }
    
    /**
     * 核心修改：onStepEnd 不再打印流式缓存，因为 onStreamChunk 已被禁用
     */
    public onStepEnd(result: StepResult): void {
        const id = result.taskId ? `${result.status.toUpperCase()} (Task: ${result.taskId})` : result.status.toUpperCase();
        
        // 如果失败，打印错误信息
        if (result.status === 'failed' && result.error) {
            this.channel.appendLine(`[ERROR] ${result.error}`);
        }
        
        this.channel.appendLine(`--- [${id}] ---`);
        // 不再需要处理 streamBuffer
    }

    /**
     * 核心修改：onStreamChunk 完全禁用，不执行任何操作
     */
    public onStreamChunk(chunk: StreamChunk): void {
        // Do nothing. We don't want to log stream chunks to the output channel.
    }

    public onAgentEnd(result: AgentResult): void {
        this.channel.appendLine(`\n====== [AGENT ${result.status.toUpperCase()}] ======`);
        if(result.error) {
            this.error("Agent failed", new Error(result.error));
        }
    }
}

/**
 * AgentLogger接口的一个实现，它将日志通过postMessage发送到Webview。
 */
export class WebviewLogger implements AgentLogger {
    constructor(private webview: vscode.Webview) {}

    info(message: string): void {
        // 只发送简洁的状态更新
        this.webview.postMessage({ command: 'agentStatusUpdate', payload: { status: 'info', message }});
    }

    warn(message: string): void {
        this.webview.postMessage({ command: 'agentStatusUpdate', payload: { status: 'warn', message }});
    }

    error(message: string, error?: Error): void {
        const errorMessage = error ? `${message}: ${error.message}` : message;
        this.webview.postMessage({ command: 'requestFailed', payload: { error: errorMessage }});
    }

    log(message: string): void {
        // 流式数据有专门的命令
        this.webview.postMessage({ command: 'streamData', payload: message });
    }

    logLine(message: string): void {
        // 对于Webview，一行详细日志可以被视为一个'info'状态
        this.info(message);
    }

    show(preserveFocus?: boolean | undefined): void {
        // Webview 默认就是可见的，此方法可以为空
    }

    // --- highlight-start ---
    // --- 任务1实现：填充结构化事件发送方法 ---
    public onPlanGenerated(plan: AgentPlan): void {
        this.webview.postMessage({ command: 'agent:planGenerated', payload: plan });
    }
    public onStepStart(step: StepExecution): void {
        this.webview.postMessage({ command: 'agent:stepStart', payload: step });
    }
    public onStepUpdate(update: StepUpdate): void {
        this.webview.postMessage({ command: 'agent:stepUpdate', payload: update });
    }
    public onStepEnd(result: StepResult): void {
        this.webview.postMessage({ command: 'agent:stepEnd', payload: result });
    }
    public onStreamChunk(chunk: StreamChunk): void { 
        this.webview.postMessage({ command: 'agent:streamChunk', payload: chunk });
    }
    public onAgentEnd(result: AgentResult): void {
        this.webview.postMessage({ command: 'agent:end', payload: result });
    }
    // --- highlight-end ---
}

--------------------------------------------------------------------------------

--- file_path: extension/tools/fileSystemTools.ts ---
// src/extension/tools/fileSystemTools.ts (完整文件)

import * as vscode from 'vscode';
import * as path from 'path';
import { z } from 'zod';
import { StructuredTool } from '@langchain/core/tools';
import { languageFilters, GENERIC_EXCLUDE, LanguageFilter } from '../config/fileFilters';

/**
 * 获取当前工作区的根路径。
 * @returns {string} 工作区根目录的绝对路径。
 * @throws {Error} 如果没有打开的工作区。
 */
function getWorkspaceRoot(): string {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders || workspaceFolders.length === 0) {
        throw new Error("没有打开的工作区。请先打开一个项目文件夹。");
    }
    return workspaceFolders[0].uri.fsPath;
}

/**
 * 新增的辅助函数，用于递归获取过滤后的文件路径。
 * @param dirUri 起始目录的URI
 * @param language 用于选择过滤规则的语言
 * @returns {Promise<vscode.Uri[]>} 过滤后的文件URI列表
 */
async function getFilteredFilePathsRecursive(dirUri: vscode.Uri, language: string = 'unknown'): Promise<vscode.Uri[]> {
    let files: vscode.Uri[] = [];
    const filter: LanguageFilter = languageFilters[language.toLowerCase()] || languageFilters.unknown;

    try {
        const entries = await vscode.workspace.fs.readDirectory(dirUri);

        for (const [name, type] of entries) {
            // 检查是否在通用排除列表中
            if (GENERIC_EXCLUDE.includes(name)) {
                continue;
            }

            const entryUri = vscode.Uri.joinPath(dirUri, name);
            if (type === vscode.FileType.File) {
                const extension = path.extname(name);
                const shouldInclude = filter.include.includes(extension);
                const shouldExclude = filter.exclude.some(pattern => name.endsWith(pattern));

                if (shouldInclude && !shouldExclude) {
                    files.push(entryUri);
                }
            } else if (type === vscode.FileType.Directory) {
                files = files.concat(await getFilteredFilePathsRecursive(entryUri, language));
            }
        }
    } catch (error) {
        console.warn(`Could not read directory ${dirUri.fsPath}:`, error);
    }
    return files;
}

/**
 * 一个LangChain工具，用于获取指定目录下所有文件的路径和内容摘要。
 * 摘要是文件的前20行。
 */
export class GetFileSummariesTool extends StructuredTool {
    static lc_name() {
        return "GetFileSummariesTool";
    }

    name = "get_file_summaries";
    description = "获取指定目录中所有文件的路径和内容摘要（文件的前20行）。用于在阅读完整文件之前，快速了解一个模块的结构。";

    schema = z.object({
        path: z.string().describe("从工作区根目录出发的相对路径。"),
        language: z.string().optional().describe("项目的编程语言 (例如 'typescript', 'python')，用于智能过滤文件。如果未提供，则使用通用规则。"),
    });

    protected async _call({ path: relativePath }: z.infer<typeof this.schema>): Promise<string> {
        try {
            const workspaceRoot = getWorkspaceRoot();
            const absolutePath = path.join(workspaceRoot, relativePath);

            const entries = await vscode.workspace.fs.readDirectory(vscode.Uri.file(absolutePath));
            const fileSummaries: string[] = [];

            for (const [name, type] of entries) {
                if (type === vscode.FileType.File) {
                    const filePath = path.join(absolutePath, name);
                    const fileUri = vscode.Uri.file(filePath);
                    
                    const contentBytes = await vscode.workspace.fs.readFile(fileUri);
                    const content = Buffer.from(contentBytes).toString('utf-8');
                    const summary = content.split('\n').slice(0, 20).join('\n');
                    
                    const fileRelativePath = path.relative(workspaceRoot, filePath);

                    fileSummaries.push(
                        `--- FILE: ${fileRelativePath.replace(/\\/g, '/')} ---\n${summary}\n--- END OF SUMMARY ---\n`
                    );
                }
            }

            if (fileSummaries.length === 0) {
                return `在目录 "${relativePath}" 中没有找到任何文件。`;
            }

            return fileSummaries.join('\n');
        } catch (error: any) {
            return `获取路径 "${relativePath}" 的文件摘要时出错: ${error.message}`;
        }
    }
}


/**
 * 一个LangChain工具，根据提供的文件路径列表，获取这些文件的完整内容。
 */
export class GetFilesContentByListTool extends StructuredTool {
    static lc_name() {
        return "GetFilesContentByListTool";
    }

    name = "get_files_content_by_list";
    description = "根据一个包含相对路径的列表，读取这些文件的完整内容。这个列表通常是文件选择工具的输出。";

    schema = z.object({
        file_paths: z.array(z.string()).describe("一个包含文件相对路径的数组，路径从工作区根目录开始计算。"),
    });

    protected async _call({ file_paths }: z.infer<typeof this.schema>): Promise<string> {
        if (!file_paths || file_paths.length === 0) {
            return "输入的文件列表为空，没有内容可以读取。";
        }

        try {
            const workspaceRoot = getWorkspaceRoot();
            const contentPromises = file_paths.map(async (relativePath) => {
                const absolutePath = path.join(workspaceRoot, relativePath);
                const fileUri = vscode.Uri.file(absolutePath);
                
                try {
                    const contentBytes = await vscode.workspace.fs.readFile(fileUri);
                    const content = Buffer.from(contentBytes).toString('utf-8');
                    return `--- FILE: ${relativePath.replace(/\\/g, '/')} ---\n${content}\n--- END OF FILE ---\n`;
                } catch (fileError: any) {
                    // 如果单个文件读取失败，返回错误信息而不是让整个工具失败
                    return `--- FILE: ${relativePath.replace(/\\/g, '/')} ---\n错误: 无法读取文件。 ${fileError.message}\n--- END OF FILE ---\n`;
                }
            });

            const allContents = await Promise.all(contentPromises);
            return allContents.join('\n');

        } catch (error: any) {
            // 捕获 getWorkspaceRoot 的错误
            return `获取文件内容时出错: ${error.message}`;
        }
    }
}

/**
 * 一个LangChain工具，用于递归获取指定目录下所有文件的完整内容。
 */
export class GetAllFilesContentTool extends StructuredTool {
    static lc_name() {
        return "GetAllFilesContentTool";
    }

    name = "get_all_files_content";
    description = "递归地获取指定目录及其所有子目录中所有文件的完整内容。当需要对一个模块的所有代码进行全面分析时使用。";

    schema = z.object({
        path: z.string().describe("从工作区根目录出发的相对路径。"),
        language: z.string().optional().describe("项目的编程语言 (例如 'typescript', 'python')，用于智能过滤文件。如果未提供，则使用通用规则。"),
    });

    /**
     * 递归遍历目录并收集文件内容。
     * @param dirUri 要遍历的目录的 URI。
     * @param workspaceRoot 工作区的根路径，用于计算相对路径。
     * @returns 一个包含文件内容和标记的字符串数组。
     */
    private async _traverseDirectory(dirUri: vscode.Uri, workspaceRoot: string): Promise<string[]> {
        let allContents: string[] = [];
        const entries = await vscode.workspace.fs.readDirectory(dirUri);

        for (const [name, type] of entries) {
            const entryUri = vscode.Uri.joinPath(dirUri, name);
            if (type === vscode.FileType.File) {
                const fileRelativePath = path.relative(workspaceRoot, entryUri.fsPath).replace(/\\/g, '/');
                try {
                    const contentBytes = await vscode.workspace.fs.readFile(entryUri);
                    const content = Buffer.from(contentBytes).toString('utf-8');
                    allContents.push(`--- FILE: ${fileRelativePath} ---\n${content}\n--- END OF FILE ---\n`);
                } catch (fileError: any) {
                    allContents.push(`--- FILE: ${fileRelativePath} ---\n错误: 无法读取文件。 ${fileError.message}\n--- END OF FILE ---\n`);
                }
            } else if (type === vscode.FileType.Directory) {
                // 如果是目录，则递归调用
                const subDirContents = await this._traverseDirectory(entryUri, workspaceRoot);
                allContents = allContents.concat(subDirContents);
            }
        }
        return allContents;
    }

    protected async _call({ path: relativePath, language }: z.infer<typeof this.schema>): Promise<string> {
        try {
            const workspaceRoot = getWorkspaceRoot();
            const absolutePath = path.join(workspaceRoot, relativePath);
            const dirUri = vscode.Uri.file(absolutePath);

            
            // 使用新的过滤辅助函数
            const fileUris = await getFilteredFilePathsRecursive(dirUri, language);
            

            if (fileUris.length === 0) {
                return `在目录 "${relativePath}" 及其子目录中没有找到与语言 '${language}' 相关的任何文件。`;
            }
            
            const contentPromises = fileUris.map(async (uri) => {
                 const fileRelativePath = path.relative(workspaceRoot, uri.fsPath).replace(/\\/g, '/');
                 try {
                    const contentBytes = await vscode.workspace.fs.readFile(uri);
                    const content = Buffer.from(contentBytes).toString('utf-8');
                    return `--- FILE: ${fileRelativePath} ---\n${content}\n--- END OF FILE ---\n`;
                 } catch (fileError: any) {
                    return `--- FILE: ${fileRelativePath} ---\n错误: 无法读取文件。 ${fileError.message}\n--- END OF FILE ---\n`;
                 }
            });
            
            const allContents = await Promise.all(contentPromises);
            return allContents.join('\n');

        } catch (error: any) {
            return `递归获取路径 "${relativePath}" 的所有文件内容时出错: ${error.message}`;
        }
    }
}

/**
 * 一个LangChain工具，用于生成指定路径的目录树结构。
 */
export class GetDirectoryTreeTool extends StructuredTool {
    static lc_name() {
        return "GetDirectoryTreeTool";
    }

    name = "get_directory_tree";
    // 更新描述，告知 AI 此工具输出紧凑的树状结构以节省 Token
    description = "生成给定路径的目录和文件树状结构图，并以紧凑的、节省 Token 的格式展示。会自动过滤掉常见的非源码目录（如 .git, .vscode, build, target 等）。用于快速了解项目的整体文件布局。";

    schema = z.object({
        path: z.string().describe("从工作区根目录出发的相对路径。"),
    });

    private readonly ignoreDirs: Set<string> = new Set([
        '.git',
        '.vscode',
        '.idea',
        'node_modules',
        'build',
        'dist',
        'target',
        'out',
        'bin',
        '.codewiki',
        '__pycache__',
    ]);

    /**
     * 递归生成格式化的目录树。
     * @param dirUri 要生成树的目录的 URI。
     * @param prefix 用于排版的树状前缀字符串 (例如 "│   " 或 "    ")。
     * @returns 一个包含格式化后树形结构行的字符串数组。
     */
    private async _generateTree(dirUri: vscode.Uri, prefix: string): Promise<string[]> {
        let treeLines: string[] = [];
        const entries = await vscode.workspace.fs.readDirectory(dirUri);

        // 先过滤掉需要忽略的目录/文件
        const filteredEntries = entries.filter(([name, _]) => !this.ignoreDirs.has(name));
        const count = filteredEntries.length;

        for (let i = 0; i < count; i++) {
            const [name, type] = filteredEntries[i];
            const isLast = i === count - 1; // 判断是否是当前目录的最后一个条目

            // 根据是否为最后一个条目，选择不同的连接符
            const connector = isLast ? '└── ' : '├── ';
            treeLines.push(`${prefix}${connector}${name}`);

            if (type === vscode.FileType.Directory) {
                // 为下一层递归计算新的前缀
                // 如果当前是最后一个，下一层的前缀使用空格；否则使用竖线连接
                const newPrefix = prefix + (isLast ? '    ' : '│   ');
                const subTreeLines = await this._generateTree(vscode.Uri.joinPath(dirUri, name), newPrefix);
                treeLines = treeLines.concat(subTreeLines);
            }
        }
        return treeLines;
    }

    protected async _call({ path: relativePath }: z.infer<typeof this.schema>): Promise<string> {
        try {
            const workspaceRoot = getWorkspaceRoot();
            if (!relativePath || relativePath === '/' || relativePath === '\\') {
                relativePath = '.';
            }
            const absolutePath = path.join(workspaceRoot, relativePath);
            const dirUri = vscode.Uri.file(absolutePath);

            try {
                const stat = await vscode.workspace.fs.stat(dirUri);
                if (stat.type !== vscode.FileType.Directory) {
                    return `错误：路径 "${relativePath}" 不是一个目录。`;
                }
            } catch (e) {
                return `错误：路径 "${relativePath}" 不存在或无法访问。`;
            }

            const displayRoot = relativePath === '.' ? '.' : `./${relativePath.replace(/\\/g, '/')}`;

            let treeLines = [displayRoot];
            // 初始调用时，前缀为空字符串 ""
            const subTree = await this._generateTree(dirUri, "");
            treeLines = treeLines.concat(subTree);

            if (treeLines.length === 1) {
                return `${displayRoot} (目录为空或所有内容均被过滤)`;
            }

            return treeLines.join('\n');
        } catch (error: any) {
            return `生成路径 "${relativePath}" 的目录树时出错: ${error.message}`;
        }
    }
}


--------------------------------------------------------------------------------

--- file_path: extension/tools/llmTools.ts ---
// src/extension/tools/llmTools.ts (完整文件)

import { z } from 'zod';
import { StructuredTool } from '@langchain/core/tools';
import { BaseLanguageModel } from '@langchain/core/language_models/base';
import { ChatPromptTemplate } from '@langchain/core/prompts';
import { StringOutputParser } from '@langchain/core/output_parsers';
import { LLMService } from '../services/LLMService'; // 导入 LLMService

// 这是 FileSelectorLLMTool 内部使用的 Prompt 模板
const SELECTION_PROMPT = `You are an expert software engineer assistant. Your task is to analyze a list of file summaries and select the most relevant files based on a user's task description.

Analyze the following file summaries:
---
{file_summaries}
---

The user's task is: "{task_description}"

Based on this, which files are the most critical for understanding and completing the task?

Please provide your answer as a clean, comma-separated list of file paths. Do NOT include any other text, explanations, or formatting.

Example response:
src/common/types.ts,src/extension/LLMService.ts,src/webview/views/ChatView.ts
`;

/**
 * 一个内部类，代表了 LLM-as-a-Tool 的具体实现。
 * 我们不直接导出它，而是通过工厂函数创建。
 */
class FileSelectorLLMTool extends StructuredTool {
    static lc_name() {
        return "FileSelectorLLMTool";
    }

    name = "file_selector_llm_tool";
    
    description = "分析文件摘要列表和任务描述，以智能地选择最相关的文件。输出是一个包含文件路径的数组。";
    
    
    // 该工具的输入 schema
    schema = z.object({
        file_summaries: z.string().describe("一个包含所有文件摘要的单一字符串，每个摘要由标记分隔。"),
        task_description: z.string().describe("用于指导文件选择的目标或任务的描述。"),
    });

    // 持有传入的 LLM 实例
    private llm: BaseLanguageModel;
    private llmService: LLMService; // 新增

    constructor(llm: BaseLanguageModel, llmService: LLMService) { // 修改构造函数
        super(); // 调用父类构造函数
        this.llm = llm;
        this.llmService = llmService; // 存储 LLMService 实例
    }

    protected async _call({ file_summaries, task_description }: z.infer<typeof this.schema>): Promise<string> {
        try {
            // 1. 构建专门用于文件筛选的 Prompt
            const selectionPrompt = ChatPromptTemplate.fromTemplate(SELECTION_PROMPT);

            // 2. 构建一个临时的、用于该工具内部的 LangChain "子链"
            //    它接收格式化的 prompt，调用 LLM，然后解析出字符串结果。
            const selectionChain = selectionPrompt
                .pipe(this.llm)
                .pipe(new StringOutputParser());

            // 3. 调用子链来执行 LLM 推理
            console.log("Scheduling file_selector_llm_tool with task:", task_description);
            const llmResult = await this.llmService.scheduleLlmCall(() => 
                selectionChain.invoke({
                    file_summaries,
                    task_description
                })
            );

            // 4. 解析 LLM 返回的结果
            //    LLM 可能返回一些额外的空格或换行符，我们进行清理。
            //    我们期望的结果是 "path/a.ts, path/b.ts, ..."
            const cleanedResult = llmResult.replace(/```/g, '').trim(); // 移除代码块标记和多余空格
            const filePaths = cleanedResult.split(',')
                .map(p => p.trim())
                .filter(p => p.length > 0 && p.includes('/')); // 过滤掉空字符串和无效条目

            if (filePaths.length === 0) {
                console.warn("File selector LLM did not return any valid file paths.");
                return "[]"; // 返回一个表示空数组的JSON字符串
            }
            
            // 5. 将结果（一个字符串数组）序列化为 JSON 字符串返回。
            //    这是因为 LangChain 工具的标准输出是 string。
            //    我们的自定义 Agent Executor (将在下一阶段实现) 将负责解析这个JSON。
            return JSON.stringify(filePaths);

        } catch (error: any) {
            console.error("Error in FileSelectorLLMTool:", error);
            return `在文件选择LLM调用期间出错: ${error.message}`;
        }
    }
}

/**
 * 工厂函数，用于创建和配置 FileSelectorLLMTool。
 * @param llm - 一个配置好的、可用于调用的 BaseLanguageModel 实例。
 * @param llmService - 用于调度LLM调用的服务实例。
 * @returns {StructuredTool} 一个配置好的、可直接使用的工具实例。
 */
export function createFileSelectorLLMTool(llm: BaseLanguageModel, llmService: LLMService): StructuredTool {
    return new FileSelectorLLMTool(llm, llmService);
}

--------------------------------------------------------------------------------

--- file_path: test/suite/index.ts ---


--------------------------------------------------------------------------------

--- file_path: webview/components/AgentRunBlock.ts ---
// --- file_path: webview/components/AgentRunBlock.ts ---

import { AgentPlan, AgentResult, StepExecution, StepUpdate, StreamChunk, AgentPlanStep, StepResult as CommonStepResultType, AgentRunRecord, SavedStepState } from '../../common/types'; 
import { marked } from 'marked';
import { vscode } from '../vscode';

type AgentStatus = 'planning' | 'validating' | 'executing' | 'completed' | 'failed' | 'cancelled';

interface ExecutionStepState extends StepExecution {
    logs: { type: 'input' | 'output' | 'llm-request', data: any, metadata?: Record<string, any> }[];
    isCollapsed: boolean;
    streamedContent: string;
    error?: string;
}

// 类型守卫，用于区分 AgentPlan 和 AgentRunRecord
function isAgentRunRecord(data: AgentPlan | AgentRunRecord): data is AgentRunRecord {
    return (data as AgentRunRecord).result !== undefined;
}

export class AgentRunBlock {
    private element: HTMLElement;
    private plan: AgentPlan;
    private onExecute: ((params: Record<string, any>) => void) | null = null; // 可为 null
    private status: AgentStatus = 'planning';
    private executionState: Map<string, ExecutionStepState> = new Map();
    private agentResult: AgentResult | null = null;
    private animatedStepIds: Set<string> = new Set();
    private stepElementsCache: Map<string, HTMLElement> = new Map();
    private executionStepsOuterContainer: HTMLElement | null = null; // Cache this
    private runId: string | null = null;
    private onCancel?: () => void; // 新增 onCancel 属性

    constructor(
        container: HTMLElement,
        // 构造函数现在可以接收一个 AgentPlan（用于新的运行）或一个 AgentRunRecord（用于从历史恢复）
        planOrRecord: AgentPlan | AgentRunRecord,
        onExecute?: (params: Record<string, any>) => void,
        onCancel?: () => void // 在构造函数中接收回调
    ) {
        this.element = container;
        this.element.className = 'agent-run-block';
        
        if (isAgentRunRecord(planOrRecord)) {
            // 从历史记录中恢复
            const record = planOrRecord;
            this.plan = record.plan;
            this.agentResult = record.result;
            this.status = record.result.status as AgentStatus;
            this.runId = record.result.runId;
            // 将保存的普通对象转换回 Map
            this.executionState = new Map(Object.entries(record.executionState).map(([key, value]) => {
                // 确保每个步骤状态都符合 ExecutionStepState 接口
                const fullStepState: ExecutionStepState = {
                    runId: record.result.runId, // 从顶层结果中恢复 runId
                    stepName: value.stepName,
                    taskId: value.taskId,
                    status: value.status,
                    logs: value.logs || [],
                    isCollapsed: true, // 从历史记录加载时默认折叠
                    streamedContent: value.streamedContent || '',
                    error: value.error,
                };
                return [key, fullStepState];
            }));
            this.onExecute = null; // 历史记录是只读的
            this.onCancel = undefined; // 历史记录没有取消功能
        } else {
            // 开始一个新的运行
            this.plan = planOrRecord;
            this.onExecute = onExecute || null;
            this.onCancel = onCancel; // 保存回调
            this.status = 'planning';
        }

        this.render(); // Initial render
        this.setupEventListeners();
    }
    
    /**
     * 新增：获取组件当前的可序列化状态，用于保存到历史记录。
     */
    public getSerializableState(): AgentRunRecord | null {
        if (!this.agentResult) {
            console.error("Cannot serialize state: Agent has not completed.");
            return null;
        }

        
        // 将 Map 转换为普通对象以便 JSON 序列化
        const serializableExecutionState: Record<string, SavedStepState> = {};
        this.executionState.forEach((state, key) => {
            // 从 state 中只选择要保存的字段
            serializableExecutionState[key] = {
                stepName: state.stepName,
                taskId: state.taskId,
                status: state.status,
                logs: state.logs,
                streamedContent: state.streamedContent,
                error: state.error,
            };
        });
        

        return {
            plan: this.plan,
            executionState: serializableExecutionState,
            result: this.agentResult
        };
    }

    // Called by ChatView when agent:stepStart or agent:stepEnd is received
    public updateStepExecutionStatus(stepEventData: StepExecution | CommonStepResultType) {
        if (!this.runId) {
            this.runId = stepEventData.runId;
        }
        const stepKey = stepEventData.taskId || stepEventData.stepName;
        let stepState = this.executionState.get(stepKey);
        const isNewStepInState = !stepState;

        if (isNewStepInState) {
            // This is a StepExecution event for a new step/task
            stepState = { ...(stepEventData as StepExecution), logs: [], isCollapsed: false, streamedContent: '' };
        } else {
            // This is an update for an existing step (either StepExecution or StepResult)
            stepState!.status = stepEventData.status;
        }
        
        if (stepEventData.status === 'failed' && 'error' in stepEventData && stepEventData.error) {
            stepState!.error = stepEventData.error;
        }
        this.executionState.set(stepKey, stepState!);

        const isSubStep = stepState!.stepName.startsWith("分析模块:"); // Heuristic for sub-steps

        if (isNewStepInState) {
            // New step appearing in the execution flow
            if (isSubStep) {
                // Try to update parent's sub-step container directly
                const parentPlanStep = this.plan.steps.find(p => p.name === "分析: 并行处理模块"); // More robust way to find parent needed
                if (parentPlanStep) {
                    const parentStepState = Array.from(this.executionState.values()).find(
                        s => s.stepName === parentPlanStep.name && s.runId === stepState!.runId
                    );
                    if (parentStepState) {
                        const parentKey = parentStepState.taskId || parentStepState.stepName;
                        const parentElement = this.stepElementsCache.get(parentKey);
                        if (parentElement) {
                            const subStepsContainer = parentElement.querySelector('.sub-steps-container') as HTMLElement;
                            if (subStepsContainer) {
                                this.updateSubStepsContainerRendering(subStepsContainer, parentStepState);
                                return; // Handled locally
                            }
                        }
                    }
                }
            }
            // Fallback to full render if sub-step parent not found/rendered, or if it's a new top-level step
            this.render();
        } else {
            // Status update for an existing, rendered step
            const stepElement = this.stepElementsCache.get(stepKey);
            if (stepElement) {
                this.updateElementHeaderAndError(stepElement, stepState!);
            }
        }
    }


    public addStepLog(update: StepUpdate) {
        const stepKey = update.taskId ||
            (this.plan.steps.find(s => s.name === update.metadata?.stepNameHint)?.name) ||
            'global_logs';

        const stepState = this.executionState.get(stepKey) || Array.from(this.executionState.values()).find(s => s.stepName === stepKey);

        if (stepState && (update.type === 'input' || update.type === 'output' || update.type === 'llm-request')) {
            stepState.logs.push({ type: update.type, data: update.data, metadata: update.metadata });

            const stepElement = this.stepElementsCache.get(stepKey);
            if (stepElement) {
                const contentWrapper = stepElement.querySelector(stepElement.classList.contains('sub-step') ? '.sub-step-content-wrapper' : '.step-content-wrapper') as HTMLElement;
                if (contentWrapper) {
                    const logsContainer = contentWrapper.querySelector('.logs-wrapper') as HTMLElement;
                    if (logsContainer) {
                        const newLogElement = this.renderLogItem({ type: update.type, data: update.data, metadata: update.metadata });
                        logsContainer.appendChild(newLogElement);
                        // Potentially scroll the logs container if needed
                        logsContainer.scrollTop = logsContainer.scrollHeight;
                    } else {
                        // Logs container doesn't exist, might need to re-render step internals for this step
                        // This case should be rare if renderStepInternals always creates it.
                        contentWrapper.innerHTML = this.renderStepInternals(stepState);
                    }
                }
            }
        }
    }

    public appendStreamChunk(chunk: StreamChunk) {
        const stepKey = chunk.taskId;
        if (!stepKey) {
            console.warn('AgentRunBlock: StreamChunk received without taskId.', chunk);
            return;
        }

        const stepState = this.executionState.get(stepKey);
        if (stepState) {
            stepState.streamedContent += chunk.content;

            const stepElement = this.stepElementsCache.get(stepKey);
            if (stepElement) {
                const contentWrapper = stepElement.querySelector(stepElement.classList.contains('sub-step') ? '.sub-step-content-wrapper' : '.step-content-wrapper') as HTMLElement;
                if (contentWrapper) {
                    let streamWrapper = contentWrapper.querySelector('.stream-wrapper') as HTMLElement;
                    if (!streamWrapper) {
                        // If stream wrapper doesn't exist, create it (e.g. by re-rendering internals for this step)
                        // This is a fallback; ideally, renderStepInternals would have set it up.
                        // A simpler approach for now is to just re-render the step's internals fully if the stream wrapper isn't found.
                        // However, a more robust way is to ensure renderStepInternals always creates these wrappers.
                        contentWrapper.innerHTML = this.renderStepInternals(stepState); //This will create the stream-wrapper
                        streamWrapper = contentWrapper.querySelector('.stream-wrapper') as HTMLElement; // Re-query
                    }
                    if (streamWrapper) {
                        streamWrapper.innerHTML = this.renderStreamedContent(stepState.streamedContent); // renderStreamedContent returns HTML for the content *inside* the wrapper
                    }
                }
            }
        } else {
            console.warn(`AgentRunBlock: Could not find step state for taskId '${stepKey}' to append stream chunk.`);
        }
    }

    public setAgentResult(result: AgentResult) {
        this.status = result.status;
        this.agentResult = result;
        // 如果Agent被取消或失败，遍历所有正在执行的步骤，并将它们标记为失败。
        if (result.status === 'cancelled' || result.status === 'failed') {
            this.executionState.forEach(stepState => {
                if (stepState.status === 'running' || stepState.status === 'waiting') {
                    stepState.status = 'failed'; // 将状态强制更新为 'failed'
                    // 可以添加一条错误信息，解释为什么这个步骤失败了
                    stepState.error = 'Execution was cancelled or failed.'; 
                }
            });
        }
        this.render();
    }

    private render() {
        // 如果 onExecute 为 null，说明是从历史记录中恢复的，始终为只读状态
        const isPlanningReadOnly = (this.status !== 'planning' && this.status !== 'validating') || this.onExecute === null;

        const planningViewContainer = this.element.querySelector('.planning-view-container');
        if (!planningViewContainer) {
            this.element.innerHTML = `<div class="planning-view-container"></div><div class="executing-view-container"></div>`;
        }
        const planningContainer = this.element.querySelector('.planning-view-container') as HTMLElement;
        planningContainer.innerHTML = this.renderPlanningView(isPlanningReadOnly);

        const executingViewContainer = this.element.querySelector('.executing-view-container') as HTMLElement;
        if (isPlanningReadOnly) {
            if (!executingViewContainer.classList.contains('active')) {
                this.animatedStepIds.clear();
                // Do NOT clear stepElementsCache here if we want to preserve elements across minor re-renders
                // this.stepElementsCache.clear(); 
                executingViewContainer.classList.add('active');
            }
            this.renderExecutingViewContents(executingViewContainer);
        } else {
            executingViewContainer.classList.remove('active');
            executingViewContainer.innerHTML = '';
        }
        this.postRender();
    }

    private renderExecutingViewContents(container: HTMLElement) {
        const statusClassMapping: Record<AgentStatus, string> = { /* ... */ planning: 'planning', validating: 'planning', executing: 'executing', completed: 'completed', failed: 'failed', cancelled: 'failed'};
        const statusClass = statusClassMapping[this.status] || 'executing';
        const statusText = this.status.charAt(0).toUpperCase() + this.status.slice(1);

        if (!this.executionStepsOuterContainer || !container.contains(this.executionStepsOuterContainer)) {
            container.innerHTML = `
            <div class="executing-view">
                <div class="agent-header">
                    <h4>执行过程</h4>
                    <span class="badge ${statusClass}">${statusText}</span>
                </div>
                <div class="execution-steps-outer-container"></div>
                <div class="final-result-container"></div>
            </div>`;
            this.executionStepsOuterContainer = container.querySelector('.execution-steps-outer-container') as HTMLElement;
        } else {
            const badge = container.querySelector('.executing-view .agent-header .badge') as HTMLElement;
            if (badge) {
                badge.className = `badge ${statusClass}`;
                badge.textContent = statusText;
            }
        }
        
        // Ensure executionStepsOuterContainer is defined
        if (!this.executionStepsOuterContainer) {
             this.executionStepsOuterContainer = container.querySelector('.execution-steps-outer-container') as HTMLElement;
             if (!this.executionStepsOuterContainer) return; // Should not happen
        }

        // 清理旧的DOM元素，并根据当前状态重新渲染
        this.executionStepsOuterContainer.innerHTML = '';
        this.stepElementsCache.clear();

        this.plan.steps.forEach((planStep, index) => {
            // 从 state 中找到所有与 planStep 匹配的顶级执行步骤
            // 这很重要，因为从历史恢复时，executionState 是预先填充好的
            const executionStepState = Array.from(this.executionState.values())
                .find(s => s.stepName === planStep.name && !s.stepName.startsWith("分析模块:"));

            if (!executionStepState) {
                // 如果是实时执行，可能会暂时没有状态，直接跳过
                // 如果是从历史恢复，这里不应该发生
                return;
            }

            const stepMapKey = executionStepState.taskId || executionStepState.stepName;
            let stepElement = this.stepElementsCache.get(stepMapKey);

            if (!stepElement) {
                let animationClass = '';
                 // 从历史恢复时，不应用动画
                if (!isAgentRunRecord(this.plan) && !this.animatedStepIds.has(stepMapKey)) {
                    animationClass = 'needs-animation';
                    this.animatedStepIds.add(stepMapKey);
                }
                const isParallel = planStep.name === "分析: 并行处理模块"; // Heuristic
                const stepHtml = isParallel
                    ? this.getParallelAnalysisStepHtml(planStep, index, executionStepState, animationClass)
                    : this.getExecutionStepHtml(executionStepState, planStep, index, animationClass);

                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = stepHtml.trim();
                stepElement = tempDiv.firstChild as HTMLElement;

                if (stepElement) {
                    this.executionStepsOuterContainer!.appendChild(stepElement);
                    this.stepElementsCache.set(stepMapKey, stepElement);
                }
            } else {
                 // 理论上，因为我们清理了 outer container，这个分支在当前逻辑下不会被走到
                this.updateStepElement(stepElement, executionStepState, planStep, planStep.name === "分析: 并行处理模块", index);
            }
        });

        const finalResultContainer = container.querySelector('.final-result-container') as HTMLElement;
        if (this.agentResult) {
            this.renderOrUpdateFinalResult(finalResultContainer);
        } else {
            finalResultContainer.innerHTML = '';
        }
    }

    private updateStepElement(element: HTMLElement, stepState: ExecutionStepState, planStep: AgentPlanStep, isParallel: boolean, index: number) {
        this.updateElementHeaderAndError(element, stepState); // Update header and error

        const contentWrapper = element.querySelector('.step-content-wrapper') as HTMLElement;
        if (contentWrapper) {
            contentWrapper.style.maxHeight = stepState.isCollapsed ? '0' : (isParallel ? '5000px' : '2000px');
            contentWrapper.style.padding = stepState.isCollapsed ? '0 15px' : '10px 15px';

            if (isParallel) {
                const subStepsContainer = contentWrapper.querySelector('.sub-steps-container') as HTMLElement;
                if (subStepsContainer) {
                    this.updateSubStepsContainerRendering(subStepsContainer, stepState);
                }
            } else {
                // Only set innerHTML for content if the wrapper is empty (initial population)
                // OR if there are logs/stream/error to display and it wasn't populated before.
                // This prevents re-rendering content if it's managed by targeted updates.
                const needsContentPopulation = !contentWrapper.querySelector('.logs-wrapper') && !contentWrapper.querySelector('.stream-wrapper');
                if (needsContentPopulation && (stepState.logs.length > 0 || stepState.streamedContent || stepState.error)) {
                    contentWrapper.innerHTML = this.renderStepInternals(stepState);
                } else if (contentWrapper.children.length === 0 && (stepState.logs.length > 0 || stepState.streamedContent || stepState.error)) {
                    // Fallback if specific wrappers are not used and content is empty
                    contentWrapper.innerHTML = this.renderStepInternals(stepState);
                }
                // If content exists, assume addStepLog/appendStreamChunk will handle it.
            }
        }
    }
    
    // New helper to specifically update header and error parts of a step element
    private updateElementHeaderAndError(element: HTMLElement, stepState: ExecutionStepState) {
        const baseClass = element.classList.contains('sub-step') ? 'sub-step' : 'execution-step';
        element.className = `${baseClass} ${stepState.status}`; // Animation might be re-added if logic desires

        const statusIconEl = element.querySelector('.status-icon');
        if (statusIconEl) statusIconEl.innerHTML = this.getIconForStatus(stepState.status);
        
        const stepStatusEl = element.querySelector('.step-status'); // For top-level steps
        if (stepStatusEl) stepStatusEl.textContent = stepState.status;

        // Update error message
        let errorWrapper = element.querySelector('.step-error-wrapper') as HTMLElement;
        if (stepState.error) {
            if (!errorWrapper) {
                // Find content wrapper to append error to
                const contentWrapper = element.querySelector(baseClass === 'sub-step' ? '.sub-step-content-wrapper' : '.step-content-wrapper') as HTMLElement;
                if (contentWrapper) {
                    errorWrapper = document.createElement('div');
                    errorWrapper.className = 'step-error-wrapper';
                    contentWrapper.appendChild(errorWrapper); // Append, not replace all content
                }
            }
            if (errorWrapper) errorWrapper.innerHTML = `<div class="step-error">${stepState.error}</div>`;
        } else {
            if (errorWrapper) errorWrapper.innerHTML = ''; // Clear error
        }
    }


    private updateSubStepsContainerRendering(container: HTMLElement, parentStepState: ExecutionStepState) {
        const subStepStates = Array.from(this.executionState.values()).filter(s =>
            s.stepName.startsWith("分析模块:") && s.runId === parentStepState.runId
        );

        const existingSubStepElements = new Map<string, HTMLElement>();
        container.querySelectorAll<HTMLElement>('.sub-step').forEach(el => {
            if (el.dataset.taskId) existingSubStepElements.set(el.dataset.taskId, el);
        });
        
        let newHtmlForSubSteps = '';
        if (subStepStates.length > 0) {
            newHtmlForSubSteps = subStepStates.map(subState => {
                 const subStepKey = subState.taskId!;
                 let animationClass = '';
                 // Check if this sub-step was already animated or if it's new to this render pass
                 if (!this.animatedStepIds.has(subStepKey) && !existingSubStepElements.has(subStepKey)) {
                     animationClass = 'needs-animation';
                     // this.animatedStepIds.add(subStepKey); // Add when actually appended
                 }
                const existingElement = existingSubStepElements.get(subStepKey);
                if (existingElement) {
                     // If exists, we might want to preserve it and update, but for now, full re-render of sub-step list
                     // For more granular, we'd call updateStepElement on existingElement here.
                    // For simplicity in this pass, this method will still use innerHTML for the whole sub-steps list.
                    // A truly granular update would diff this list.
                }
                 return this.getSubStepHtml(subState, animationClass);
             }).join('');
        } else if (parentStepState.status === 'running') {
            newHtmlForSubSteps = '<div class="sub-step-placeholder">等待模块分析任务启动...</div>';
        }
        
        container.innerHTML = newHtmlForSubSteps;

        // After setting innerHTML, re-query and add new animated IDs
        container.querySelectorAll<HTMLElement>('.sub-step.needs-animation').forEach(el => {
            if (el.dataset.taskId) this.animatedStepIds.add(el.dataset.taskId);
        });
        // Also update cache for new sub-steps
        subStepStates.forEach(subState => {
            const subStepKey = subState.taskId!;
            if (!this.stepElementsCache.has(subStepKey)) {
                const newEl = container.querySelector(`.sub-step[data-task-id="${subStepKey}"]`) as HTMLElement;
                if (newEl) this.stepElementsCache.set(subStepKey, newEl);
            }
        });
    }

    private renderStepInternals(stepState: ExecutionStepState): string {
        // Ensure this method creates the distinct wrappers
        const logsHtml = stepState.logs.map(log => this.renderLogItemToString(log)).join(''); // Temporarily back to string
        let waitingPlaceholderHtml = '';
        // ... (waiting placeholder logic) ...
        const streamRendered = this.renderStreamedContent(stepState.streamedContent); // This returns HTML for *inside* the stream wrapper
        const errorHtml = stepState.error ? `<div class="step-error">${stepState.error}</div>` : '';

        return `
            <div class="logs-wrapper">${logsHtml}</div>
            ${waitingPlaceholderHtml}
            <div class="stream-wrapper">${streamRendered}</div>
            <div class="step-error-wrapper">${errorHtml}</div>
        `;
    }
    
    // New: Renders a single log item to an HTML string for renderStepInternals
    private renderLogItemToString(log: { type: string, data: any, metadata?: Record<string, any> }): string {
        // ... (logic from original renderLogItem to build HTML string for one log) ...
        let content = '';
        const logDataName = log.data && typeof log.data === 'object' && 'name' in log.data ? log.data.name : '';
        const logContent = log.data && typeof log.data === 'object' && 'content' in log.data
            ? (typeof log.data.content === 'string' ? log.data.content : JSON.stringify(log.data.content, null, 2))
            : (typeof log.data === 'string' ? log.data : JSON.stringify(log.data, null, 2));

        if (log.metadata?.type === 'file') {
            content = this.renderFileCard(log.metadata.path, logDataName);
        } else {
            content = `<pre><code>${logContent}</code></pre>`;
        }
        const iconHtml = this.getIconForLogType(log.type);
        const titleText = `${log.type.toUpperCase()}${logDataName ? ': ' + logDataName : ''}`;
        const isLargeInput = log.type === 'input' && logContent.length > 500 && logContent.includes('\n');
        const collapsedClass = isLargeInput ? 'collapsed' : '';

        return `<div class="log-item log-${log.type} ${collapsedClass}"><div class="log-header">${iconHtml}<span>${titleText}</span></div><div class="log-content-wrapper">${content}</div></div>`;
    }

    // Changed: renderLogItem now returns HTMLElement for direct DOM append
    private renderLogItem(log: { type: string, data: any, metadata?: Record<string, any> }): HTMLElement {
        let content = '';
        const logDataName = log.data && typeof log.data === 'object' && 'name' in log.data ? log.data.name : '';
        const logContentText = log.data && typeof log.data === 'object' && 'content' in log.data
            ? (typeof log.data.content === 'string' ? log.data.content : JSON.stringify(log.data.content, null, 2))
            : (typeof log.data === 'string' ? log.data : JSON.stringify(log.data, null, 2));

        if (log.metadata?.type === 'file') {
            content = this.renderFileCard(log.metadata.path, logDataName);
        } else {
            content = `<pre><code>${logContentText}</code></pre>`;
        }
        const iconHtml = this.getIconForLogType(log.type);
        const titleText = `${log.type.toUpperCase()}${logDataName ? ': ' + logDataName : ''}`;
        const isLargeInput = log.type === 'input' && logContentText.length > 500 && logContentText.includes('\n');
        const collapsedClass = isLargeInput ? 'collapsed' : '';
        
        const logItemElement = document.createElement('div');
        logItemElement.className = `log-item log-${log.type} ${collapsedClass}`;
        logItemElement.innerHTML = `<div class="log-header">${iconHtml}<span>${titleText}</span></div><div class="log-content-wrapper">${content}</div>`;
        return logItemElement;
    }


    private renderStreamedContent(content: string): string {
        // This method returns the HTML string for the *content* of the stream wrapper
        if (!content) return '';
        const htmlContent = marked.parse(content, { gfm: true, breaks: true });
        // The class 'markdown-body' should be on the wrapper if specific styling is needed
        return `<div class="markdown-body">${htmlContent}</div>`; 
    }

    // --- Other methods (getExecutionStepHtml, getParallelAnalysisStepHtml, getSubStepHtml, renderPlanningView, etc.) largely remain the same for initial HTML string generation ---
    // Make sure they call renderStepInternals when creating content.

    private getExecutionStepHtml(stepState: ExecutionStepState, planStep: { name: string }, index: number, animationClass: string): string {
        const state = stepState.status;
        const taskIdAttr = stepState.taskId ? `data-task-id="${stepState.taskId}"` : '';
        const contentWrapperStyle = stepState.isCollapsed ? 'max-height: 0px; padding: 0px 15px;' : 'max-height: 2000px; padding: 10px 15px;';
        return `
            <div class="execution-step ${state} ${animationClass}" data-step-name="${planStep.name}" ${taskIdAttr}>
                <div class="step-header">
                    <span class="status-icon">${this.getIconForStatus(state)}</span>
                    <span class="step-name"><b>Step ${index + 1}:</b> ${planStep.name}</span>
                    <span class="step-status">${state}</span>
                </div>
                <div class="step-content-wrapper" style="${contentWrapperStyle}">
                    ${this.renderStepInternals(stepState)}
                </div>
            </div>
        `;
    }

    private getParallelAnalysisStepHtml(planStep: AgentPlanStep, index: number, parentStepState: ExecutionStepState, animationClass: string): string {
        const state = parentStepState.status;
        const taskIdAttr = parentStepState.taskId ? `data-task-id="${parentStepState.taskId}"` : '';
        // Initial sub-steps rendering (likely empty or placeholder if just started)
        const subStepsHtml = this.renderSubStepsContainerInitial(parentStepState);
        const contentWrapperStyle = parentStepState.isCollapsed ? 'max-height: 0px; padding: 0px 15px;' : 'max-height: 5000px; padding: 10px 15px;';

        return `
            <div class="execution-step ${state} ${animationClass}" data-step-name="${planStep.name}" ${taskIdAttr}>
                <div class="step-header">
                    <span class="status-icon">${this.getIconForStatus(state)}</span>
                    <span class="step-name"><b>Step ${index + 1}:</b> ${planStep.name}</span>
                    <span class="step-status">${state}</span>
                </div>
                <div class="step-content-wrapper" style="${contentWrapperStyle}">
                     <div class="sub-steps-container">
                        ${subStepsHtml}
                    </div>
                    ${this.renderStepInternals(parentStepState)} 
                </div>
            </div>
        `;
    }
    
    // Renders the initial HTML for the sub-steps container (used during creation of parent step)
    private renderSubStepsContainerInitial(parentStepState: ExecutionStepState): string {
        const subSteps = Array.from(this.executionState.values()).filter(s =>
            s.stepName.startsWith("分析模块:") && s.runId === parentStepState.runId
        );
        if (subSteps.length > 0) {
            return subSteps.map(sub => {
                const subStepMapKey = sub.taskId || sub.stepName;
                let subAnimationClass = ''; // No animation on initial parent render for existing sub-steps
                return this.getSubStepHtml(sub, subAnimationClass);
            }).join('');
        } else if (parentStepState.status === 'running' || parentStepState.status === 'waiting') {
            return '<div class="sub-step-placeholder">等待模块分析任务启动...</div>';
        }
        return '';
    }


    private getSubStepHtml(subStep: ExecutionStepState, animationClass: string): string {
        const contentWrapperStyle = subStep.isCollapsed ? 'max-height: 0px; padding: 0px 10px;' : 'max-height: 2000px; padding: 10px;';
        return `
            <div class="sub-step ${subStep.status} ${animationClass}" data-task-id="${subStep.taskId}">
                 <div class="sub-step-header">
                    <span class="status-icon">${this.getIconForStatus(subStep.status)}</span>
                    <span class="step-name">${subStep.stepName}</span>
                </div>
                <div class="sub-step-content-wrapper" style="${contentWrapperStyle}">
                    ${this.renderStepInternals(subStep)}
                </div>
            </div>
        `;
    }
    
    // renderPlanningView, renderStepCard, renderParameterInput, getIconForStatus, renderFinalResult, setupEventListeners, postRender remain the same
    private renderPlanningView(isReadOnly: boolean): string {
        const badgeClass = this.status === 'planning' || this.status === 'validating' ? 'planning' : (this.status === 'executing' ? 'executing' : 'completed');
        const badgeText = this.status === 'planning' || this.status === 'validating' ? '待执行' : (this.status === 'executing' ? '运行中' : '规划已锁定');

        const renderAgentActions = (status: AgentStatus) => {
            // 如果 onExecute 为 null (从历史恢复)，则不显示任何操作按钮
            if (this.onExecute === null) {
                return '';
            }
            if (status === 'executing') {
                return `<button class="stop-btn secondary"><i class="codicon codicon-stop-circle"></i> 停止执行</button>`;
            }
            if (status === 'planning' || status === 'validating') {
                return `
                    <button class="execute-btn"><i class="codicon codicon-play"></i> 开始执行</button>
                    <button class="cancel-btn secondary"><i class="codicon codicon-close"></i> 取消</button>
                `;
            }
            return '';
        };

        return `
            <div class="planning-view ${isReadOnly ? 'read-only' : ''}">
                <div class="agent-header">
                    <h4>${this.plan.agentName}</h4>
                    <span class="badge ${badgeClass}">${badgeText}</span>
                </div>
                <div class="agent-plan-steps">
                    <h5>执行计划</h5>
                    ${this.plan.steps.map(step => this.renderStepCard(step)).join('')}
                </div>
                ${this.plan.parameters.length > 0 ? `
                    <div class="agent-parameters">
                        <h5>参数</h5>
                        ${this.plan.parameters.map(param => this.renderParameterInput(param, isReadOnly)).join('')}
                    </div>
                ` : ''}
                <div class="agent-actions" style="display: ${this.status === 'completed' || this.status === 'failed' || this.status === 'cancelled' ? 'none' : 'flex'};">
                    ${renderAgentActions(this.status)}
                </div>
            </div>
        `;
    }
    private renderStepCard(step: AgentPlanStep): string {
        return `
            <div class="step-card">
                <div class="step-card-name">${step.name}</div>
                <div class="step-card-desc">${step.description}</div>
                ${step.promptFiles && step.promptFiles.length > 0 ? `
                    <div class="prompt-files-container">
                        ${step.promptFiles.map(file => this.renderFileCard(file)).join('')}
                    </div>
                ` : ''}
            </div>
        `;
    }
    private renderParameterInput(param: { name: string, description: string, type: string, value?: any, isValid?: boolean, error?: string }, isReadOnly: boolean): string {
        const isInvalid = param.error ? 'invalid' : '';
        const value = param.value || '';
        return `
            <div class="parameter-item">
                <label for="param-${param.name}">${param.name}</label>
                <div class="parameter-description">${param.description}</div>
                <input type="text" id="param-${param.name}" name="${param.name}" class="${isInvalid}" value="${value}" ${isReadOnly ? 'disabled' : ''}>
                ${param.error ? `<div class="error-text">${param.error}</div>` : ''}
            </div>
        `;
    }
    private renderFileCard(filePath: string, displayName?: string): string {
        const fileName = displayName || filePath.split(/[\\/]/).pop() || 'file';
        let icon = 'codicon-file';
        if (fileName.endsWith('.md')) icon = 'codicon-markdown';
        if (fileName.endsWith('.json')) icon = 'codicon-json';
        if (fileName.endsWith('.yml') || fileName.endsWith('.yaml')) icon = 'codicon-symbol-keyword';
        if (fileName.endsWith('.txt')) icon = 'codicon-file-code';
        return `<div class="file-card" data-file-path="${filePath}" title="${filePath}"><i class="codicon ${icon}"></i><span>${fileName}</span></div>`;
    }
    private getIconForLogType(logType: string): string {
        switch (logType) {
            case 'input': return '<i class="codicon codicon-arrow-right"></i>';
            case 'output': return '<i class="codicon codicon-arrow-left"></i>';
            case 'llm-request': return '<i class="codicon codicon-comment"></i>';
            case 'llm-stream': return '<i class="codicon codicon-wand"></i>';
            default: return '';
        }
    }
    private getIconForStatus(status: string): string {
        switch (status) {
            case 'running': return '<i class="codicon codicon-loading codicon-spin"></i>';
            case 'completed': return '<i class="codicon codicon-check"></i>';
            case 'failed': return '<i class="codicon codicon-error"></i>';
            case 'waiting': return '<i class="codicon codicon-more"></i>';
            default: return '';
        }
    }
    private renderOrUpdateFinalResult(container: HTMLElement) { // Was renderFinalResult()
        if (!this.agentResult) {
            container.innerHTML = '';
            this.stepElementsCache.delete('__agent_final_result__');
            return;
        }

        let resultElement = this.stepElementsCache.get('__agent_final_result__');
        const resultKey = '__agent_final_result__';
        let animationClass = '';

        if (!resultElement) {
            // 从历史恢复时，不应用动画
            if (!isAgentRunRecord(this.plan) && !this.animatedStepIds.has(resultKey)) {
                animationClass = 'needs-animation';
                this.animatedStepIds.add(resultKey);
            }
            const resultHtml = this.getFinalResultHtml(animationClass); 
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = resultHtml.trim();
            resultElement = tempDiv.firstChild as HTMLElement;
            if (resultElement) {
                container.innerHTML = ''; 
                container.appendChild(resultElement);
                this.stepElementsCache.set(resultKey, resultElement);
            }
        } else {
            resultElement.className = `agent-final-result ${this.agentResult.status} ${animationClass}`;
            const iconEl = resultElement.querySelector('.result-header .codicon') as HTMLElement;
            const titleEl = resultElement.querySelector('.result-header span') as HTMLElement;
            const contentEl = resultElement.querySelector('.result-content') as HTMLElement;

            const isCompleted = this.agentResult.status === 'completed';
            if (iconEl) iconEl.className = `codicon ${isCompleted ? 'codicon-check-all' : 'codicon-error'}`;
            if (titleEl) titleEl.textContent = isCompleted ? 'Agent Execution Completed' : 'Agent Execution Failed';

            if (contentEl) {
                let newContentHtml = '';
                 if (isCompleted && this.agentResult.stats) {
                    const stats = this.agentResult.stats;
                    newContentHtml = `
                        <div class="result-stats">
                            <div class="stat-item"><i class="codicon codicon-clock"></i><span>耗时</span><strong>${stats.duration}</strong></div>
                            <div class="stat-item"><i class="codicon codicon-symbol-event"></i><span>总 Tokens</span><strong>${stats.totalTokens.toLocaleString()}</strong></div>
                            <div class="stat-item"><i class="codicon codicon-arrow-right"></i><span>输入 Tokens</span><strong>${stats.promptTokens.toLocaleString()}</strong></div>
                            <div class="stat-item"><i class="codicon codicon-arrow-left"></i><span>输出 Tokens</span><strong>${stats.completionTokens.toLocaleString()}</strong></div>
                        </div>`;
                } else if (!isCompleted) {
                    newContentHtml = `<div class="error-text">${this.agentResult.error || '未知错误'}</div>`;
                }
                // Only update if different to avoid flicker
                if (contentEl.innerHTML !== newContentHtml) {
                     contentEl.innerHTML = newContentHtml;
                }
            }
        }
    }
    private getFinalResultHtml(animationClass: string): string {
        if (!this.agentResult) return '';
        const resultClass = this.agentResult.status;
        const icon = resultClass === 'completed' ? '<i class="codicon codicon-check-all"></i>' : '<i class="codicon codicon-error"></i>';
        const title = resultClass === 'completed' ? 'Agent Execution Completed' : 'Agent Execution Failed';
        let contentHtml = '';
        if (resultClass === 'completed' && this.agentResult.stats) {
            const stats = this.agentResult.stats;
            contentHtml = `
                <div class="result-stats">
                    <div class="stat-item"><i class="codicon codicon-clock"></i><span>耗时</span><strong>${stats.duration}</strong></div>
                    <div class="stat-item"><i class="codicon codicon-symbol-event"></i><span>总 Tokens</span><strong>${stats.totalTokens.toLocaleString()}</strong></div>
                    <div class="stat-item"><i class="codicon codicon-arrow-right"></i><span>输入 Tokens</span><strong>${stats.promptTokens.toLocaleString()}</strong></div>
                    <div class="stat-item"><i class="codicon codicon-arrow-left"></i><span>输出 Tokens</span><strong>${stats.completionTokens.toLocaleString()}</strong></div>
                </div>`;
        } else if (resultClass !== 'completed') {
            contentHtml = `<div class="error-text">${this.agentResult.error || '未知错误'}</div>`;
        }
        return `<div class="agent-final-result ${resultClass} ${animationClass}"><div class="result-header">${icon}<span>${title}</span></div><div class="result-content">${contentHtml}</div></div>`;
    }
    private setupEventListeners() {
        this.element.addEventListener('click', (e) => { 
            const target = e.target as HTMLElement;
            const logHeader = target.closest('.log-header');
            if (logHeader) {
                const logItem = logHeader.closest('.log-item');
                if (logItem) {
                    e.stopPropagation();
                    logItem.classList.toggle('collapsed');
                    return; 
                }
            }
            // Event listener for agent actions (start, stop, cancel)
            const actionsContainer = target.closest('.agent-actions');
            if (actionsContainer) {
                const executeBtn = target.closest('.execute-btn');
                const cancelBtn = target.closest('.cancel-btn');
                const stopBtn = target.closest('.stop-btn');

                if (executeBtn) {
                    if (!this.onExecute) return; // 从历史恢复时，onExecute 为 null
                    const params: Record<string, any> = {};
                    let allValid = true;
                    this.plan.parameters.forEach(p => {
                        const input = this.element.querySelector(`#param-${p.name}`) as HTMLInputElement;
                        if (input) {
                            const value = input.value.trim();
                            if (!value && p.type === 'path') { p.error = 'This field is required.'; allValid = false; }
                            else { p.error = undefined; params[p.name] = value; p.value = value; }
                        }
                    });
                    this.status = allValid ? 'executing' : 'validating';
                    this.render(); 
                    if (allValid) this.onExecute(params); 
                    return;
                }
                if (cancelBtn) {
                    // 如果 onCancel 回调存在，就调用它
                    if (this.onCancel) {
                        this.onCancel();
                    } else {
                        // 否则，作为后备，只移除元素（不应该发生）
                        this.element.remove();
                    }
                    return;
                }
                if (stopBtn) {
                    if (this.runId) {
                        vscode.postMessage({ command: 'agent:cancel', payload: { runId: this.runId } });
                    } else {
                        console.warn('Stop button clicked, but no runId is available.');
                        this.element.remove();
                    }
                    return;
                }
            }
            const fileCard = target.closest('.file-card');
            if (fileCard) {
                e.stopPropagation(); 
                const filePath = (fileCard as HTMLElement).dataset.filePath;
                if (filePath) {
                    vscode.postMessage({ command: 'viewFile', payload: { path: filePath } });
                }
                return;
            }
            const stepHeader = target.closest('.step-header, .sub-step-header');
            if (stepHeader) {
                e.stopPropagation();
                const stepElement = stepHeader.closest('.execution-step, .sub-step');
                if (stepElement instanceof HTMLElement) {
                    const stepName = stepElement.dataset.stepName;
                    const taskId = stepElement.dataset.taskId;
                    const key = taskId || stepName;
                    if (key) {
                        const state = this.executionState.get(key);
                        if (state) {
                            state.isCollapsed = !state.isCollapsed;
                            const contentWrapper = stepElement.querySelector('.step-content-wrapper, .sub-step-content-wrapper') as HTMLElement;
                            if (contentWrapper) {
                                const isParallel = stepElement.classList.contains('execution-step') && !!stepElement.querySelector('.sub-steps-container');
                                contentWrapper.style.maxHeight = state.isCollapsed ? '0' : (isParallel ? '5000px' : '2000px');
                                contentWrapper.style.padding = state.isCollapsed ? '0 15px' : '10px 15px';
                            }
                        }
                    }
                }
                return;
            }
        });
    }
    private postRender() { /* For future use */ }
}

--------------------------------------------------------------------------------

--- file_path: webview/components/AtCommandMenu.ts ---
// --- file_path: webview/components/AtCommandMenu.ts ---

// 定义命令节点的接口
interface CommandNode {
    id: string;
    name: string;
    children: (CommandNode | CommandLeaf)[];
}

// 定义命令叶子节点（可执行的Agent）的接口
interface CommandLeaf {
    id: string;
    name: string;
    agentId: string; // 对应 AgentService 中的 ID
    description: string;
}

// 类型守卫，用于判断一个节点是否是叶子节点
function isLeaf(node: CommandNode | CommandLeaf): node is CommandLeaf {
    return !('children' in node);
}

// 所有可用命令的树状结构定义
const COMMAND_TREE: (CommandNode | CommandLeaf)[] = [
    {
        id: 'docgen',
        name: 'DocGen',
        children: [
            {
                id: 'docgen-project',
                name: 'DocGen-Project',
                agentId: 'docgen-project',
                description: '生成项目级软件实现设计文档'
            },
            {
                id: 'docgen-module-direct',
                name: 'DocGen-Module-Direct',
                agentId: 'docgen-module-direct',
                description: '采用直接分析的方式，生成模块级详细设计文档'
            },
            {
                id: 'docgen-module-mapreduce',
                name: 'DocGen-Module-MapReduce',
                agentId: 'docgen-module-mapreduce',
                description: '对大模块进行分批摘要总结分析，生成模块级详细设计文档'
            }
        ]
    },
    // 未来可以添加更多一级命令, e.g., CodeRefactor, TestGen etc.
];


export class AtCommandMenu {
    private element: HTMLElement;
    private onSelect: (command: CommandLeaf) => void = () => {};
    
    // 状态管理
    private commands: (CommandNode | CommandLeaf)[] = COMMAND_TREE;
    private currentPath: CommandNode[] = []; // 导航路径
    private visibleItems: (CommandNode | CommandLeaf)[] = []; // 当前显示的列表
    private activeIndex: number = -1; // 当前高亮的索引
    private isSearchMode: boolean = false; // 是否为搜索模式
    private filterText: string = ''; // 搜索文本

    constructor(private container: HTMLElement) {
        // 直接使用传入的容器作为菜单的根元素
        this.element = container;
        this.element.className = 'at-command-menu'; // 确保 class 正确
        this.element.style.display = 'none'; // 默认隐藏

        // 事件监听器直接绑定到容器上
        this.element.addEventListener('click', (e) => {
            const li = (e.target as HTMLElement).closest('li');
            if (li) {
                const index = parseInt(li.dataset.index || '-1', 10);
                if (index !== -1) {
                    this.activeIndex = index;
                    this.handleSelection();
                }
            }
        });
    }

    /**
     * 显示并初始化菜单。
     * @param filter 用户输入的 @ 后面的文本
     * @param onSelect 选择命令后的回调
     */
    public show(filter: string, onSelect: (command: CommandLeaf) => void) {
        this.onSelect = onSelect;
        this.filterText = filter.trim().toLowerCase();
        
        
        // 强制禁用搜索模式，总是显示层级菜单
        this.isSearchMode = false;
        

        this.currentPath = [];
        this.activeIndex = 0;
        
        // 逻辑大幅简化：只需显示并渲染
        this.element.style.display = 'block';
        this.render(); 
    }



    public hide() {
        this.element.style.display = 'none';
        this.currentPath = [];
        this.activeIndex = -1;
    }

    public isVisible(): boolean {
        return this.element.style.display !== 'none';
    }

    /**
     * 处理键盘事件，由 ChatView 委托
     */
    public handleKeyDown(e: KeyboardEvent) {
        if (!this.isVisible()) return;

        e.preventDefault();
        e.stopPropagation();

        switch (e.key) {
            case 'ArrowDown':
                this.activeIndex = (this.activeIndex + 1) % this.visibleItems.length;
                this.render();
                break;
            case 'ArrowUp':
                this.activeIndex = (this.activeIndex - 1 + this.visibleItems.length) % this.visibleItems.length;
                this.render();
                break;
            case 'Tab':
            case 'Enter':
                this.handleSelection();
                break;
            case 'Escape':
                if (this.currentPath.length > 0) {
                    this.currentPath.pop();
                    this.activeIndex = 0;
                    this.render();
                } else {
                    this.hide();
                }
                break;
        }
    }

    /**
     * 处理用户通过 Enter/Tab/Click 进行的选择
     */
    private handleSelection() {
        if (this.activeIndex < 0 || this.activeIndex >= this.visibleItems.length) return;

        const selectedItem = this.visibleItems[this.activeIndex];
        if (isLeaf(selectedItem)) {
            this.onSelect(selectedItem);
            this.hide();
        } else {
            // 进入下一级
            this.currentPath.push(selectedItem);
            this.activeIndex = 0;
            this.render();
        }
    }

    /**
     * 渲染菜单的当前视图
     */
    private render() {
        if (this.isSearchMode) {
            this.renderSearchResults();
        } else {
            this.renderHierarchicalView();
        }
    }

    private renderHierarchicalView() {
        let itemsToShow: (CommandNode | CommandLeaf)[];
        let parent: CommandNode | undefined = this.currentPath[this.currentPath.length - 1];
        
        if (parent) {
            itemsToShow = parent.children;
        } else {
            itemsToShow = this.commands;
        }

        this.visibleItems = itemsToShow;
        if (this.activeIndex >= this.visibleItems.length) {
            this.activeIndex = 0;
        }

        const breadcrumbs = ['@', ...this.currentPath.map(p => p.name)].join(' > ');
        
        this.element.innerHTML = `
            <div class="menu-header">${breadcrumbs}</div>
            <ul>
                ${this.visibleItems.map((item, index) => this.renderItem(item, index)).join('')}
            </ul>
        `;
        this.scrollIntoView();
    }

    private renderSearchResults() {
        const allLeaves = this.flattenCommands(this.commands);
        const searchTerms = this.filterText.split(' ').filter(Boolean);

        this.visibleItems = allLeaves.filter(leaf => 
            searchTerms.every(term => 
                leaf.name.toLowerCase().includes(term) ||
                leaf.agentId.toLowerCase().includes(term) ||
                (this.findPath(leaf.id)?.map(p => p.name.toLowerCase()).join(' ') || '').includes(term)
            )
        );

        if (this.activeIndex >= this.visibleItems.length) {
            this.activeIndex = 0;
        }
        
        if (this.visibleItems.length === 0) {
            this.element.innerHTML = `<div class="menu-header">No results for "${this.filterText}"</div>`;
            return;
        }

        this.element.innerHTML = `
            <div class="menu-header">Search results for "${this.filterText}"</div>
            <ul>
                ${this.visibleItems.map((item, index) => this.renderItem(item, index)).join('')}
            </ul>
        `;
        this.scrollIntoView();
    }

    private renderItem(item: CommandNode | CommandLeaf, index: number): string {
        const isActive = index === this.activeIndex ? 'active' : '';
        const hasChildren = !isLeaf(item);

        return `
            <li class="${isActive}" data-index="${index}">
                <div class="menu-item-name" style="display: flex; align-items: center;">
                    <span>${item.name}</span>
                    ${hasChildren ? '<i class="codicon codicon-chevron-right"></i>' : ''}
                </div>
                ${isLeaf(item) ? `<div class="menu-item-description">${item.description}</div>` : ''}
            </li>
        `;
    }

    private scrollIntoView() {
        const activeItem = this.element.querySelector('li.active');
        if (activeItem) {
            activeItem.scrollIntoView({ block: 'nearest' });
        }
    }

    // --- 辅助函数 ---
    private flattenCommands(nodes: (CommandNode | CommandLeaf)[]): CommandLeaf[] {
        let leaves: CommandLeaf[] = [];
        for (const node of nodes) {
            if (isLeaf(node)) {
                leaves.push(node);
            } else {
                leaves = leaves.concat(this.flattenCommands(node.children));
            }
        }
        return leaves;
    }
    
    private findPath(id: string, nodes: (CommandNode | CommandLeaf)[] = this.commands, path: CommandNode[] = []): CommandNode[] | null {
        for (const node of nodes) {
            if (node.id === id) {
                return path;
            }
            if (!isLeaf(node)) {
                const newPath = [...path, node];
                const found = this.findPath(id, node.children, newPath);
                if (found) {
                    return found;
                }
            }
        }
        return null;
    }
}

--------------------------------------------------------------------------------

--- file_path: webview/components/MessageBlock.ts ---
// src/webview/components/MessageBlock.ts
import { ChatMessage } from "../../common/types";

export class MessageBlock {
    constructor(private readonly message: ChatMessage, private readonly messageIndex: number) { }

    public render(): HTMLElement {
        const element = document.createElement('div');
        element.className = `message-block ${this.message.role}`;
        element.dataset.index = this.messageIndex.toString();

        const content = document.createElement('div');
        content.className = 'message-content';

        // FIX: 使用类型守卫来设置内容
        if (this.message.type === 'text') {
            content.textContent = this.message.content;
        } else { // this.message.type === 'agent_run'
            // 为 AgentRun 消息提供一个摘要或占位符
            content.innerHTML = `<strong>Agent Run: ${this.message.run.plan.agentName}</strong><br>Status: ${this.message.run.result.status}`;
            // 这里可以将来扩展为更复杂的渲染组件
        }

        element.appendChild(content);
        element.appendChild(this.createToolbar());

        return element;
    }

    private createToolbar(): HTMLElement {
        const toolbar = document.createElement('div');
        toolbar.className = 'message-toolbar';

        toolbar.appendChild(this.createButton('toggle-fold', 'Fold', 'codicon-chevron-up'));

        // Agent 运行消息也视为 assistant 角色
        if (this.message.role === 'assistant') {
            toolbar.appendChild(this.createButton('copy-content', 'Copy', 'codicon-copy'));
            // 仅为文本消息提供“重新生成”
            if (this.message.type === 'text') {
                toolbar.appendChild(this.createButton('regenerate-response', 'Regenerate', 'codicon-sync'));
            }
        } else { // user 角色
            toolbar.appendChild(this.createButton('copy-content', 'Copy', 'codicon-copy'));
            toolbar.appendChild(this.createButton('edit-message', 'Edit', 'codicon-pencil'));
        }

        return toolbar;
    }

    private createButton(action: string, title: string, icon: string): HTMLButtonElement {
        const button = document.createElement('button');
        button.className = `icon-button`;
        button.title = title;
        button.dataset.action = action;
        button.innerHTML = `<i class="codicon ${icon}"></i>`;
        return button;
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/css/main.css ---
/* --- file_path: webview/css/main.css --- */
body,
html {
    height: 100%;
    margin: 0;
    padding: 0;
    background-color: var(--vscode-sideBar-background);
    color: var(--vscode-editor-foreground);
    font-family: var(--vscode-font-family);
    display: flex;
    flex-direction: column;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
}

#root {
    display: flex;
    flex-direction: column;
    height: 100%;
    flex: 1;
}

.top-toolbar {
    display: flex;
    justify-content: flex-start;
    padding: 5px;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    flex-shrink: 0;
}

.nav-icon {
    cursor: pointer;
    padding: 5px;
    margin: 0 5px;
    border-radius: 5px;
}

.nav-icon:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.nav-icon.active {
    background-color: var(--vscode-list-activeSelectionBackground);
}

.main-content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    padding: 0;
}

.view {
    display: none;
    height: 100%;
    width: 100%;
    flex-direction: column;
}

.view.active {
    display: flex;
}


/* Chat View & Focus Editor Common Styles */
.chat-container,
.focus-editor-container {
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    flex: 1;
    position: relative;
}

.messages-list {
    flex-grow: 1;
    overflow-y: auto;
    min-height: 0;
    width: 100%;
    box-sizing: border-box;
}

.chat-sticky-bottom {
    flex-shrink: 0;
    width: 100%;
    box-sizing: border-box;
    padding: 10px;
    border-top: 1px solid var(--vscode-editorGroup-border);
    background-color: var(--vscode-sideBar-background);
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.chat-quick-actions {
    display: flex;
    gap: 10px;
    align-items: center;
}

.chat-quick-actions label {
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
}

#model-selector,
#prompt-selector {
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 5px;
    border-radius: 5px;
    flex-grow: 1;
}

.chat-quick-actions button {
    margin-left: auto;
    margin-top: 0;
}

.chat-input-box-container {
    display: flex;
}

.chat-input-box-container textarea {
    flex-grow: 1;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 8px;
    resize: none;
    border-radius: 5px;
}

.chat-container .chat-input-box-container textarea {
    max-height: 250px;
}

.focus-editor-container {
    padding: 10px;
}

.focus-editor-container .chat-input-box-container {
    flex-grow: 1;
}

.focus-editor-container .chat-input-box-container textarea {
    height: 100%;
    width: 100%;
    max-height: none;
    box-sizing: border-box;
}


/* Message Block Styles */
.message-block {
    padding: 15px;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    word-wrap: break-word;
    white-space: pre-wrap;
    position: relative;
}

.message-content {
    transition: max-height 0.3s ease-in-out;
    overflow: hidden;
    position: relative;
}

.message-block.folded .message-content {
    max-height: 70px;
}

.message-block.folded .message-content::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 30px;
    background: linear-gradient(to bottom, transparent, var(--vscode-editor-background));
    pointer-events: none;
}

.message-block:last-child {
    border-bottom: none;
}

.message-toolbar {
    position: absolute;
    top: 5px;
    right: 5px;
    background-color: var(--vscode-editorWidget-background);
    border-radius: 5px;
    padding: 2px;
    display: flex;
    gap: 2px;
    opacity: 0;
    transition: opacity 0.1s ease-in-out;
    pointer-events: none;
}

.message-block:hover .message-toolbar {
    opacity: 1;
    pointer-events: all;
}

.message-block.user {
    background-color: var(--vscode-list-hoverBackground);
    border-left: 3px solid var(--vscode-focusBorder);
    padding-left: 12px;
}

.message-block.folded.user .message-content::after {
    background: linear-gradient(to bottom, transparent, var(--vscode-list-hoverBackground));
}

.message-block.assistant {
    background-color: var(--vscode-editor-background);
}

.message-block.editing {
    border: 1px solid var(--vscode-focusBorder);
    box-shadow: 0 0 3px var(--vscode-focusBorder);
    border-radius: 5px;
}

.message-block.error {
    color: var(--vscode-errorForeground);
}

button.streaming {
    background-color: var(--vscode-button-secondaryBackground);
}

button.streaming:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

button.streaming:hover, .chat-sticky-bottom button[data-action="send-or-save"].streaming:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

/* 更新流式/停止按钮样式 */
button.streaming, .chat-sticky-bottom button[data-action="send-or-save"].streaming {
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

/* Settings View */
.config-form {
    border: 1px solid var(--vscode-editorGroup-border);
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 5px;
    background-color: var(--vscode-sideBar-sectionHeader-background);
}

.form-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.form-title {
    font-size: 1.1em;
}

.default-badge {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 0.8em;
}

.form-group {
    margin-bottom: 10px;
}

.form-group label {
    display: block;
    margin-bottom: 5px;
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
}

.form-group-description {
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
    margin-top: 5px;
    margin-bottom: 10px;
}

.config-form input {
    width: calc(100% - 20px);
    margin-bottom: 5px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 5px;
}

.form-actions {
    margin-top: 15px;
    display: flex;
    gap: 10px;
}

.form-actions button {
    margin-top: 0;
}

button {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: none;
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 5px;
}

button:hover {
    background-color: var(--vscode-button-hoverBackground);
}

/* Generic View Header */
.view-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.view-header h2 {
    margin: 0;
}

.add-btn {
    font-size: 20px;
    font-weight: bold;
    padding: 0px 8px;
}

/* Chat History View */
.history-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.history-item {
    display: flex;
    align-items: center;
    padding: 15px;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    cursor: pointer;
    position: relative;
}

.history-item:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.history-item-content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}

.history-item-timestamp {
    font-size: 0.8em;
    color: var(--vscode-descriptionForeground);
    margin-bottom: 5px;
}

.history-item-title {
    font-size: 1em;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.history-item-actions {
    display: flex;
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    background-color: var(--vscode-list-hoverBackground);
    opacity: 0;
    transition: opacity 0.1s ease-in-out;
    pointer-events: none;
}

.history-item:hover .history-item-actions {
    opacity: 1;
    pointer-events: all;
}

.icon-button {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--vscode-foreground);
    padding: 5px;
    border-radius: 5px;
}

.icon-button:hover {
    background-color: var(--vscode-toolbar-hoverBackground);
}

.history-empty {
    text-align: center;
    padding: 20px;
    color: var(--vscode-descriptionForeground);
}

/*=================================*/
/*========= Prompt Manager ========*/
/*=================================*/

.prompt-manager-view,
.prompt-editor-view {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.prompt-editor-view {
    display: none;
}

.search-bar {
    display: flex;
    align-items: center;
    flex-grow: 1;
    margin-right: 15px;
    background-color: var(--vscode-input-background);
    border: 1px solid var(--vscode-input-border);
    border-radius: 5px;
    padding: 0 8px;
}

.search-bar i {
    margin-right: 8px;
    color: var(--vscode-descriptionForeground);
}

.search-bar input {
    width: 100%;
    border: none;
    background: transparent;
    color: var(--vscode-input-foreground);
    padding: 6px 0;
    outline: none;
}

.codicon-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: none;
    padding: 6px 12px;
    cursor: pointer;
    border-radius: 5px;
}

.codicon-btn:hover {
    background-color: var(--vscode-button-hoverBackground);
}

.codicon-btn.secondary {
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
}

.codicon-btn.secondary:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.icon-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--vscode-foreground);
    padding: 5px;
    border-radius: 5px;
}

.icon-btn:hover {
    background-color: var(--vscode-toolbar-hoverBackground);
}


.prompt-list-container {
    flex-grow: 1;
    overflow-y: auto;
}

.prompt-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.prompt-list-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    cursor: pointer;
    transition: background-color 0.1s ease-in-out;
}

.prompt-list-item:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.prompt-item-main {
    flex-grow: 1;
    margin-right: 15px;
    overflow: hidden;
}

.prompt-item-title {
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: 4px;
}

.prompt-item-summary {
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.prompt-item-meta {
    flex-shrink: 0;
    text-align: right;
}

.prompt-item-time {
    font-size: 0.8em;
    color: var(--vscode-descriptionForeground);
    margin-bottom: 8px;
}

.prompt-item-actions {
    display: flex;
    gap: 5px;
    opacity: 0;
    transition: opacity 0.1s ease-in-out;
}

.prompt-list-item:hover .prompt-item-actions {
    opacity: 1;
}

.empty-state {
    text-align: center;
    padding: 40px 20px;
    color: var(--vscode-descriptionForeground);
}

.empty-state p {
    margin-bottom: 15px;
}

.highlighted-btn {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: 1px solid var(--vscode-button-border, transparent);
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
}

.highlighted-btn:hover {
    background-color: var(--vscode-button-hoverBackground);
}

/*=================================*/
/*========= Prompt Editor =========*/
/*=================================*/

.prompt-editor-form {
    flex-grow: 1;
    overflow-y: auto;
    padding: 10px;
    display: flex;
    flex-direction: column;
}

.prompt-editor-form .form-group {
    display: flex;
    flex-direction: column;
}

.prompt-editor-form .form-group:last-child {
    flex-grow: 1;
}

.prompt-editor-form input,
.prompt-editor-form textarea {
    width: calc(100% - 22px);
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 10px;
    border-radius: 5px;
}

.prompt-editor-form textarea {
    flex-grow: 1;
    resize: none;
    font-family: var(--vscode-editor-font-family);
}

.prompt-editor-form textarea:focus {
    outline: none;
}

/*=================================*/
/*====== Rich Input & Pills =======*/
/*=================================*/

.chat-input-box {
    flex-grow: 1;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 8px;
    border-radius: 5px;
    min-height: 22px;
    max-height: 250px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
    line-height: 1.5;
}

.chat-input-box:focus {
    outline: 1px solid var(--vscode-focusBorder);
}

.content-pill {
    display: inline-block;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border-radius: 12px;
    padding: 2px 10px;
    margin: 0 2px;
    font-size: 0.9em;
    font-weight: 500;
    cursor: default;
}

.chat-input-box p, .chat-input-box div {
    margin: 0;
}

/*=================================*/
/*====== @ Command Menu ===========*/
/*=================================*/
.at-command-menu {
    width: 100%;
    box-sizing: border-box;
    background-color: var(--vscode-editorWidget-background);
    border: 1px solid var(--vscode-editorWidget-border);
    border-radius: 5px;
    z-index: 100;
    max-height: 220px;
    overflow-y: auto;
    margin-bottom: 8px;
    display: none;
}

.at-command-menu ul {
    list-style: none;
    padding: 5px;
    margin: 0;
}

.at-command-menu li {
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 3px;
}

.at-command-menu li:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.at-command-menu li.active {
    background-color: var(--vscode-list-hoverBackground);
    color: var(--vscode-list-activeSelectionForeground);
}

.at-command-menu .menu-header {
    padding: 8px 12px;
    border-bottom: 1px solid var(--vscode-editorWidget-border);
    color: var(--vscode-descriptionForeground);
    font-size: 0.9em;
}

.at-command-menu .menu-item-name {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
}

.at-command-menu .menu-item-name .codicon {
    color: var(--vscode-descriptionForeground);
}

.at-command-menu .menu-item-description {
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
    margin-top: 4px;
}

/*=================================*/
/*====== Agent Run Block (Final & Cleaned) =======*/
/*=================================*/

.agent-run-block {
    background-color: var(--vscode-sideBar-sectionHeader-background);
    border: 1px solid var(--vscode-editorGroup-border);
    border-radius: 8px;
    margin: 10px 0;
    padding: 15px;
    font-size: 0.9em;
}

.agent-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    padding-bottom: 10px;
    margin-bottom: 15px;
}

.agent-header h4 {
    margin: 0;
    font-size: 1.2em;
}

.badge {
    padding: 3px 8px;
    border-radius: 12px;
    font-weight: 500;
}
.badge.planning { background-color: var(--vscode-testing-iconQueued-foreground); color: var(--vscode-button-foreground); }
.badge.executing { background-color: var(--vscode-testing-iconRunning-foreground); color: var(--vscode-button-foreground); }
.badge.completed { background-color: var(--vscode-testing-iconPassed-foreground); color: var(--vscode-button-foreground); }
.badge.failed { background-color: var(--vscode-testing-iconFailed-foreground); color: var(--vscode-button-foreground); }
.badge.cancelled { background-color: var(--vscode-testing-iconSkipped-foreground); color: var(--vscode-button-foreground); }

.agent-plan-steps, .agent-parameters {
    margin-bottom: 20px;
}

.agent-plan-steps h5, .agent-parameters h5 {
    margin: 0 0 10px 0;
    color: var(--vscode-descriptionForeground);
}

.step-card {
    background-color: var(--vscode-input-background);
    border: 1px solid var(--vscode-input-border);
    border-radius: 5px;
    padding: 10px;
    margin-bottom: 8px;
}

.step-card-name {
    font-weight: bold;
    margin-bottom: 4px;
}

.step-card-desc {
    font-size: 0.95em;
    color: var(--vscode-descriptionForeground);
}

.parameter-item {
    margin-bottom: 10px;
}

.parameter-item label {
    display: block;
    margin-bottom: 5px;
}

.parameter-description {
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
    margin-bottom: 8px; 
    font-style: italic; 
}

.parameter-item input {
    width: calc(100% - 16px);
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 8px;
    border-radius: 5px;
}

.parameter-item .error-text {
    color: var(--vscode-errorForeground);
    font-size: 0.9em;
    margin-top: 5px;
}

.parameter-item input.invalid {
    border-color: var(--vscode-errorForeground);
}

.agent-actions {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 15px;
}

.agent-actions button {
    flex: 1;
    padding: 10px;
    font-size: 1.1em;
    font-weight: 500;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}
.execute-btn:hover {
    background-color: var(--vscode-button-hoverBackground);
}

.agent-actions .stop-btn {
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
}
.agent-actions .stop-btn:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.agent-actions button.secondary {
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
}
.agent-actions button.secondary:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.execute-btn {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: none;
    padding: 8px 15px;
    cursor: pointer;
    border-radius: 5px;
}
.execute-btn:hover {
    background-color: var(--vscode-button-hoverBackground);
}


/* -- Executing View -- */
.execution-step {
    border-left: 3px solid;
    margin-bottom: 10px;
    transition: all 0.2s ease-in-out;
    border-radius: 0 5px 5px 0;
    overflow: hidden;
}
.execution-step.waiting { border-color: var(--vscode-editorHint-foreground); }
.execution-step.completed { border-color: var(--vscode-testing-iconPassed-foreground); }
.execution-step.failed { border-color: var(--vscode-testing-iconFailed-foreground); }

@keyframes pulse-border {
    0% { border-color: var(--vscode-testing-iconRunning-foreground); }
    50% { border-color: var(--vscode-focusBorder); }
    100% { border-color: var(--vscode-testing-iconRunning-foreground); }
}

.execution-step.running {
    animation: pulse-border 2s infinite;
}

.execution-step .step-header {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    cursor: pointer;
    background-color: var(--vscode-sideBar-sectionHeader-background);
    transition: background-color 0.2s ease;
}
.execution-step .step-header:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.execution-step .status-icon {
    font-size: 1.1em;
}

.execution-step .step-name {
    flex-grow: 1;
}

.execution-step .step-status {
    font-family: monospace;
    font-size: 0.9em;
    padding: 2px 6px;
    border-radius: 3px;
    background-color: var(--vscode-badge-background);
    color: var(--vscode-badge-foreground);
}

.execution-step .step-content {
    overflow: hidden;
    transition: max-height 0.4s ease-in-out, padding 0.4s ease-in-out;
    padding: 0 15px;
    background-color: var(--vscode-input-background);
}
.execution-step .step-content[style*="max-height: 2000px"],
.execution-step .step-content[style*="max-height: 5000px"] {
    padding: 10px 15px;
}


.log-item {
    border: 1px solid var(--vscode-input-border);
    border-left-width: 4px;
    border-radius: 5px;
    margin: 10px 0;
    background: var(--vscode-editor-background);
}
.log-item.log-input { border-left-color: var(--vscode-terminal-ansiBlue); }
.log-item.log-output { border-left-color: var(--vscode-terminal-ansiGreen); }
.log-item.log-llm-request { border-left-color: var(--vscode-terminal-ansiYellow); }
.log-item.log-llm-stream { border-left-color: var(--vscode-terminal-ansiCyan); }

.log-item .log-header {
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(128, 128, 128, 0.1);
    padding: 5px 10px;
    font-weight: bold;
    color: var(--vscode-descriptionForeground);
    border-bottom: 1px solid var(--vscode-input-border);
    cursor: pointer; /* 添加手型光标，提示用户这里可以点击 */
}
.log-item .log-header .codicon {
    font-size: 1.1em;
}

.log-content-wrapper {
    padding: 5px 10px;
    max-height: 400px; /* 设置一个合理的默认最大高度 */
    overflow-y: auto;  /* 当内容超出时，显示内部滚动条 */
    transition: max-height 0.3s ease-out, padding 0.3s ease-out; /* 添加平滑过渡动画 */
    background-color: var(--vscode-editor-background); /* 确保滚动条背景色正确 */
}

.log-item.collapsed .log-content-wrapper {
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
    overflow: hidden; /* 在折叠时隐藏内容，防止文字溢出 */
    border-bottom: none; /* 折叠时不需要底边框 */
}

.log-content-wrapper pre {
    margin: 0;
    padding: 5px;
    white-space: pre-wrap;
    word-break: break-all;
}
.log-content-wrapper code {
    font-family: var(--vscode-editor-font-family);
}

.log-llm-stream .markdown-body {
    padding: 0 10px 10px 10px;
}
.log-llm-stream .markdown-body p:first-child,
.log-llm-stream .markdown-body ul:first-child,
.log-llm-stream .markdown-body ol:first-child {
    margin-top: 10px;
}
.log-llm-stream .markdown-body p,
.log-llm-stream .markdown-body ul,
.log-llm-stream .markdown-body ol {
    margin-top: 0;
    margin-bottom: 0.5em;
}

.step-error {
    background-color: rgba(255, 0, 0, 0.1);
    border: 1px solid var(--vscode-errorForeground);
    color: var(--vscode-errorForeground);
    padding: 10px;
    border-radius: 5px;
    margin: 10px 0;
    white-space: pre-wrap;
}

.agent-final-result {
    margin-top: 20px;
    border: 1px solid var(--vscode-editorGroup-border);
    border-left-width: 4px;
    border-radius: 5px;
    overflow: hidden;
}
.agent-final-result.completed {
    border-left-color: var(--vscode-testing-iconPassed-foreground);
    background-color: rgba(45, 212, 129, 0.1);
}
.agent-final-result.failed,
.agent-final-result.cancelled {
    border-left-color: var(--vscode-testing-iconFailed-foreground);
    background-color: rgba(255, 0, 0, 0.1);
}

.result-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    font-weight: bold;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
}

.result-header .codicon {
    font-size: 1.2em;
}

.result-content {
    padding: 12px;
}
.result-content .error-text {
    color: var(--vscode-errorForeground);
    white-space: pre-wrap;
}

/* --- File & Prompt Card Styles --- */
.prompt-files-container {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
}

.file-card {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background-color: var(--vscode-input-background);
    border: 1px solid var(--vscode-input-border);
    padding: 6px 12px;
    border-radius: 5px;
    font-size: 0.9em;
    cursor: pointer;
    transition: background-color 0.2s ease, border-color 0.2s ease;
    flex-grow: 0;
}
.file-card:hover {
    background-color: var(--vscode-list-hoverBackground);
    border-color: var(--vscode-focusBorder);
}
.file-card .codicon {
    font-size: 1.2em;
    color: var(--vscode-descriptionForeground);
}
.result-content .file-card {
    background: none;
    border: none;
    padding: 0;
    font-size: 1em;
}
.result-content .file-card:hover {
    background: var(--vscode-list-hoverBackground);
}


/* --- Sub-step Styles --- */
.sub-steps-container {
    padding: 10px 5px;
    margin: 10px 0;
    border-radius: 5px;
    background-color: var(--vscode-sideBar-background);
}

.sub-step-placeholder {
    color: var(--vscode-descriptionForeground);
    font-style: italic;
    text-align: center;
    padding: 15px;
}

.sub-step {
    padding: 0;
    border-left: 3px solid;
    margin-bottom: 8px;
    background-color: var(--vscode-editor-background);
    border-radius: 0 3px 3px 0;
    overflow: hidden;
}
.sub-step:last-child {
    margin-bottom: 0;
}

.sub-step.waiting { border-color: var(--vscode-editorHint-foreground); }
.sub-step.running { border-color: var(--vscode-testing-iconRunning-foreground); }
.sub-step.completed { border-color: var(--vscode-testing-iconPassed-foreground); }
.sub-step.failed { border-color: var(--vscode-testing-iconFailed-foreground); }

.sub-step-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 10px;
    cursor: pointer;
    transition: background-color 0.2s ease;
}
.sub-step-header:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.sub-step-content {
    padding: 0 10px 10px 10px;
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}
.sub-step-content .log-item {
    margin: 0;
}

.planning-view.read-only .parameter-item input {
    background-color: var(--vscode-input-background);
    opacity: 0.7;
    cursor: not-allowed;
    border-style: dashed;
}

.planning-view.read-only .prompt-file-card {
    cursor: default;
}
.planning-view.read-only .prompt-file-card:hover {
    background-color: var(--vscode-button-secondaryBackground);
}

@keyframes pulse-waiting {
  0% { opacity: 1; }
  50% { opacity: 0.4; }
  100% { opacity: 1; }
}
.execution-step.waiting .status-icon .codicon-more,
.sub-step.waiting .status-icon .codicon-more {
  animation: pulse-waiting 2s infinite ease-in-out;
}

.llm-waiting-placeholder {
    border-style: dashed !important; /* 覆盖默认边框样式 */
}
.llm-waiting-placeholder .log-header {
    background: transparent !important;
    border-bottom: none !important;
    color: var(--vscode-descriptionForeground) !important;
    font-style: italic;
}
.llm-waiting-placeholder .log-header .codicon-loading {
    color: var(--vscode-testing-iconRunning-foreground);
}

/* Loading dots animation */
@keyframes-loading-dots {
  0%   { content: '.'; }
  33%  { content: '..'; }
  66%  { content: '...'; }
  100% { content: '.'; }
}

.loading-dots::after {
  content: '.';
  animation: keyframes-loading-dots 1.5s infinite;
  display: inline-block;
  width: 20px; /* Give it some space */
  text-align: left;
}

/* 新增淡入动画 */
@keyframes-fade-in {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.fade-in {
  animation: keyframes-fade-in 0.4s ease-out;
}

/* 为步骤状态变化添加平滑过渡 */
.execution-step, .sub-step {
    transition: border-color 0.4s ease-in-out, background-color 0.4s ease-in-out;
}

.executing-view-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 0;
    margin-top: 15px;
    border-top: 1px solid var(--vscode-editorGroup-border);
}
.executing-view-header h4 {
    margin: 0;
}

@keyframes card-fade-in {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* 将动画应用到主步骤卡片上 */
.execution-step {
    border-left: 3px solid;
    margin-bottom: 10px;
    transition: all 0.2s ease-in-out;
    border-radius: 0 5px 5px 0;
    animation: card-fade-in 0.4s ease-out forwards;
}

/* 将动画也应用到最终结果卡片上 */
.agent-final-result {
    margin-top: 20px;
    border: 1px solid var(--vscode-editorGroup-border);
    border-left-width: 4px;
    border-radius: 5px;
    animation: card-fade-in 0.4s ease-out forwards;
}

.execution-step.needs-animation,
.sub-step.needs-animation, /* Added for sub-steps */
.agent-final-result.needs-animation {
    animation: card-fade-in 0.4s ease-out forwards;
}

@keyframes codicon-spin-animation { /* 使用一个不冲突的动画名 */
    100% {
        transform: rotate(360deg);
    }
}

.codicon-spin:before { /* 直接针对 :before 伪元素应用动画 */
    animation: codicon-spin-animation 0.6s linear infinite; /* 时长可以调整 */
    display: inline-block; /* 有时需要确保伪元素是块级或行内块级才能应用 transform */
}

.result-content {
    padding: 12px;
    background-color: var(--vscode-editor-background);
}
.result-content .error-text {
    color: var(--vscode-errorForeground);
    white-space: pre-wrap;
}

/* highlight-start */
.result-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 10px;
    padding: 5px;
}

.stat-item {
    display: flex;
    align-items: center;
    gap: 8px;
    background-color: var(--vscode-sideBar-sectionHeader-background);
    padding: 8px 12px;
    border-radius: 5px;
    border-left: 2px solid var(--vscode-focusBorder);
}

.stat-item .codicon {
    font-size: 1.2em;
    color: var(--vscode-descriptionForeground);
}

.stat-item span {
    flex-grow: 1;
    color: var(--vscode-descriptionForeground);
    font-size: 0.9em;
}

.stat-item strong {
    font-size: 1em;
    font-weight: 600;
    color: var(--vscode-editor-foreground);
}

/*====== Chat View Empty State ======*/
.chat-empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    padding: 20px;
    box-sizing: border-box;
    text-align: center;
    color: var(--vscode-descriptionForeground);
}

.chat-empty-state .empty-state-icon {
    font-size: 48px;
    margin-bottom: 16px;
    color: var(--vscode-editor-foreground);
}

.chat-empty-state .empty-state-icon .codicon {
    font-size: 96px; /* 这直接应用到了 <i> 元素上 */
}

.chat-empty-state h2 {
    margin: 0 0 8px 0;
    font-size: 1.5em;
    font-weight: 600;
    color: var(--vscode-editor-foreground);
}

.chat-empty-state p {
    margin: 0 0 24px 0;
    font-size: 1.1em;
}

.example-prompts {
    width: 100%;
    max-width: 500px;
}

.example-prompts .example-prompt-title {
    margin-bottom: 12px;
    font-weight: bold;
}

.example-prompts .example-prompt {
    background-color: var(--vscode-sideBar-sectionHeader-background);
    border: 1px solid var(--vscode-editorGroup-border);
    padding: 12px;
    border-radius: 5px;
    margin-bottom: 8px;
    font-family: var(--vscode-editor-font-family);
    font-size: 0.95em;
    text-align: left;
}

.example-prompts .example-prompt code {
    background-color: var(--vscode-textCodeBlock-background);
    padding: 2px 4px;
    border-radius: 3px;
}

/* 1. 隐藏顶部工具栏中的 "Prompts" 导航图标 */
#nav-prompts {
    display: none;
}

/* 2. 隐藏聊天视图中 "Prompt:" 的标签和下拉选择器 */
.chat-quick-actions label[for="prompt-selector"],
#prompt-selector {
    display: none;
}

/* 3. (可选但推荐) 隐藏 Focus Editor 视图中的 "Prompt:" 标签和下拉选择器 */
.focus-editor-container .chat-quick-actions label[for="prompt-selector"],
.focus-editor-container #prompt-selector {
    display: none;
}

--------------------------------------------------------------------------------

--- file_path: webview/main.ts ---
import { App } from './views/App';

// Wait for the DOM to be fully loaded before initializing the app
window.addEventListener('load', () => {
    const app = new App(document.body);
    app.initialize();
});


--------------------------------------------------------------------------------

--- file_path: webview/views/App.ts ---
import { vscode } from '../vscode';
import { ChatView } from './ChatView';
import { SettingsView } from './SettingsView';
import { WelcomeView } from './WelcomeView';
import { ChatHistoryView } from './ChatHistoryView';
import { FocusEditorView } from './FocusEditorView';
import { PerformanceSettingsView } from './PerformanceSettingsView';

export class App {
    private chatView: ChatView;
    private focusEditorView?: FocusEditorView;
    private settingsView: SettingsView;
    private welcomeView: WelcomeView;
    private chatHistoryView: ChatHistoryView;
    private performanceSettingsView: PerformanceSettingsView;


    constructor(private readonly parent: HTMLElement) {
        this.parent.innerHTML = this.render();

        this.welcomeView = new WelcomeView(this.parent.querySelector('#view-welcome') as HTMLElement);
        this.chatView = new ChatView(this.parent.querySelector('#view-chat') as HTMLElement);
        this.chatHistoryView = new ChatHistoryView(
            this.parent.querySelector('#view-history') as HTMLElement,
            this.navigateTo.bind(this)
        );
        this.settingsView = new SettingsView(this.parent.querySelector('#view-settings') as HTMLElement);
        this.performanceSettingsView = new PerformanceSettingsView(this.parent.querySelector('#view-performance-settings') as HTMLElement);
    }

    public initialize() {
        this.setupEventListeners();
        // On initial load, determine if this is a focus editor or main view
        if (document.body.classList.contains('focus-editor-body')) {
            vscode.postMessage({ command: 'ready' });
        } else {
            this.navigateTo('chat');
            vscode.postMessage({ command: 'ready' });
        }
    }

    private setupEventListeners() {
        // Top toolbar navigation
        this.parent.querySelector('#nav-new-chat')?.addEventListener('click', () => this.chatView.clearChat());
        this.parent.querySelector('#nav-chat')?.addEventListener('click', () => this.navigateTo('chat'));
        this.parent.querySelector('#nav-history')?.addEventListener('click', () => this.navigateTo('history'));
        this.parent.querySelector('#nav-prompts')?.addEventListener('click', () => this.navigateTo('prompts'));
        this.parent.querySelector('#nav-settings')?.addEventListener('click', () => this.navigateTo('settings'));
        this.parent.querySelector('#nav-performance-settings')?.addEventListener('click', () => this.navigateTo('performance-settings'));

        // Listen for messages from the extension host
        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.command) {
                case 'initialize':
                    this.chatView.setConversations(message.payload.conversations);
                    this.chatHistoryView.setConversations(message.payload.conversations);
                    // this.promptManagerView.update(message.payload.prompts);
                    // this.chatView.setPrompts(message.payload.prompts);
                    this.chatView.setModelConfigs(message.payload.modelConfigs);
                    this.settingsView.setModelConfigs(message.payload.modelConfigs);
                    if (message.payload.performanceConfig) {
                        this.performanceSettingsView.setPerformanceConfig(message.payload.performanceConfig);
                    }
                    break;
                case 'setActiveConversation':
                    this.chatView.loadConversation(message.payload);
                    break;
                case 'updateModelConfigs':
                    this.chatView.setModelConfigs(message.payload);
                    this.settingsView.setModelConfigs(message.payload);
                    if (this.focusEditorView) {
                        this.focusEditorView.setModelConfigs(message.payload);
                    }
                    break;
                case 'updateHistory':
                    this.chatHistoryView.setConversations(message.payload);
                    break;
                case 'showFocusEditor':
                    this.navigateTo('focus-editor', message.payload);
                    break;
                case 'updateContent':
                    if (this.focusEditorView) {
                        this.focusEditorView.updateContent(message.payload.content);
                    }
                    const mainTextarea = this.chatView['bottomPanel'].querySelector('textarea');
                    if (mainTextarea && mainTextarea.value !== message.payload.content) {
                        mainTextarea.value = message.payload.content;
                        this.chatView['autoResizeInput'](mainTextarea);
                    }
                    break;
                case 'updateState':
                    if (this.focusEditorView) {
                        this.focusEditorView.updateState(message.payload);
                    }
                    if (message.payload.modelId) {
                        this.chatView['modelSelector'].value = message.payload.modelId;
                    }
                    if (message.payload.promptId) {
                        this.chatView['promptSelector'].value = message.payload.promptId;
                    }
                    break;
                case 'clearInput':
                    const textarea = this.chatView['bottomPanel'].querySelector('textarea');
                    if (textarea) {
                        textarea.value = '';
                        this.chatView['autoResizeInput'](textarea);
                    }
                    if (this.focusEditorView) {
                        this.focusEditorView.clearInput();
                    }
                    break;
                case 'focusEditorClosed':
                    this.navigateTo('chat');
                    const topToolbar = this.parent.querySelector('.top-toolbar') as HTMLElement;
                    if (topToolbar) topToolbar.style.display = 'flex';
                    this.chatView['toggleMaximizeButton'](false);
                    break;
            }
        });
    }

    public navigateTo(view: string, data?: any) {
        this.parent.querySelectorAll('.view').forEach(v => {
            (v as HTMLElement).style.display = 'none';
        });

        let activeNav = view;

        if (view === 'performance-settings') {
            activeNav = 'performance-settings';
        } else if (view === 'settings') {
            activeNav = 'settings';
        }

        if (view === 'chat' && typeof data === 'string') {
            vscode.postMessage({ command: 'loadConversation', payload: { id: data } });
        } else if (view === 'focus-editor') {
            const container = this.parent.querySelector('#view-focus-editor') as HTMLElement;
            if (!this.focusEditorView) {
                this.focusEditorView = new FocusEditorView(container, data);
            }

            // 直接从 data payload 中获取数据并设置
            if (data.modelConfigs) {
                this.focusEditorView.setModelConfigs(data.modelConfigs);
            }
            if (data.prompts) {
                this.focusEditorView.setPrompts(data.prompts);
            }

            // 每次导航时都更新内容和状态
            this.focusEditorView.updateContent(data.content);
            this.focusEditorView.updateState(data);
            container.style.display = 'flex';
            const topToolbar = this.parent.querySelector('.top-toolbar') as HTMLElement;
            if (topToolbar) topToolbar.style.display = 'none';
            return; // Skip nav update for focus editor
        }

        // 找到目标视图并显示它
        const targetView = this.parent.querySelector(`#view-${view}`);
        if (targetView) {
            // --- 确保这里是 'flex' ---
            (targetView as HTMLElement).style.display = 'flex';
        } else {
            // 如果找不到视图，打印一个错误，这有助于调试
            console.error(`NavigateTo: Could not find view with id #view-${view}`);
        }

        // 更新顶部导航栏图标的激活状态
        this.parent.querySelectorAll('.nav-icon').forEach(icon => icon.classList.remove('active'));
        const navIcon = this.parent.querySelector(`#nav-${activeNav}`);
        if (navIcon) {
            navIcon.classList.add('active');
        } else {
            console.error(`NavigateTo: Could not find nav icon with id #nav-${activeNav}`);
        }
    }

    private render(): string {
        // 更新工具栏 HTML
        return `
            <div class="top-toolbar">
                <div id="nav-new-chat" class="nav-icon" title="New Chat"><i class="codicon codicon-add"></i></div>
                <div class="nav-separator"></div>
                <div id="nav-chat" class="nav-icon" title="Chat"><i class="codicon codicon-comment-discussion"></i></div>
                <div id="nav-history" class="nav-icon" title="History"><i class="codicon codicon-history"></i></div>
                <!-- <div id="nav-prompts" class="nav-icon" title="Prompts"><i class="codicon codicon-symbol-keyword"></i></div> -->
                <div id="nav-settings" class="nav-icon" title="Model Settings"><i class="codicon codicon-server-environment"></i></div>
                <div id="nav-performance-settings" class="nav-icon" title="Performance Settings"><i class="codicon codicon-settings-gear"></i></div>
            </div>
            <div class="main-content">
                <div id="view-welcome" class="view"></div>
                <div id="view-chat" class="view"></div>
                <div id="view-history" class="view"></div>
                <!-- <div id="view-prompts" class="view"></div> -->
                <!-- <div id="view-prompt-editor" class="view"></div> -->
                <div id="view-settings" class="view"></div>
                <div id="view-performance-settings" class="view"></div>
                <div id="view-focus-editor" class="view"></div>
            </div>
        `;
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/ChatHistoryView.ts ---
import { Conversation } from "../../common/types";
import { vscode } from "../vscode";

export class ChatHistoryView {
    private conversations: Conversation[] = [];
    private historyContainer: HTMLElement;

    constructor(
        private readonly parent: HTMLElement,
        private readonly navigate: (view: string, conversationId?: string) => void
    ) {
        this.parent.innerHTML = `<div class="history-container"><h2>Chat History</h2><ul class="history-list"></ul></div>`;
        this.historyContainer = this.parent.querySelector('.history-list') as HTMLElement;
    }

    public setConversations(conversations: Conversation[]) {
        // Sort conversations by date, newest first
        this.conversations = conversations.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
        this.render();
    }

    private render() {
        this.historyContainer.innerHTML = '';
        if (this.conversations.length === 0) {
            this.historyContainer.innerHTML = `<li class="history-empty">No chat history found.</li>`;
            return;
        }

        this.conversations.forEach(conv => {
            const li = document.createElement('li');
            li.className = 'history-item';
            li.dataset.id = conv.id;
            li.addEventListener('click', () => {
                this.navigate('chat', conv.id);
            });

            const content = document.createElement('div');
            content.className = 'history-item-content';

            const timestamp = document.createElement('div');
            timestamp.className = 'history-item-timestamp';
            timestamp.textContent = this.formatDate(conv.createdAt);

            const title = document.createElement('div');
            title.className = 'history-item-title';
            title.textContent = conv.title;

            content.appendChild(timestamp);
            content.appendChild(title);

            const actions = document.createElement('div');
            actions.className = 'history-item-actions';
            
            const deleteButton = document.createElement('button');
            deleteButton.className = 'icon-button';
            deleteButton.title = 'Delete';
            deleteButton.innerHTML = `<i class="codicon codicon-trash"></i>`;
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                vscode.postMessage({ command: 'deleteConversation', payload: { id: conv.id } });
            });

            const exportButton = document.createElement('button');
            exportButton.className = 'icon-button';
            exportButton.title = 'Export';
            exportButton.innerHTML = `<i class="codicon codicon-export"></i>`;
            exportButton.addEventListener('click', (e) => {
                e.stopPropagation();
                // Placeholder for export functionality
                vscode.postMessage({ command: 'info', payload: 'Export functionality is not yet implemented.' });
            });

            actions.appendChild(deleteButton);
            actions.appendChild(exportButton);

            li.appendChild(content);
            li.appendChild(actions);

            this.historyContainer.appendChild(li);
        });
    }

    private formatDate(dateString: string): string {
        const date = new Date(dateString);
        const options: Intl.DateTimeFormatOptions = {
            month: 'long',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric',
            hour12: true
        };
        return date.toLocaleString('en-US', options).replace(',', '');
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/ChatView.ts ---
// --- file_path: webview/views/ChatView.ts ---

import { vscode } from "../vscode";
import { MessageBlock } from "../components/MessageBlock";
import { AtCommandMenu } from "../components/AtCommandMenu";
// 在文件顶部添加新的 import
import { AgentRunBlock } from "../components/AgentRunBlock";
import { Conversation, ChatMessage, ModelConfig, Prompt, AgentPlan, StepExecution, StepUpdate, StepResult, StreamChunk, AgentResult, TextChatMessage, AgentRunChatMessage, AgentRunRecord } from "../../common/types";

interface CommandLeaf {
    id: string;
    name: string;
    agentId: string;
    description: string;
}

export class ChatView {
    private activeConversationId: string | null = null;
    private messages: ChatMessage[] = [];
    private modelConfigs: ModelConfig[] = [];
    private prompts: Prompt[] = [];
    private messageContainer: HTMLElement;
    private bottomPanel: HTMLElement;
    private modelSelector: HTMLSelectElement;
    private promptSelector: HTMLSelectElement;
    private isStreaming: boolean = false;
    private editingMessageIndex: number | null = null;
    private originalMessageContent: string | null = null;
    private atCommandMenu: AtCommandMenu;
    private inputBox: HTMLElement; // 从 HTMLTextAreaElement 改为 HTMLElement
    private activeAgentRunContainer: HTMLElement | null = null;
    private activeAgentRunBlock: AgentRunBlock | null = null;
    private isAgentRunning: boolean = false;
    private activeAgentRunId: string | null = null;


    constructor(private readonly parent: HTMLElement) {
        this.parent.innerHTML = this.renderInitialLayout();
        this.messageContainer = this.parent.querySelector('.messages-list') as HTMLElement;
        this.bottomPanel = this.parent.querySelector('.chat-sticky-bottom') as HTMLElement;
        this.modelSelector = this.parent.querySelector('#model-selector') as HTMLSelectElement;
        this.promptSelector = this.parent.querySelector('#prompt-selector') as HTMLSelectElement;

        // 渲染输入框并获取其引用
        this.renderBottomInput(); 
        this.inputBox = this.bottomPanel.querySelector('.chat-input-box') as HTMLElement;
        
        // 将菜单附加到 chat-container, 以便使用相对定位
        const commandMenuContainer = this.parent.querySelector('.at-command-menu-container') as HTMLElement;
        this.atCommandMenu = new AtCommandMenu(commandMenuContainer);

        this.setupEventListeners();
    }

    public setConversations(conversations: Conversation[]) {
        if (conversations.length > 0) {
            // 找到最后一个非空对话
            const lastNonEmptyConversation = [...conversations].reverse().find(c => c.messages.length > 0);
            if (lastNonEmptyConversation) {
                this.messages = lastNonEmptyConversation.messages;
                this.activeConversationId = lastNonEmptyConversation.id;
            } else {
                // 如果所有对话都是空的，则清空当前状态
                this.messages = [];
                this.activeConversationId = null;
            }
        } else {
            this.messages = [];
        }
        this.renderMessages();
    }

    public clearChat() {
        this.messages = [];
        this.renderMessages();
        vscode.postMessage({ command: 'newChat' });
    }

    public loadConversation(conversation: Conversation) {
        this.messages = conversation.messages;
        this.activeConversationId = conversation.id; // 确保加载对话时也设置 activeConversationId
        this.handleCancelEdit(); // Ensure we exit any edit mode when loading a new conversation
        this.renderMessages();
    }

    public setModelConfigs(configs: ModelConfig[]) {
        this.modelConfigs = configs;
        this.renderModelSelector();
    }

    public setPrompts(prompts: Prompt[]) {
        this.prompts = prompts;
        this.renderPromptSelector();
    }

    private setupEventListeners() {
        // Listener for all clicks in the view
        this.parent.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            const button = target.closest('button');

            // 如果点击了输入框外部，且@菜单是可见的，则隐藏它
            if (!this.inputBox.contains(target) && !this.atCommandMenu['element'].contains(target)) {
                this.atCommandMenu.hide();
            }

            if (this.editingMessageIndex !== null) {
                const editingBlock = this.parent.querySelector('.message-block.editing');
                if (editingBlock && !editingBlock.contains(target) && !this.bottomPanel.contains(target)) {
                    this.handleCancelEdit();
                    return;
                }
            }

            if (!button) return;
            const action = button.dataset.action;
            if (!action) return;

            const messageBlock = target.closest('.message-block');
            const messageIndex = messageBlock ? parseInt((messageBlock as HTMLElement).dataset.index || '-1', 10) : -1;

            switch (action) {
                case 'send-or-save': this.handleSendOrSave(); break;
                case 'copy-content': if (messageIndex !== -1) this.handleCopy(messageIndex); break;
                case 'regenerate-response': if (messageIndex !== -1) this.handleRegenerate(messageIndex); break;
                case 'edit-message': if (messageIndex !== -1) this.handleEnterEditMode(messageIndex); break;
                case 'maximize-editor': this.handleMaximizeEditor(); break;
                case 'toggle-fold':
                    if (messageBlock) {
                        const icon = button.querySelector('i');
                        messageBlock.classList.toggle('folded');
                        if (messageBlock.classList.contains('folded')) {
                            button.title = 'Expand';
                            icon?.classList.remove('codicon-chevron-up');
                            icon?.classList.add('codicon-chevron-down');
                        } else {
                            button.title = 'Fold';
                            icon?.classList.remove('codicon-chevron-down');
                            icon?.classList.add('codicon-chevron-up');
                        }
                    }
                    break;

            }
        });

        window.addEventListener('resize', () => {

        });

        this.modelSelector.addEventListener('change', () => {
            vscode.postMessage({
                command: 'syncStateChange',
                payload: { modelId: this.modelSelector.value }
            });
        });

        this.promptSelector.addEventListener('change', () => {
            const selectedPromptId = this.promptSelector.value;
            vscode.postMessage({
                command: 'syncStateChange',
                payload: { promptId: selectedPromptId }
            });

            if (selectedPromptId) {
                const selectedPrompt = this.prompts.find(p => p.id === selectedPromptId);
                if (selectedPrompt) {
                    // 更新为操作 contenteditable div
                    if (this.inputBox) {
                        this.inputBox.innerText = selectedPrompt.content;
                        this.inputBox.focus();
                        vscode.postMessage({
                            command: 'updateWebviewContent',
                            payload: { content: this.inputBox.innerText }
                        });
                    }
                }
            }
        });

        window.addEventListener('message', event => {
            const message = event.data;
            const { command, payload } = message;
            if (command.startsWith('agent:')) {
                if (command === 'agent:planGenerated' && this.activeAgentRunContainer) {
                    const plan: AgentPlan = payload;
                    
                    // 定义执行回调
                    const onExecute = (params: Record<string, any>) => {
                        vscode.postMessage({
                            command: 'agent:execute',
                            payload: { agentId: plan.agentId, parameters: params }
                        });
                    };

                    // 定义取消回调
                    const onCancel = () => {
                        // 清理父组件的状态
                        this.activeAgentRunBlock = null;
                        this.activeAgentRunContainer = null;
                        // 重新渲染，此时会因为状态已清理而显示欢迎界面
                        this.renderMessages();
                    };
                    
                    // 创建 AgentRunBlock 实例，并传入所有回调
                    this.activeAgentRunBlock = new AgentRunBlock(
                        this.activeAgentRunContainer, 
                        plan, 
                        onExecute, 
                        onCancel // 传入新的 onCancel 回调
                    );
                    return;
                }
                
                if (this.activeAgentRunBlock) {
                    switch (command) {
                        case 'agent:stepStart':
                            if (!this.isAgentRunning) { // 第一个步骤事件，标志着运行开始
                                this.isAgentRunning = true;
                                this.activeAgentRunId = payload.runId;
                                this.updateSendButtonState();
                            }
                            this.activeAgentRunBlock.updateStepExecutionStatus(payload as StepExecution);
                            return;
                        case 'agent:stepEnd':
                            this.activeAgentRunBlock.updateStepExecutionStatus(payload as StepResult);
                            return;
                        case 'agent:stepUpdate':
                            this.activeAgentRunBlock.addStepLog(payload);
                            return;
                        case 'agent:streamChunk':
                            this.activeAgentRunBlock.appendStreamChunk(payload);
                            return;
                        case 'agent:end': { // 使用块作用域
                            this.activeAgentRunBlock.setAgentResult(payload as AgentResult);
                            
                            // 对于任何终端状态，都获取其可序列化状态
                            const runRecord = this.activeAgentRunBlock.getSerializableState();

                            if (runRecord) {
                                // --- highlight-start ---
                                // 在保存前截断长字符串
                                const truncatedRecord = this.truncateLongStrings(runRecord);
                                // --- highlight-end ---

                                const agentMessage: AgentRunChatMessage = {
                                    type: 'agent_run',
                                    role: 'assistant',
                                    run: truncatedRecord as AgentRunRecord // 使用截断后的记录
                                };
                                // 将持久化消息添加到历史记录中
                                this.messages.push(agentMessage);
                                this.saveCurrentConversation();
                            }

                            // 清理实时运行状态
                            this.isAgentRunning = false;
                            this.activeAgentRunId = null;
                            this.activeAgentRunBlock = null; 
                            this.activeAgentRunContainer = null;
                            
                            // 从更新后的 messages 数组中重新渲染整个消息列表。
                            // 这将移除旧的“实时”agent block容器，并从保存的消息中
                            // 渲染一个新的、历史性的 AgentRunBlock。
                            this.renderMessages();
                            
                            this.updateSendButtonState();

                            return;
                        }
                    }
                }
            }

            switch (message.command) {
                case 'startStreaming': this.beginStream(); break;
                case 'streamData': this.appendStreamData(message.payload); break;
                case 'streamEnd': this.finalizeStream(); break;
                case 'requestFailed': this.handleRequestFailed(message.payload.error); break;
                case 'setActiveConversation': this.loadConversation(message.payload); break;
                case 'updatePrompts': this.setPrompts(message.payload); break;
                case 'updateContent': {
                    if (this.inputBox && this.inputBox.innerText !== message.payload.content) {
                        this.inputBox.innerText = message.payload.content;
                    }
                    break;
                }
                case 'clearInput': {
                    if (this.inputBox) {
                       this.inputBox.innerHTML = '';
                    }
                    break;
                }
                case 'focusEditorClosed': this.toggleMaximizeButton(false); break;
                case 'updateState':
                    if (message.payload.modelId) {
                        this.modelSelector.value = message.payload.modelId;
                    }
                    if (message.payload.promptId) {
                        this.promptSelector.value = message.payload.promptId;
                    }
                    break;
            }
        });
    }

    // --- highlight-start ---
    /**
     * 递归地遍历一个对象，并将所有长字符串截断。
     * @param obj 要处理的对象
     * @param maxLength 最大字符串长度，默认为 500
     * @returns 处理后的新对象
     */
    private truncateLongStrings(obj: any, maxLength: number = 500): any {
        if (!obj) {
            return obj;
        }

        if (Array.isArray(obj)) {
            return obj.map(item => this.truncateLongStrings(item, maxLength));
        }

        if (typeof obj === 'object') {
            const newObj: { [key: string]: any } = {};
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    newObj[key] = this.truncateLongStrings(obj[key], maxLength);
                }
            }
            return newObj;
        }

        if (typeof obj === 'string' && obj.length > maxLength) {
            return obj.substring(0, maxLength) + '... (truncated)';
        }

        return obj;
    }
    // --- highlight-end ---

    private saveCurrentConversation() {
        if (this.activeConversationId) {
            // 这是向后端发送更新后对话的请求
            // 后端 StateManager.saveConversation 会处理它
            vscode.postMessage({
                command: 'saveConversation',
                payload: {
                    id: this.activeConversationId,
                    messages: this.messages,
                    // 其他字段（如 title, createdAt）将由后端保留
                }
            });
        } else {
             // 如果是新对话，第一个Agent运行也可能触发保存
            console.warn("Attempted to save conversation, but no activeConversationId is set.");
        }
    }

    private handleSendOrSave() {
        if (this.isAgentRunning && this.activeAgentRunId) {
            vscode.postMessage({ command: 'agent:cancel', payload: { runId: this.activeAgentRunId } });
            return;
        }
        if (this.isStreaming) {
            vscode.postMessage({ command: 'stopMessage' });
            return;
        }
        
        if (this.editingMessageIndex !== null) {
            this.handleSaveEdit(this.editingMessageIndex);
        } else {
            this.handleSendMessage();
        }
    }

    private handleSendMessage() {
        if (this.isStreaming) {
            vscode.postMessage({ command: 'stopMessage' });
            return;
        }
        
        const prompt = this.inputBox.innerText.trim();
        if (!prompt) return;

        const selectedModelId = this.modelSelector.value;
        const selectedConfig = this.modelConfigs.find(c => c.id === selectedModelId);

        if (!selectedConfig) {
            vscode.postMessage({ command: 'error', payload: 'Please select a valid model from settings.' });
            return;
        }

        const message: TextChatMessage = { type: 'text', role: 'user', content: prompt };
        this.messages.push(message);
        this.renderMessages();

        this.inputBox.innerHTML = '';
        vscode.postMessage({ command: 'sendMessage', payload: { prompt, config: selectedConfig } });
    }

    private handleCopy(index: number) {
        const message = this.messages[index];
        
        if (message.type === 'text') {
            navigator.clipboard.writeText(message.content);
            vscode.postMessage({ command: 'info', payload: 'Copied to clipboard!' });
        } else {
            // 对于 Agent 运行，可以复制其最终结果或摘要
            const summary = JSON.stringify(message.run.result, null, 2);
            navigator.clipboard.writeText(summary);
             vscode.postMessage({ command: 'info', payload: 'Copied agent result summary to clipboard!' });
        }
        
    }

    private handleRegenerate(index: number) {
        vscode.postMessage({ command: 'regenerate', payload: { messageIndex: index } });
    }

    private handleEnterEditMode(index: number) {
        if (this.editingMessageIndex === index) return;
        
        const message = this.messages[index];
        if (message.type !== 'text') {
             vscode.postMessage({ command: 'info', payload: 'Agent runs cannot be edited.' });
            return; // 不允许编辑 Agent 运行
        }
        

        if (this.editingMessageIndex !== null) {
            this.handleCancelEdit();
        }

        this.editingMessageIndex = index;
        this.originalMessageContent = message.content;

        if (this.inputBox) {
            this.inputBox.innerText = this.originalMessageContent;
            this.inputBox.focus();
        }

        this.renderMessages();
        this.updateSendButtonState();
    }


    private handleCancelEdit() {
        if (this.editingMessageIndex === null) return;

        const message = this.messages[this.editingMessageIndex];
        if (this.originalMessageContent !== null && message.type === 'text') {
            message.content = this.originalMessageContent;
        }

        this.editingMessageIndex = null;
        this.originalMessageContent = null;

        if (this.inputBox) {
            this.inputBox.innerHTML = '';
        }

        this.renderMessages();
        this.updateSendButtonState();
    }

    private handleSaveEdit(index: number) {
        if (!this.inputBox) return;
        const newContent = this.inputBox.innerText.trim();
        const message = this.messages[index];
        if (newContent && message.type === 'text') {
            message.content = newContent;
            vscode.postMessage({ command: 'editMessage', payload: { messageIndex: index, content: newContent } });
        }

        this.editingMessageIndex = null;
        this.originalMessageContent = null;

        this.inputBox.innerHTML = '';

        this.renderMessages();
        this.updateSendButtonState();
    }

    private beginStream() {
        this.isStreaming = true;
        
        const assistantMessage: TextChatMessage = { type: 'text', role: 'assistant', content: '' };
        
        this.messages.push(assistantMessage);
        this.renderMessages();
        this.updateSendButtonState();
    }

    private appendStreamData(chunk: string) {
        const lastMessage = this.messages[this.messages.length - 1];
        
        if (lastMessage?.type === 'text' && lastMessage?.role === 'assistant') {
            lastMessage.content += chunk;
            this.renderMessages();
        }
        
    }


    private finalizeStream(stopped = false) {
        this.isStreaming = false;
        const lastMessage = this.messages[this.messages.length - 1];
        if (stopped && lastMessage?.type === 'text' && lastMessage?.role === 'assistant') {
            lastMessage.content += ' (Stopped)';
        }
        this.renderMessages();
        this.updateSendButtonState();
    }

    private handleRequestFailed(error: string) {
        this.finalizeStream();
        this.messages.pop();
        const lastUserMessage = this.messages.pop();

        this.renderMessages();

        if (lastUserMessage && lastUserMessage.type === 'text') {
            if (this.inputBox) this.inputBox.innerText = lastUserMessage.content;
        }

        const errorElement = document.createElement('div');
        errorElement.className = 'message-block assistant error';
        errorElement.textContent = `Error: ${error}`;
        this.messageContainer.appendChild(errorElement);
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
    }

    private handleMaximizeEditor() {
        if (this.inputBox) {
            vscode.postMessage({
                command: 'openFocusEditor',
                payload: {
                    content: this.inputBox.innerText,
                    modelId: this.modelSelector.value,
                    promptId: this.promptSelector.value
                }
            });
            this.toggleMaximizeButton(true);
        }
    }

    private toggleMaximizeButton(isMaximized: boolean) {
        const button = this.bottomPanel.querySelector('button[data-action="maximize-editor"]') as HTMLButtonElement;
        if (button) {
            if (isMaximized) {
                button.innerHTML = `<i class="codicon codicon-screen-normal"></i>`;
                button.title = '恢复至侧边栏';
            } else {
                button.innerHTML = `<i class="codicon codicon-screen-full"></i>`;
                button.title = '最大化编辑';
            }
        }
    }

    private renderMessages() {
        this.messageContainer.innerHTML = '';

        // 检查是否应该显示空状态
        if (this.messages.length === 0 && !this.activeAgentRunContainer) {
            this.messageContainer.innerHTML = this.renderEmptyState();
            return; // 显示空状态后直接返回
        }

        this.messages.forEach((msg, index) => {
            
            if (msg.type === 'agent_run') {
                // 渲染一个 AgentRunBlock
                const agentContainer = document.createElement('div');
                this.messageContainer.appendChild(agentContainer);
                // 使用 AgentRunBlock 的构造函数从历史记录中恢复
                new AgentRunBlock(agentContainer, msg.run);
            } else {
                // 渲染一个标准的 MessageBlock
                const element = new MessageBlock(msg, index).render();
                if (this.editingMessageIndex === index) {
                    element.classList.add('editing');
                }
                this.messageContainer.appendChild(element);
            }
            
        });
        
        // 如果当前有正在运行但尚未保存到 messages 数组的 Agent，它的容器也需要被处理
        if (this.activeAgentRunContainer && !this.messageContainer.contains(this.activeAgentRunContainer)) {
             this.messageContainer.appendChild(this.activeAgentRunContainer);
        }

        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
    }

    /**
     * 新增：渲染聊天视图的空状态（欢迎和引导信息）。
     * @returns 返回包含空状态内容的 HTML 字符串。
     */
    private renderEmptyState(): string {
        return `
            <div class="chat-empty-state">
                <div class="empty-state-icon">
                    <i class="codicon codicon-book"></i>
                </div>
                <h1>CodeWiki</h1>
                <h3>您的智能软件设计助手</h3>
                <div class="example-prompts">
                    <div class="example-prompt-title">您可以尝试这样开始：</div>
                    <div class="example-prompt">使用 <code>@DocGen->DocGen-Project</code> 为当前项目生成一份软件实现设计文档</div>
                    <div class="example-prompt">使用 <code>@DocGen->DocGen-Module-Direct</code> 为模块生成详细实现设计文档</div>
                    <div class="example-prompt">使用 <code>@DocGen->DocGen-Module-MapReduce</code> 用摘要总结迭代多轮的方式，为模块生成详细实现设计文档</div>
                </div>
            </div>
        `;
    }

    private renderBottomInput() {
        const container = this.bottomPanel.querySelector('.chat-input-box-container');
        if (!container) return;

        // 关键改动：使用 contenteditable div 替换 textarea
        container.innerHTML = `<div class="chat-input-box" contenteditable="true" placeholder="输入消息，或用'@'触发命令..."></div>`;
        const inputBox = container.querySelector('.chat-input-box') as HTMLElement;

        inputBox.addEventListener('keydown', (e) => {
            if (this.atCommandMenu.isVisible()) {
                this.atCommandMenu.handleKeyDown(e);
                return; // 阻止后续的 Enter 发送等行为
            }

            // 优化 Backspace 处理逻辑，使其更健壮
            if (e.key === 'Backspace') {
                const sel = window.getSelection();
                if (sel && sel.isCollapsed) {
                    const range = sel.getRangeAt(0);
                    // 此条件适用于光标位于输入框容器内，且其前方有节点（例如，在Pill之后）
                    if (range.startContainer === inputBox && range.startOffset > 0) {
                        const nodeToDelete = inputBox.childNodes[range.startOffset - 1];
                        // 检查待删除的节点是否是Pill
                        if (nodeToDelete && nodeToDelete.nodeName === 'SPAN' && (nodeToDelete as HTMLElement).classList.contains('content-pill')) {
                            e.preventDefault();
                            nodeToDelete.remove();
                            return; // 阻止默认的Backspace行为
                        }
                    }
                }
            }

            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.handleSendOrSave();
            }
        });

        inputBox.addEventListener('input', () => {
            this.handleInputForAtCommand(inputBox);
            vscode.postMessage({
                command: 'updateWebviewContent',
                payload: { content: inputBox.innerText }
            });
        });

        // 如果输入框为空，显示 placeholder
        inputBox.addEventListener('focus', () => {
             if (inputBox.getAttribute('placeholder')) {
                inputBox.removeAttribute('placeholder');
             }
        });
        inputBox.addEventListener('blur', () => {
            if (!inputBox.textContent) {
                 inputBox.setAttribute('placeholder', "输入消息，或用'@'触发命令...");
            }
        });

        this.updateSendButtonState();
    }

    /**
     * 处理输入事件，用于触发 @ 命令菜单
     */
    private handleInputForAtCommand(inputBox: HTMLElement) {
        // 1. 如果输入框中已经存在一个Pill，则不应触发@命令菜单。
        if (inputBox.querySelector('.content-pill')) {
            this.atCommandMenu.hide();
            return;
        }

        // 2. 获取整个输入框的纯文本内容。
        const text = inputBox.innerText;

        // 3. 仅当文本以 '@' 字符开头时才显示菜单。
        //    这避免了在文本中间输入'@'时触发菜单。
        if (text.startsWith('@')) {
            // 传递@后面的部分，供菜单内部使用（即使当前过滤已禁用）
            const filter = text.substring(1);
            this.atCommandMenu.show(
                filter,
                (command) => { 
                    this.handleAgentCommandSelected(command); 
                }
            );
        } else {
            this.atCommandMenu.hide();
        }
    }

    /**
     * 新增方法：处理从 @ 菜单中选择 Agent 命令的逻辑
     * @param command 选中的 CommandLeaf 对象
     */
    private handleAgentCommandSelected(command: CommandLeaf) {
        // 1. 清空输入框
        this.inputBox.innerHTML = '';
        this.atCommandMenu.hide();

        // 2. 在消息列表中创建一个新的 div 容器，作为 AgentRunBlock 的占位符
        this.activeAgentRunContainer = document.createElement('div');
        
        // 3. 关键：立即调用 renderMessages() 来更新视图
        //    这将根据新的 activeAgentRunContainer 状态清除欢迎界面
        this.renderMessages();
        
        // 确保视图滚动到底部，以便用户能看到新创建的容器
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;

        // 4. 向后端发送消息，请求这个 Agent 的执行计划
        vscode.postMessage({
            command: 'agent:getPlan',
            payload: {
                agentId: command.agentId
            }
        });
    }

    /**
     * 将选中的 Agent 命令作为 "Pill" 插入到输入框中
     */
    // 更新方法签名以接收完整的 CommandLeaf 对象
    private insertAgentPill(command: { agentId: string, name: string }) {
        // 使用更具描述性的 Pill 内容
        const pillHtml = `<span class="content-pill" contenteditable="false" data-agent-id="${command.agentId}">@${command.name}</span> `;
        
        // 清空输入框并插入 Pill
        this.inputBox.innerHTML = pillHtml;
        this.inputBox.focus();

        // 移动光标到最后
        const selection = window.getSelection();
        if (selection) {
            const range = document.createRange();
            range.selectNodeContents(this.inputBox);
            range.collapse(false); // false 表示折叠到末尾
            selection.removeAllRanges();
            selection.addRange(range);
        }

        this.atCommandMenu.hide();
    }

    private updateSendButtonState() {
        const sendButton = this.bottomPanel.querySelector<HTMLButtonElement>('button[data-action="send-or-save"]');
        if (sendButton) {
            if (this.isAgentRunning || this.isStreaming) {
                sendButton.innerHTML = `<i class="codicon codicon-stop-circle"></i> Stop`;
                sendButton.classList.add('streaming');
                sendButton.title = 'Stop Generation';
            } 
            else if (this.editingMessageIndex !== null) {
                sendButton.textContent = 'Save';
                sendButton.classList.remove('streaming');
                sendButton.title = 'Save Changes';
            } else {
                sendButton.textContent = 'Send';
                sendButton.classList.remove('streaming');
                sendButton.title = 'Send Message';
            }
        }
    }

    private renderInitialLayout(): string {
        return `
            <div class="chat-container">
                <div class="messages-list"></div>
                <div class="chat-sticky-bottom">
                    <div class="at-command-menu-container"></div>
                    <div class="chat-quick-actions">
                        <label for="model-selector">Model:</label>
                        <select id="model-selector"></select>
                        <label for="prompt-selector">Prompt:</label>
                        <select id="prompt-selector"></select>
                        <button data-action="maximize-editor" title="最大化编辑">
                            <i class="codicon codicon-screen-full"></i>
                        </button>
                        <button data-action="send-or-save">Send</button>
                    </div>
                    <div class="chat-input-box-container"></div>
                </div>
            </div>
        `;
    }

    private renderModelSelector() {
        this.modelSelector.innerHTML = '';
        const defaultModel = this.modelConfigs.find(c => c.isDefault);
        this.modelConfigs.forEach(config => {
            const option = document.createElement('option');
            option.value = config.id;
            option.textContent = config.name;
            if (defaultModel && config.id === defaultModel.id) {
                option.selected = true;
            }
            this.modelSelector.appendChild(option);
        });
    }

    private renderPromptSelector() {
        this.promptSelector.innerHTML = '<option value="">Select a prompt...</option>';
        this.prompts.forEach(prompt => {
            const option = document.createElement('option');
            option.value = prompt.id;
            option.textContent = prompt.title;
            this.promptSelector.appendChild(option);
        });
    }

    private autoResizeInput(textarea: HTMLTextAreaElement) {
        textarea.style.height = 'auto';
        const scrollHeight = textarea.scrollHeight;
        const maxHeight = 250; // Synced with main.css

        if (scrollHeight > maxHeight) {
            textarea.style.height = `${maxHeight}px`;
            textarea.style.overflowY = 'auto';
        } else {
            textarea.style.height = `${scrollHeight}px`;
            textarea.style.overflowY = 'hidden';
        }
    }
    
    // --- 新增：模拟后端处理器 ---
    private mockBackendHandler(agentId: string, agentName: string) {
        // 1. 创建 AgentRunBlock 的容器并添加到聊天列表中
        const agentRunContainer = document.createElement('div');
        this.messageContainer.appendChild(agentRunContainer);
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;

        // 2. 定义模拟的 AgentPlan 数据
        const mockPlan: AgentPlan = {
            agentId: 'docgen-project',
            agentName: '项目级文档生成',
            steps: [
                { name: "规划: 分析项目结构", description: "分析文件树，规划需要分析的核心模块。", promptFiles: ['project_planner.yml'] },
                { name: "执行: 并行分析所有模块", description: "为每个已规划的模块生成详细的文档。", promptFiles: ['module_analysis_direct.yml', 'module_analysis_mapreduce.yml']},
                { name: "综合: 生成最终文档", description: "将所有模块分析结果汇编成最终的项目设计文档。", promptFiles: ['project_synthesis.yml'] }
            ],
            parameters: [] // 项目级文档生成不需要参数
        };


        // 3. 定义执行回调，当用户点击“开始执行”时触发
        const onExecute = (params: Record<string, any>) => {
            console.log("Mock backend received execute command with params:", params);
            this.runMockExecution(agentBlock, mockPlan);
        };

        // 4. 创建 AgentRunBlock 实例，传入容器、计划和回调
        const agentBlock = new AgentRunBlock(agentRunContainer, mockPlan, onExecute);
    }
    
    // --- 新增：模拟执行流程 ---
    private runMockExecution(agentBlock: AgentRunBlock, plan: AgentPlan) {
        const runId = `run_${Date.now()}`;
        let eventIndex = 0;
        
        // 模拟从 plan.json 读取到的模块列表
        const plannedModules = [
            { name: "核心业务模块", path: "agile-boot/agile-spring-boot-starter" },
            { name: "前端控制台工具", path: "agile-boot/agile-console" },
            { name: "后台管理服务", path: "agile-boot/agile-serve-admin" },
            { name: "文件上传服务", path: "agile-boot/agile-spring-upload" },
            { name: "RESTful接口服务", path: "agile-boot/agile-serve-restful" },
            { name: "验证码服务", path: "agile-boot/agile-spring-captcha" }
        ];

        // 高保真模拟事件流
        const mockEventStream: (StepExecution | StepUpdate | StreamChunk | AgentResult)[] = [
            // === 阶段 1: 规划 ===
            { runId, taskId: 'task_plan', stepName: "规划: 分析项目结构", status: 'running' } as StepExecution,
            { runId, taskId: 'task_plan', type: 'llm-request', data: { name: '规划请求' }, metadata: { type: 'file', path: '.codewiki/runs/.../01_planning_request.txt' } } as StepUpdate,
            { runId, taskId: 'task_plan', type: 'output', data: { name: '规划响应' }, metadata: { type: 'file', path: '.codewiki/runs/.../01_planning_response.txt' } } as StepUpdate,
            { runId, taskId: 'task_plan', stepName: "规划: 分析项目结构", status: 'completed' } as StepExecution,

            // === 阶段 2: 并行分析 (父任务启动) ===
            { runId, taskId: 'task_parallel_parent', stepName: "执行: 并行分析所有模块", status: 'running' } as StepExecution,
            
            // --- 模拟所有子任务的创建 ---
            { runId, taskId: 'task_mod_1', stepName: "分析模块: '核心业务模块'", status: 'running' } as StepExecution,
            { runId, taskId: 'task_mod_2', stepName: "分析模块: '前端控制台工具'", status: 'running' } as StepExecution,
            { runId, taskId: 'task_mod_3', stepName: "分析模块: '后台管理服务'", status: 'running' } as StepExecution,
            // ... 其他模块也在这里启动

            // --- 模块 1 的完整生命周期 ---
            { runId, taskId: 'task_mod_1', type: 'llm-request', data: { name: '核心业务模块分析请求' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_agile-spring-boot-starter/llm_request.txt' } } as StepUpdate,
            // (此时UI应显示等待动画)
            { runId, taskId: 'task_mod_1', content: '### 核心业务模块\n\n该模块是系统的核心...' } as StreamChunk,
            { runId, taskId: 'task_mod_1', content: '它包含了主要的业务逻辑和实体定义。' } as StreamChunk,
            { runId, taskId: 'task_mod_1', type: 'output', data: { name: '模块文档' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_核心业务模块.md' } } as StepUpdate,
            { runId, taskId: 'task_mod_1', stepName: "分析模块: '核心业务模块'", status: 'completed' } as StepExecution,

            // --- 模块 2 的完整生命周期 ---
            { runId, taskId: 'task_mod_2', type: 'llm-request', data: { name: '前端控制台工具分析请求' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_agile-console/llm_request.txt' } } as StepUpdate,
            // (UI显示等待)
            { runId, taskId: 'task_mod_2', content: '### 前端控制台工具\n\n提供了命令行工具...' } as StreamChunk,
            { runId, taskId: 'task_mod_2', type: 'output', data: { name: '模块文档' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_前端控制台工具.md' } } as StepUpdate,
            { runId, taskId: 'task_mod_2', stepName: "分析模块: '前端控制台工具'", status: 'completed' } as StepExecution,

            // ... (模块3 及以后同理)
            { runId, taskId: 'task_mod_3', type: 'llm-request', data: { name: '后台管理服务分析请求' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_agile-serve-admin/llm_request.txt' } } as StepUpdate,
            { runId, taskId: 'task_mod_3', type: 'output', data: { name: '模块文档' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_后台管理服务.md' } } as StepUpdate,
            { runId, taskId: 'task_mod_3', stepName: "分析模块: '后台管理服务'", status: 'completed' } as StepExecution,


            // === 阶段 2: 并行分析 (父任务完成) ===
            { runId, taskId: 'task_parallel_parent', stepName: "执行: 并行分析所有模块", status: 'completed' } as StepExecution,
            
            // === 阶段 3: 综合 (也遵循完整周期) ===
            { runId, taskId: 'task_synthesis', stepName: "综合: 生成最终文档", status: 'running' } as StepExecution,
            { runId, taskId: 'task_synthesis', type: 'llm-request', data: { name: '综合请求' }, metadata: { type: 'file', path: '.codewiki/runs/.../03_synthesis_request.txt' } } as StepUpdate,
            // (UI显示等待)
            { runId, taskId: 'task_synthesis', content: '# Agile-Boot 项目总体设计文档\n\n' } as StreamChunk,
            { runId, taskId: 'task_synthesis', content: '本文档旨在提供Agile-Boot项目的整体架构...' } as StreamChunk,
            { runId, taskId: 'task_synthesis', stepName: "综合: 生成最终文档", status: 'completed' } as StepExecution,

            // === 最终结果 ===
            { runId, status: 'completed', finalOutput: "项目总体设计文档.md 已生成。" } as AgentResult
        ];


        const intervalId = setInterval(() => {
            if (eventIndex >= mockEventStream.length) {
                clearInterval(intervalId);
                return;
            }

            const event = mockEventStream[eventIndex++];
            
            
            // 更稳健的类型检查和派发，修复了原有逻辑错误
            if ('stepName' in event && 'status' in event && 'runId' in event) {
                // 这是 StepExecution 事件
                agentBlock.updateStepExecutionStatus(event as StepExecution | StepResult); 
            } else if ('status' in event && 'runId' in event && !('stepName' in event)) {
                // 这是 AgentResult 事件
                 agentBlock.setAgentResult(event as AgentResult);
            } else if ('type' in event && 'data' in event) {
                // 这是 StepUpdate 事件
                agentBlock.addStepLog(event as StepUpdate);
            } else if ('content' in event && !('role' in event)) {
                // 这是 StreamChunk 事件
                 agentBlock.appendStreamChunk(event as StreamChunk);
            }
            

        }, 3000); // 每 800 毫秒发送一个事件
    }
}

--------------------------------------------------------------------------------

--- file_path: webview/views/FocusEditorView.ts ---
import { vscode } from "../vscode";
import { ModelConfig, Prompt } from "../../common/types";

export class FocusEditorView {
    private parent: HTMLElement;
    private modelConfigs: ModelConfig[] = [];
    private prompts: Prompt[] = [];
    private modelSelector: HTMLSelectElement;
    private promptSelector: HTMLSelectElement;
    private textarea: HTMLTextAreaElement;

    constructor(container: HTMLElement, initialData: { content: string, modelId?: string, promptId?: string }) {
        this.parent = container;
        this.parent.innerHTML = this.render();
        
        this.modelSelector = this.parent.querySelector('#model-selector') as HTMLSelectElement;
        this.promptSelector = this.parent.querySelector('#prompt-selector') as HTMLSelectElement;
        this.textarea = this.parent.querySelector('textarea') as HTMLTextAreaElement;

        this.textarea.value = initialData.content;
        if (initialData.modelId) {
            this.modelSelector.value = initialData.modelId;
        }
        if (initialData.promptId) {
            this.promptSelector.value = initialData.promptId;
        }

        this.setupEventListeners();
    }

    public render(): string {
        return `
            <div class="focus-editor-container">
                <div class="chat-quick-actions">
                    <label for="model-selector">Model:</label>
                    <select id="model-selector"></select>
                    <label for="prompt-selector">Prompt:</label>
                    <select id="prompt-selector"></select>
                    <button data-action="minimize-editor" title="恢复至侧边栏">
                        <i class="codicon codicon-screen-normal"></i>
                    </button>
                    <button data-action="send-message">Send</button>
                </div>
                <div class="chat-input-box-container">
                     <textarea placeholder="输入消息，或从下拉菜单选择提示词..."></textarea>
                </div>
            </div>
        `;
    }

    private setupEventListeners() {
        this.parent.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            const button = target.closest('button');
            if (!button) return;

            const action = button.dataset.action;
            switch (action) {
                case 'send-message':
                    this.handleSendMessage();
                    break;
                case 'minimize-editor':
                    vscode.postMessage({ command: 'closeFocusEditor' });
                    break;
            }
        });

        this.modelSelector.addEventListener('change', () => {
            vscode.postMessage({
                command: 'syncStateChange',
                payload: { modelId: this.modelSelector.value }
            });
        });

        this.promptSelector.addEventListener('change', () => {
            const selectedPromptId = this.promptSelector.value;
            vscode.postMessage({
                command: 'syncStateChange',
                payload: { promptId: selectedPromptId }
            });
        });

        this.textarea.addEventListener('input', () => {
            vscode.postMessage({
                command: 'updateWebviewContent',
                payload: { content: this.textarea.value }
            });
        });

        this.textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.handleSendMessage();
            }
        });

        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.command) {
                case 'updateState':
                    this.updateState(message.payload);
                    break;
                case 'updatePrompts':
                    this.setPrompts(message.payload);
                    break;
                case 'updateContent':
                    this.updateContent(message.payload.content);
                    break;
            }
        });
    }

    public setModelConfigs(configs: ModelConfig[]) {
        this.modelConfigs = configs;
        const currentVal = this.modelSelector.value;
        this.renderModelSelector();
        this.modelSelector.value = currentVal;
    }

    public setPrompts(prompts: Prompt[]) {
        this.prompts = prompts;
        const currentVal = this.promptSelector.value;
        this.renderPromptSelector();
        this.promptSelector.value = currentVal;
    }

    public updateContent(content: string) {
        if (this.textarea.value !== content) {
            this.textarea.value = content;
        }
    }

    public updateState(state: { modelId?: string, promptId?: string }) {
        if (state.modelId) {
            this.modelSelector.value = state.modelId;
        }
        if (state.promptId) {
            this.promptSelector.value = state.promptId;
        }
    }

    public clearInput() {
        this.textarea.value = '';
    }

    private handleSendMessage() {
        const prompt = this.textarea.value.trim();
        if (prompt) {
            const selectedModelId = this.modelSelector.value;
            const selectedConfig = this.modelConfigs.find(c => c.id === selectedModelId);

            if (!selectedConfig) {
                vscode.postMessage({ command: 'error', payload: 'Please select a valid model from settings.' });
                return;
            }
            
            vscode.postMessage({ command: 'sendMessage', payload: { prompt, config: selectedConfig } });
            this.clearInput();
        }
    }

    private renderModelSelector() {
        this.modelSelector.innerHTML = '';
        const defaultModel = this.modelConfigs.find(c => c.isDefault);
        this.modelConfigs.forEach(config => {
            const option = document.createElement('option');
            option.value = config.id;
            option.textContent = config.name;
            if (defaultModel && config.id === defaultModel.id) {
                option.selected = true;
            }
            this.modelSelector.appendChild(option);
        });
    }

    private renderPromptSelector() {
        this.promptSelector.innerHTML = '<option value="">Select a prompt...</option>';
        this.prompts.forEach(prompt => {
            const option = document.createElement('option');
            option.value = prompt.id;
            option.textContent = prompt.title;
            this.promptSelector.appendChild(option);
        });
    }

}


--------------------------------------------------------------------------------

--- file_path: webview/views/PerformanceSettingsView.ts ---
// --- file_path: webview/views/PerformanceSettingsView.ts ---
import { PerformanceConfig } from "../../common/types";
import { vscode } from "../vscode";

export class PerformanceSettingsView {
    private config: PerformanceConfig | null = null;

    constructor(private readonly parent: HTMLElement) {
        // 初始渲染为空，等待数据
        this.parent.innerHTML = '';
        this.setupEventListeners();
    }

    public setPerformanceConfig(config: PerformanceConfig) {
        this.config = config;
        this.render();
    }

    private setupEventListeners() {
        this.parent.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            const button = target.closest('button');
            if (!button || !button.matches('.btn-save-perf')) return;

            this.saveConfig();
        });
    }

    private saveConfig() {
        const form = this.parent.querySelector('#perf-config-form') as HTMLFormElement;
        if (!form || !this.config) return;

        const newConfig: PerformanceConfig = {
            concurrencyLimit: parseInt((form.querySelector('input[name="concurrencyLimit"]') as HTMLInputElement).value, 10) || this.config.concurrencyLimit,
            minInterval: parseInt((form.querySelector('input[name="minInterval"]') as HTMLInputElement).value, 10) || this.config.minInterval,
            maxTokensPerBatch: parseInt((form.querySelector('input[name="maxTokensPerBatch"]') as HTMLInputElement).value, 10) || this.config.maxTokensPerBatch,
            maxTokensForDirectAnalysis: parseInt((form.querySelector('input[name="maxTokensForDirectAnalysis"]') as HTMLInputElement).value, 10) || this.config.maxTokensForDirectAnalysis,
        };

        vscode.postMessage({ command: 'savePerformanceConfig', payload: newConfig });
        vscode.postMessage({ command: 'info', payload: 'Performance settings saved.' });
    }

    private render() {
        if (!this.config) {
            this.parent.innerHTML = `<p>Loading performance settings...</p>`;
            return;
        }

        this.parent.innerHTML = `
            <div class="settings-container">
                <div class="view-header">
                    <h2>性能与限制设置</h2>
                </div>
                <form class="config-form" id="perf-config-form">
                    <div class="form-group">
                        <label for="concurrencyLimit">LLM 最大并发请求数</label>
                        <input type="number" id="concurrencyLimit" name="concurrencyLimit" value="${this.config.concurrencyLimit}">
                        <div class="form-group-description">同时向语言模型发送的最大请求数量。较低的值可以避免超出 API 速率限制。</div>
                    </div>
                    <div class="form-group">
                        <label for="minInterval">LLM 请求最小间隔 (毫秒)</label>
                        <input type="number" id="minInterval" name="minInterval" value="${this.config.minInterval}">
                        <div class="form-group-description">两次连续的 LLM 请求之间的最小时间间隔，用于控制请求频率。</div>
                    </div>
                    <div class="form-group">
                        <label for="maxTokensPerBatch">Map-Reduce 每批最大 Token 数</label>
                        <input type="number" id="maxTokensPerBatch" name="maxTokensPerBatch" value="${this.config.maxTokensPerBatch}">
                        <div class="form-group-description">在使用 Map-Reduce 策略分析大模块时，每个批次包含的最大 Token 数量。</div>
                    </div>
                    <div class="form-group">
                        <label for="maxTokensForDirectAnalysis">直接分析最大 Token 阈值</label>
                        <input type="number" id="maxTokensForDirectAnalysis" name="maxTokensForDirectAnalysis" value="${this.config.maxTokensForDirectAnalysis}">
                        <div class="form-group-description">当模块总 Token 数低于此值时，将使用直接分析策略，否则切换到 Map-Reduce。</div>
                    </div>
                    <div class="form-actions">
                        <button type="button" class="btn-save-perf">保存设置</button>
                    </div>
                </form>
            </div>
        `;
    }
}

--------------------------------------------------------------------------------

--- file_path: webview/views/PromptEditorView.ts ---
import { Prompt } from '../../common/types';
import { vscode } from '../vscode';

export class PromptEditorView {
    private element: HTMLElement;
    private prompt: Prompt | null = null;
    private isDirty = false;

    constructor(private readonly parent: HTMLElement) {
        this.element = document.createElement('div');
        this.element.className = 'prompt-editor-view';
        this.parent.appendChild(this.element);
    }

    public show(prompt?: Prompt) {
        this.prompt = prompt ? { ...prompt } : null;
        this.isDirty = false;
        this.render();
        this.addEventListeners();
        this.element.style.display = 'flex';
    }

    public hide() {
        if (this.isDirty) {
            const confirmation = window.confirm('您有未保存的更改，确定要放弃吗？');
            if (!confirmation) {
                return;
            }
        }
        this.element.style.display = 'none';
        this.element.innerHTML = '';
        // Let the extension handle the navigation
        vscode.postMessage({ command: 'cancelPromptEdit' });
    }

    private render() {
        const title = this.prompt?.title ?? '';
        const content = this.prompt?.content ?? '';
        const headerTitle = this.prompt ? `编辑: ${title}` : '新建提示词';

        this.element.innerHTML = `
            <div class="view-header">
                <h3>${headerTitle}</h3>
                <div class="actions">
                    <button id="save-prompt-btn" class="codicon-btn">
                        <i class="codicon codicon-save"></i>
                        <span>保存</span>
                    </button>
                    <button id="cancel-prompt-edit-btn" class="codicon-btn secondary">
                        <i class="codicon codicon-close"></i>
                        <span>取消</span>
                    </button>
                </div>
            </div>
            <div class="prompt-editor-form">
                <div class="form-group">
                    <label for="prompt-title">标题</label>
                    <input type="text" id="prompt-title" value="${title}" required>
                </div>
                <div class="form-group">
                    <label for="prompt-content">内容</label>
                    <textarea id="prompt-content" rows="15">${content}</textarea>
                </div>
            </div>
        `;
    }

    private addEventListeners() {
        const saveBtn = this.element.querySelector('#save-prompt-btn');
        const cancelBtn = this.element.querySelector('#cancel-prompt-edit-btn');
        const titleInput = this.element.querySelector('#prompt-title') as HTMLInputElement;
        const contentTextArea = this.element.querySelector('#prompt-content') as HTMLTextAreaElement;

        const markDirty = () => { this.isDirty = true; };
        titleInput.addEventListener('input', markDirty);
        contentTextArea.addEventListener('input', markDirty);

        if (saveBtn) {
            saveBtn.addEventListener('click', () => {
                if (!titleInput.value.trim()) {
                    vscode.postMessage({ command: 'showError', payload: '标题不能为空。' });
                    return;
                }

                const now = new Date().toISOString();
                const promptToSave: Prompt = {
                    id: this.prompt?.id || `prompt_${Date.now()}`,
                    title: titleInput.value.trim(),
                    content: contentTextArea.value,
                    createdAt: this.prompt?.createdAt || now,
                    updatedAt: now,
                };

                vscode.postMessage({ command: 'savePrompt', payload: promptToSave });
                this.isDirty = false;
            });
        }

        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                this.hide();
            });
        }
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/PromptManagerView.ts ---
import { Prompt } from '../../common/types';
import { vscode } from '../vscode';

export class PromptManagerView {
    private prompts: Prompt[] = [];
    private filteredPrompts: Prompt[] = [];
    private element: HTMLElement;

    constructor(private readonly parent: HTMLElement) {
        this.element = document.createElement('div');
        this.element.className = 'prompt-manager-view';
        this.parent.appendChild(this.element);
        this.render();
        this.addEventListeners();
    }

    public update(prompts: Prompt[]) {
        this.prompts = prompts.sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
        this.filteredPrompts = [...this.prompts];
        this.render();
        this.addEventListeners();
    }

    public getPrompts(): Prompt[] {
        return this.prompts;
    }

    private render() {
        this.element.innerHTML = `
            <div class="view-header">
                <div class="search-bar">
                    <i class="codicon codicon-search"></i>
                    <input type="text" id="prompt-search-input" placeholder="搜索提示词...">
                </div>
                <button id="new-prompt-btn" class="codicon-btn">
                    <i class="codicon codicon-add"></i>
                    <span>新建提示词</span>
                </button>
            </div>
            <div class="prompt-list-container">
                ${this.filteredPrompts.length > 0 ? this.renderList() : this.renderEmptyState()}
            </div>
        `;
    }

    private renderList(): string {
        return `
            <ul class="prompt-list">
                ${this.filteredPrompts.map(prompt => this.renderListItem(prompt)).join('')}
            </ul>
        `;
    }

    private renderListItem(prompt: Prompt): string {
        const summary = prompt.content.substring(0, 100) + (prompt.content.length > 100 ? '...' : '');
        const lastUpdated = new Date(prompt.updatedAt).toLocaleString();

        return `
            <li class="prompt-list-item" data-id="${prompt.id}">
                <div class="prompt-item-main">
                    <div class="prompt-item-title">${prompt.title}</div>
                    <div class="prompt-item-summary">${summary}</div>
                </div>
                <div class="prompt-item-meta">
                    <div class="prompt-item-time">${lastUpdated}</div>
                    <div class="prompt-item-actions">
                        <button class="icon-btn edit-prompt-btn" data-id="${prompt.id}" title="编辑">
                            <i class="codicon codicon-edit"></i>
                        </button>
                        <button class="icon-btn delete-prompt-btn" data-id="${prompt.id}" title="删除">
                            <i class="codicon codicon-trash"></i>
                        </button>
                    </div>
                </div>
            </li>
        `;
    }

    private renderEmptyState(): string {
        return `
            <div class="empty-state">
                <p>您还没有任何提示词模板，点击“新建提示词”来创建第一个吧！</p>
                <button id="new-prompt-btn-empty" class="highlighted-btn">新建提示词</button>
            </div>
        `;
    }

    private addEventListeners() {
        // New prompt button
        const newPromptBtn = this.element.querySelector('#new-prompt-btn');
        if (newPromptBtn) {
            newPromptBtn.addEventListener('click', () => {
                vscode.postMessage({ command: 'newPrompt' });
            });
        }
        const newPromptBtnEmpty = this.element.querySelector('#new-prompt-btn-empty');
        if (newPromptBtnEmpty) {
            newPromptBtnEmpty.addEventListener('click', () => {
                vscode.postMessage({ command: 'newPrompt' });
            });
        }

        // Search input
        const searchInput = this.element.querySelector('#prompt-search-input') as HTMLInputElement;
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                const searchTerm = (e.target as HTMLInputElement).value.toLowerCase();
                this.filteredPrompts = this.prompts.filter(p => 
                    p.title.toLowerCase().includes(searchTerm) || 
                    p.content.toLowerCase().includes(searchTerm)
                );
                this.render();
                this.addEventListeners();
            });
        }

        // List item clicks
        this.element.querySelectorAll('.prompt-list-item').forEach(item => {
            item.addEventListener('click', (e) => {
                const target = e.target as HTMLElement;
                // Don't trigger edit if clicking on a button
                if (!target.closest('button')) {
                    const promptId = item.getAttribute('data-id');
                    if (promptId) {
                        vscode.postMessage({ command: 'editPrompt', payload: { id: promptId } });
                    }
                }
            });
        });

        // Edit buttons
        this.element.querySelectorAll('.edit-prompt-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const promptId = (btn as HTMLElement).dataset.id;
                if (promptId) {
                    vscode.postMessage({ command: 'editPrompt', payload: { id: promptId } });
                }
            });
        });

        // Delete buttons
        this.element.querySelectorAll('.delete-prompt-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const promptId = (btn as HTMLElement).dataset.id;
                if (promptId) {
                    vscode.postMessage({ command: 'deletePrompt', payload: { id: promptId } });
                }
            });
        });
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/SettingsView.ts ---
import { ModelConfig } from "../../common/types";
import { vscode } from "../vscode";

export class SettingsView {
    private configs: ModelConfig[] = [];

    constructor(private readonly parent: HTMLElement) {
        this.render();
        this.setupEventListeners();
    }

    public setModelConfigs(configs: ModelConfig[]) {
        this.configs = configs;
        this.render();
    }

    public getModelConfigs(): ModelConfig[] {
        return this.configs;
    }

    private setupEventListeners() {
        this.parent.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            const button = target.closest('button');
            if (!button) return;

            const id = button.dataset.id;
            if (button.matches('.btn-add-model')) {
                this.addEmptyConfigForm();
            } else if (button.matches('.btn-save-model')) {
                this.saveConfig(id);
            } else if (button.matches('.btn-delete-model')) {
                this.deleteConfig(id);
            } else if (button.matches('.btn-set-default')) {
                this.setDefault(id);
            }
        });
    }

    private addEmptyConfigForm() {
        const newConfig: ModelConfig = { 
            id: `new-${Date.now()}`, 
            name: '', 
            baseUrl: '', 
            apiKey: '', 
            modelId: '',
            isDefault: this.configs.length === 0 
        };
        this.configs.push(newConfig);
        this.render();
    }

    private saveAllConfigs() {
        vscode.postMessage({ command: 'saveModelConfigs', payload: this.configs });
    }

    private setDefault(id?: string) {
        if (!id) return;
        this.configs.forEach(c => c.isDefault = c.id === id);
        this.saveAllConfigs();
        this.render();
    }

    private saveConfig(id?: string) {
        if (!id) return;
        const form = this.parent.querySelector(`#config-form-${id}`) as HTMLFormElement;
        if (!form) return;

        const name = (form.querySelector('input[name="name"]') as HTMLInputElement).value;
        const baseUrl = (form.querySelector('input[name="baseUrl"]') as HTMLInputElement).value;
        const apiKey = (form.querySelector('input[name="apiKey"]') as HTMLInputElement).value;
        const modelId = (form.querySelector('input[name="modelId"]') as HTMLInputElement).value;

        const index = this.configs.findIndex(c => c.id === id);
        if (index === -1) return;

        const isNew = id.startsWith('new-');
        const newId = isNew ? `model-${Date.now()}` : id;
        
        this.configs[index] = { ...this.configs[index], id: newId, name, baseUrl, apiKey, modelId };
        
        this.saveAllConfigs();
    }

    private deleteConfig(id?: string) {
        if (!id) return;
        this.configs = this.configs.filter(c => c.id !== id);
        // If the deleted model was the default, make the first one default
        if (this.configs.length > 0 && !this.configs.some(c => c.isDefault)) {
            this.configs[0].isDefault = true;
        }
        this.saveAllConfigs();
    }

    private render() {
        this.parent.innerHTML = `
            <div class="settings-container">
                <div class="view-header">
                    <h2>Model Settings</h2>
                    <button class="btn-add-model add-btn" title="Add new model configuration">
                        <i class="codicon codicon-add"></i>
                    </button>
                </div>
                <div id="model-configs-list">
                    ${this.configs.map(config => this.renderConfigForm(config)).join('')}
                </div>
            </div>
        `;
    }

    private renderConfigForm(config: ModelConfig): string {
        return `
            <form class="config-form" id="config-form-${config.id}" data-id="${config.id}">
                <div class="form-header">
                    <strong class="form-title">${config.name || 'New Model'}</strong>
                    ${config.isDefault ? '<span class="default-badge">Default</span>' : ''}
                </div>
                <div class="form-group">
                    <label for="name-${config.id}">Model Name</label>
                    <input type="text" id="name-${config.id}" name="name" placeholder="e.g., GPT-4o" value="${config.name}">
                </div>
                <div class="form-group">
                    <label for="baseUrl-${config.id}">Base URL</label>
                    <input type="text" id="baseUrl-${config.id}" name="baseUrl" placeholder="https://api.openai.com/v1" value="${config.baseUrl}">
                </div>
                <div class="form-group">
                    <label for="apiKey-${config.id}">API Key</label>
                    <input type="password" id="apiKey-${config.id}" name="apiKey" placeholder="sk-..." value="${config.apiKey}">
                </div>
                <div class="form-group">
                    <label for="modelId-${config.id}">Model ID</label>
                    <input type="text" id="modelId-${config.id}" name="modelId" placeholder="gpt-4o" value="${config.modelId}">
                </div>
                <div class="form-actions">
                    <button type="button" class="btn-save-model" data-id="${config.id}">Save</button>
                    <button type="button" class="btn-delete-model" data-id="${config.id}">Delete</button>
                    ${!config.isDefault ? `<button type="button" class="btn-set-default" data-id="${config.id}">Set as Default</button>` : ''}
                </div>
            </form>
        `;
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/WelcomeView.ts ---
export class WelcomeView {
    constructor(private readonly parent: HTMLElement) {
        this.parent.innerHTML = this.render();
    }

    private render(): string {
        return `
            <div class="welcome-container">
                <h2>Welcome to CodeWiki</h2>
                <p>Your intelligent assistant for software design.</p>
                <button id="btn-new-chat">New Chat</button>
            </div>
        `;
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/vscode.ts ---
import type { PostMessage } from '../common/types';

/**
 * A typed wrapper around the VS Code API that is exposed to the webview.
 */
interface VsCodeApi {
    postMessage(message: PostMessage): void;
    getState(): any;
    setState(newState: any): void;
}

declare const acquireVsCodeApi: () => VsCodeApi;

export const vscode = acquireVsCodeApi();


--------------------------------------------------------------------------------
toolchainExecutor为啥最终的输出output是嵌套的llm-request块里的，哪里逻辑错了，给我分析一下。按说output是要和llm-request平级的卡片
比如在step1里，input和output就是平级的，为啥这两个不是，分析一下根本原因
不要把