================================================================================
项目结构 (基于过滤规则):
src
├── common
│   └── types.ts
├── extension
│   ├── agents
│   │   ├── executors
│   │   │   ├── MapReduceExecutor.ts
│   │   │   └── ToolChainExecutor.ts
│   │   ├── orchestrators
│   │   │   └── ProjectDocumentationOrchestrator.ts
│   │   ├── AgentContext.ts
│   │   └── CustomAgentExecutor.ts
│   ├── config
│   │   └── fileFilters.ts
│   ├── services
│   │   ├── AgentService.ts
│   │   ├── LLMService.ts
│   │   ├── StatsTracker.ts
│   │   ├── ToolRegistry.ts
│   │   └── logging.ts
│   ├── tools
│   │   ├── fileSystemTools.ts
│   │   └── llmTools.ts
│   ├── CodeWikiViewProvider.ts
│   ├── StateManager.ts
│   └── extension.ts
├── test
│   └── suite
│       └── index.ts
└── webview
    ├── components
    │   ├── AgentRunBlock.ts
    │   ├── AtCommandMenu.ts
    │   └── MessageBlock.ts
    ├── css
    │   └── main.css
    ├── views
    │   ├── App.ts
    │   ├── ChatHistoryView.ts
    │   ├── ChatView.ts
    │   ├── FocusEditorView.ts
    │   ├── PromptEditorView.ts
    │   ├── PromptManagerView.ts
    │   ├── SettingsView.ts
    │   └── WelcomeView.ts
    ├── main.ts
    └── vscode.ts
================================================================================

--- file_path: common/types.ts ---
/**
 * Defines the structure for messages posted between the Webview and the Extension Host.
 */
export interface PostMessage {
    command: string;
    payload?: any;
}

/**
 * Represents the configuration for a single language model.
 */
export interface ModelConfig {
    id: string;
    name: string;
    baseUrl: string;
    apiKey: string;
    modelId: string;
    isDefault?: boolean;
}

/**
 * Represents a single message in a conversation, from either the user or the model (assistant).
 */
export interface ChatMessage {
    role: 'user' | 'assistant';
    content: string;
    // Additional metadata can be added here, e.g., timestamps, message ID, etc.
}

/**
 * Represents a full conversation, including its ID, title, and all messages.
 */
export interface Conversation {
    id: string;
    title: string;
    messages: ChatMessage[];
    createdAt: string; // ISO 8601 date string
}

/**
 * Represents a reusable prompt template.
 */
export interface Prompt {
    id: string;
    title: string;
    content: string;
    createdAt: string; // ISO 8601 date string
    updatedAt: string; // ISO 8601 date string
}

/**
 * =======================================================================
 * Agent Execution Event & Plan Types (新增)
 * =======================================================================
 */

/**
 * 定义了一个Agent执行计划中的单个步骤。
 */
export interface AgentPlanStep {
    name: string;
    description: string;
    promptFiles?: string[]; // 使用的YML文件名
}

/**
 * 描述了Agent的完整执行计划。
 */
export interface AgentPlan {
    agentName: string;
    agentId: string;
    steps: AgentPlanStep[];
    parameters: { // 需要用户输入的参数
        name: string;
        description: string;
        type: 'path' | 'string';
        value?: any; // 解析后的或用户输入的值
        isValid?: boolean;
        error?: string;
    }[];
}

/**
 * 代表一个正在执行的步骤或子任务。
 */
export interface StepExecution {
    runId: string; // 整个Agent运行的唯一ID
    stepName: string; //
    taskId?: string; // 并行任务中，子任务的唯一ID
    status: 'running' | 'completed' | 'failed' | 'waiting';
}

/**
 * 用于更新一个正在执行的步骤的信息。
 */
export interface StepUpdate {
    runId: string;
    taskId?: string;
    type: 'input' | 'output' | 'llm-request' | 'status';
    data: any;
    metadata?: Record<string, any>; // 例如 { type: 'file', path: '...' }
}

/**
 * 代表一个步骤或子任务的最终结果。
 */
export interface StepResult {
    runId: string;
    stepName: string; // <-- 新增: 确保步骤名称被传递
    taskId?: string; //
    status: 'completed' | 'failed';
    output?: any;
    error?: string;
}

/**
 * 代表一个LLM流式响应的数据块。
 */
export interface StreamChunk {
    runId: string;
    taskId?: string;
    content: string;
}

/**
 * 代表整个Agent运行的最终结果。
 */
export interface AgentResult {
    runId: string;
    status: 'completed' | 'failed' | 'cancelled';
    finalOutput?: any;
    error?: string;
    // highlight-start
    stats?: {
        duration: string;
        totalTokens: number;
        promptTokens: number;
        completionTokens: number;
    };
    // highlight-end
}

--------------------------------------------------------------------------------

--- file_path: extension/CodeWikiViewProvider.ts ---
// src/extension/CodeWikiViewProvider.ts (修改后完整文件)

import * as vscode from 'vscode';
import { PostMessage, Conversation, ChatMessage, Prompt, ModelConfig, AgentPlan } from '../common/types'; // AgentPlan 可能也需要
import { StateManager } from './StateManager';
import { LLMService } from './services/LLMService';
import { AgentService } from './services/AgentService';
import { v4 as uuidv4 } from 'uuid';
import * as yaml from 'js-yaml';
import { WebviewLogger } from './services/logging';
import * as path from 'path';

export class CodeWikiViewProvider implements vscode.WebviewViewProvider {

    public static readonly viewType = 'codewiki.mainView';

    private _view?: vscode.WebviewView;
    private _focusEditorView?: vscode.WebviewPanel;
    private _stateManager: StateManager;
    private _llmService: LLMService;
    private _agentService: AgentService; // <-- 新增 AgentService 成员
    private _activeConversation: Conversation | null = null;

    constructor(
        private readonly _extensionUri: vscode.Uri,
        private readonly _context: vscode.ExtensionContext,
        agentService: AgentService // <-- 注入 AgentService
    ) {
        this._stateManager = new StateManager(this._context.globalState);
        this._llmService = new LLMService();
        this._agentService = agentService; // <-- 保存注入的实例
    }

    // initializeTools 方法被移除，其功能已移至 AgentService 和 ToolRegistry

    public resolveWebviewView(
        webviewView: vscode.WebviewView,
        context: vscode.WebviewViewResolveContext,
        _token: vscode.CancellationToken,
    ) {
        this._view = webviewView;

        webviewView.webview.options = {
            // Allow scripts in the webview
            enableScripts: true,

            localResourceRoots: [
                this._extensionUri
            ]
        };

        webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

        webviewView.webview.onDidReceiveMessage((data: PostMessage) => {
            this.handleMessage(data, 'sidebar');
        });
    }

    private async handleMessage(data: PostMessage, source: 'sidebar' | 'focus-editor' = 'sidebar') {
        const webview = (source === 'sidebar' && data.command.startsWith('agent:'))
            ? this._view?.webview
            : (source === 'focus-editor')
                ? this._focusEditorView?.webview
                : this._view?.webview; // 默认或非 agent 命令使用主视图

        // 对于 Agent 命令，我们强制它必须来自主视图，并检查 webview 是否存在
        if (data.command.startsWith('agent:')) {
            if (!this._view?.webview) {
                console.error("Agent command received but main webview is not available.");
                return;
            }
        }
        const sourceWebview = (source === 'focus-editor') ? this._focusEditorView?.webview : this._view?.webview;

        switch (data.command) {
            case 'ready':
                {
                    const sourceWebview = (source === 'focus-editor') ? this._focusEditorView?.webview : this._view?.webview;
                    if (!sourceWebview) break;

                    const conversations = await this._stateManager.getConversations();
                    const modelConfigs = await this._stateManager.getModelConfigs();
                    const prompts = await this._stateManager.getPrompts();

                    // If there are conversations, set the most recent one as active.
                    if (source === 'sidebar' && conversations.length > 0) {
                        if (!this._activeConversation) { // 避免覆盖已激活的对话
                            this._activeConversation = conversations[conversations.length - 1];
                        }
                    }

                    sourceWebview.postMessage({
                        command: 'initialize',
                        payload: {
                            conversations,
                            modelConfigs,
                            prompts
                        }
                    });
                    break;
                }
            case 'openFocusEditor':
                {
                    const { content, modelId, promptId } = data.payload;
                    if (this._focusEditorView) {
                        this._focusEditorView.reveal(vscode.ViewColumn.One);
                    } else {
                        this._focusEditorView = vscode.window.createWebviewPanel(
                            'codewiki.focusEditor',
                            'Focus Editor',
                            vscode.ViewColumn.One,
                            {
                                enableScripts: true,
                                localResourceRoots: [this._extensionUri]
                            }
                        );

                        this._focusEditorView.webview.html = this._getHtmlForWebview(this._focusEditorView.webview);

                        this._focusEditorView.onDidDispose(() => {
                            this._focusEditorView = undefined;
                            this._view?.webview.postMessage({ command: 'focusEditorClosed' });
                        }, null, this._context.subscriptions);

                        this._focusEditorView.webview.onDidReceiveMessage((msg) => this.handleMessage(msg, 'focus-editor'));
                    }

                    const modelConfigs = await this._stateManager.getModelConfigs();
                    const prompts = await this._stateManager.getPrompts();

                    // 将所有需要的数据一次性发送过去
                    this._focusEditorView.webview.postMessage({
                        command: 'showFocusEditor',
                        payload: {
                            content,
                            modelId,
                            promptId,
                            modelConfigs, // 捆绑模型数据
                            prompts       // 捆绑提示词数据
                        }
                    });
                    break;
                }
            case 'closeFocusEditor':
                {
                    this._focusEditorView?.dispose();
                    break;
                }
            case 'updateWebviewContent':
                {
                    const { content } = data.payload;
                    if (source === 'sidebar') {
                        this._focusEditorView?.webview.postMessage({ command: 'updateContent', payload: { content } });
                    } else { // source === 'focus-editor'
                        this._view?.webview.postMessage({ command: 'updateContent', payload: { content } });
                    }
                    break;
                }
            case 'syncStateChange':
                {
                    if (source === 'sidebar') {
                        this._focusEditorView?.webview.postMessage({ command: 'updateState', payload: data.payload });
                    } else { // source === 'focus-editor'
                        this._view?.webview.postMessage({ command: 'updateState', payload: data.payload });
                    }
                    break;
                }
            case 'newChat':
                {
                    this._activeConversation = null;
                    // Potentially clear the webview chat here if needed
                    break;
                }
            case 'info':
                {
                    vscode.window.showInformationMessage(data.payload);
                    break;
                }
            case 'error':
                {
                    vscode.window.showErrorMessage(data.payload);
                    break;
                }
            case 'sendMessage':
                {
                    // When a message is sent from either view, clear the input in the other.
                    if (source === 'sidebar') {
                        this._focusEditorView?.webview.postMessage({ command: 'clearInput' });
                    } else {
                        this._view?.webview.postMessage({ command: 'clearInput' });
                    }

                    const { prompt, config } = data.payload;
                    const userMessage: ChatMessage = { role: 'user', content: prompt };
                    let modelMessage: ChatMessage = { role: 'assistant', content: '' };

                    // Ensure there is an active conversation
                    if (!this._activeConversation) {
                        this._activeConversation = {
                            id: uuidv4(),
                            title: prompt.substring(0, 50), // Add title
                            messages: [],
                            createdAt: new Date().toISOString(),
                        };
                    }

                    this._activeConversation.messages.push(userMessage);

                    // Tell the webviews to enter streaming state
                    this._view?.webview.postMessage({ command: 'startStreaming' });
                    this._focusEditorView?.webview.postMessage({ command: 'startStreaming' });


                    let fullReply = '';
                    this._llmService.getCompletion(
                        this._activeConversation.messages,
                        config,
                        (chunk: string) => { // <--- 添加类型 : string
                            fullReply += chunk;
                            this._view?.webview.postMessage({ command: 'streamData', payload: chunk });
                            this._focusEditorView?.webview.postMessage({ command: 'streamData', payload: chunk });
                        },
                        async () => {
                            // ...
                        },
                        (error: any) => { // <--- 添加类型 : any 或 : Error
                            const errorPayload = { error: error.message };
                            this._view?.webview.postMessage({ command: 'requestFailed', payload: errorPayload });
                            this._focusEditorView?.webview.postMessage({ command: 'requestFailed', payload: errorPayload });
                        }
                    );
                    break;
                }
            case 'stopMessage':
                {
                    this._llmService.abortRequest();
                    break;
                }
            case 'executeActionPrompt':
                {
                    const webview = this._view?.webview;
                    if (!webview) return;

                    const { yamlContent, userInputs, modelConfig } = data.payload;

                    // 启动流式处理的UI状态
                    webview.postMessage({ command: 'startStreaming' });

                    // 将所有复杂性委托给 AgentService
                    // AgentService 内部会创建 WebviewLogger 来发送状态更新、流式数据和错误
                    await this._agentService.runActionFromWebview(
                        yamlContent,
                        userInputs,
                        modelConfig,
                        webview
                    );

                    // AgentService 完成后，结束流式UI状态
                    webview.postMessage({ command: 'streamEnd' });

                    break;
                }
            case 'regenerate':
            case 'editMessage':
                {
                    if (!this._activeConversation) break;

                    const { messageIndex, content } = data.payload;

                    // Truncate the history to the point of regeneration/edit
                    this._activeConversation.messages.splice(messageIndex);

                    if (data.command === 'editMessage') {
                        const userMessage: ChatMessage = { role: 'user', content: content };
                        this._activeConversation.messages.push(userMessage);
                    }

                    // Find the last valid model config from the conversation
                    const modelConfigs = await this._stateManager.getModelConfigs();
                    const defaultConfig = modelConfigs.find(c => c.isDefault) || modelConfigs[0];

                    if (!defaultConfig) {
                        vscode.window.showErrorMessage('No model configured.');
                        break;
                    }

                    let modelMessage: ChatMessage = { role: 'assistant', content: '' };
                    let fullReply = '';

                    // Post a message to clear the old response and show a loading state
                    this._view?.webview.postMessage({ command: 'setActiveConversation', payload: this._activeConversation });
                    // Tell the webview to enter streaming state
                    this._view?.webview.postMessage({ command: 'startStreaming' });

                    this._llmService.getCompletion(
                        this._activeConversation.messages,
                        defaultConfig,
                        (chunk: string) => { // <--- 添加类型 : string
                            fullReply += chunk;
                            this._view?.webview.postMessage({ command: 'streamData', payload: chunk });
                        },
                        async () => {
                            // ...
                        },
                        (error: any) => { // <--- 添加类型 : any 或 : Error
                            this._view?.webview.postMessage({ command: 'requestFailed', payload: { error: error.message } });
                        }
                    );
                    break;
                }
            case 'loadConversation':
                {
                    const { id } = data.payload;
                    const conversations = await this._stateManager.getConversations();
                    const conversation = conversations.find(c => c.id === id);
                    if (conversation) {
                        this._activeConversation = conversation;
                        this._view?.webview.postMessage({ command: 'setActiveConversation', payload: conversation });
                    }
                    break;
                }
            case 'deleteConversation':
                {
                    const { id } = data.payload;
                    await this._stateManager.deleteConversation(id);
                    const conversations = await this._stateManager.getConversations();
                    this._view?.webview.postMessage({ command: 'updateHistory', payload: conversations });
                    break;
                }
            case 'saveModelConfigs':
                {
                    await this._stateManager.saveModelConfigs(data.payload);
                    vscode.window.showInformationMessage('Model configurations saved.');

                    // 广播模型配置更新到所有视图
                    const updateMessage = {
                        command: 'updateModelConfigs',
                        payload: data.payload
                    };
                    this._view?.webview.postMessage(updateMessage);
                    this._focusEditorView?.webview.postMessage(updateMessage);

                    // Re-initialize agent service with the new default model
                    const defaultConfig = data.payload.find((c: ModelConfig) => c.isDefault) || (data.payload.length > 0 ? data.payload[0] : null);
                    if (defaultConfig) {
                        await this._agentService.initialize(defaultConfig);
                        console.log("AgentService re-initialized with new default model.");
                    } else {
                        console.warn("No default model config found after saving. Agent Service might not function correctly.");
                    }
                    break;
                }
            //== Prompt Management ==//
            case 'newPrompt':
                {
                    this._view?.webview.postMessage({ command: 'showPromptEditor' });
                    break;
                }
            case 'editPrompt':
                {
                    const { id } = data.payload;
                    const prompts = await this._stateManager.getPrompts();
                    const prompt = prompts.find(p => p.id === id);
                    if (prompt) {
                        this._view?.webview.postMessage({ command: 'showPromptEditor', payload: { prompt } });
                    }
                    break;
                }
            case 'savePrompt':
                {
                    const prompt: Prompt = data.payload;
                    await this._stateManager.savePrompt(prompt);
                    vscode.window.showInformationMessage(`Prompt "${prompt.title}" saved.`);
                    // First, update the prompts list in the webview
                    await this._updatePrompts();
                    // Then, tell the webview to navigate back to the manager
                    this._view?.webview.postMessage({ command: 'showPromptManager' });
                    break;
                }
            case 'cancelPromptEdit':
                {
                    this._view?.webview.postMessage({ command: 'showPromptManager' });
                    break;
                }
            case 'deletePrompt':
                {
                    const { id } = data.payload;
                    // Optional: Add a confirmation dialog
                    const confirmation = await vscode.window.showWarningMessage(
                        'Are you sure you want to delete this prompt?',
                        { modal: true },
                        'Delete'
                    );
                    if (confirmation === 'Delete') {
                        await this._stateManager.deletePrompt(id);
                        await this._updatePrompts();
                        vscode.window.showInformationMessage('Prompt deleted.');
                    }
                    break;
                }
            case 'agent:getPlan': {
                // 确保 webview 存在，agent 命令只在主视图处理
                const mainWebview = this._view?.webview;
                if (!mainWebview) break;

                const { agentId } = data.payload;
                const plan = this._agentService.getAgentPlan(agentId);
                if (plan) {
                    const logger = new WebviewLogger(mainWebview);
                    logger.onPlanGenerated(plan);
                } else {
                    vscode.window.showErrorMessage(`Agent with ID "${agentId}" could not be found.`);
                }
                break;
            }

            case 'agent:execute': {
                // 确保 webview 存在
                const mainWebview = this._view?.webview;
                if (!mainWebview) break;

                const { agentId, parameters } = data.payload;

                const modelConfigs = await this._stateManager.getModelConfigs();
                const defaultConfig = modelConfigs.find(c => c.isDefault) || modelConfigs[0];
                if (!defaultConfig) {
                    const errorMsg = 'No default model configured. Please set one in the settings.';
                    vscode.window.showErrorMessage(errorMsg);
                    const logger = new WebviewLogger(mainWebview);
                    logger.onAgentEnd({ runId: 'init-fail', status: 'failed', error: errorMsg });
                    return;
                }

                const logger = new WebviewLogger(mainWebview);

                // 异步执行 Agent
                this._agentService.prepareAndRunAgent(
                    agentId,
                    parameters,
                    defaultConfig,
                    logger
                );
                break;
            }

            case 'viewFile': {
                const filePathPayload = data.payload?.path;
                if (typeof filePathPayload === 'string') {
                    const workspaceFolders = vscode.workspace.workspaceFolders;
                    if (workspaceFolders && workspaceFolders.length > 0) {
                        const workspaceRootUri = workspaceFolders[0].uri;
                        let fileToOpenUri: vscode.Uri;

                        // 检查 filePathPayload 是否已经是绝对路径 (虽然通常 webview 发送的是相对路径或特殊标记的路径)
                        // 或者是否是相对于 .codewiki/runs/... 的路径
                        if (path.isAbsolute(filePathPayload)) {
                            fileToOpenUri = vscode.Uri.file(filePathPayload);
                        } else if (filePathPayload.startsWith('.codewiki/') || filePathPayload.startsWith('.vscode/')) {
                            // 假设路径是相对于工作区根目录的，例如从 .codewiki 目录
                            fileToOpenUri = vscode.Uri.joinPath(workspaceRootUri, filePathPayload);
                        } else {
                            // 默认行为：如果不是 .codewiki/runs/... 下的，尝试把它作为相对于 .codewiki 目录下的提示文件
                            // (这可能需要调整，取决于 fileCard 的 filePath 具体是什么)
                            // 假设它可能是 .codewiki 目录下的 yml 文件
                            // 如果是 Agent 运行产生的 markdown 文件，路径可能需要特别处理
                            // 例如，AgentResult 的 finalOutput 可能是 "项目总体设计文档.md"
                            // 这时需要结合 Agent 运行的 runDir 来构造完整路径

                            // 对于 AgentPlan 中的 promptFiles (e.g., 'project_planner.yml')
                            // 它们是相对于 .codewiki 目录的
                            if (filePathPayload.endsWith('.yml') || filePathPayload.endsWith('.yaml')) {
                                fileToOpenUri = vscode.Uri.joinPath(workspaceRootUri, '.codewiki', filePathPayload);
                            } else if (filePathPayload.endsWith('.md') && this._agentService && (this._agentService as any).getLastRunDir) {
                                // 这是一个假设：AgentService 能提供上次运行的目录
                                // 这个逻辑比较复杂，因为 CodeWikiViewProvider 通常不知道 runDir
                                // 更好的做法是让 AgentRunBlock 发送更明确的路径类型或完整路径
                                // 或者，AgentResult.finalOutput 如果是文件，应该是相对于工作区的路径
                                const lastRunDir = await (this._agentService as any).getLastRunDir(); // 需要 AgentService 支持
                                if (lastRunDir) {
                                    fileToOpenUri = vscode.Uri.joinPath(lastRunDir, filePathPayload);
                                } else {
                                    vscode.window.showErrorMessage(`无法确定文件 ${filePathPayload} 的完整路径。`);
                                    return;
                                }
                            }
                            else {
                                // 默认尝试作为项目根路径下的文件
                                fileToOpenUri = vscode.Uri.joinPath(workspaceRootUri, filePathPayload);
                            }
                        }

                        try {
                            // 检查文件是否存在
                            await vscode.workspace.fs.stat(fileToOpenUri);
                            vscode.window.showTextDocument(fileToOpenUri);
                        } catch (error) {
                            console.error(`Error opening file ${fileToOpenUri.fsPath}:`, error);
                            // 如果 .codewiki/xxx.yml 不存在，尝试作为项目根目录下的文件
                            if ((filePathPayload.endsWith('.yml') || filePathPayload.endsWith('.yaml')) && !filePathPayload.includes('/')) {
                                try {
                                    const rootFileUri = vscode.Uri.joinPath(workspaceRootUri, filePathPayload);
                                    await vscode.workspace.fs.stat(rootFileUri);
                                    vscode.window.showTextDocument(rootFileUri);
                                    return;
                                } catch (rootError) {
                                    vscode.window.showErrorMessage(`文件 "${filePathPayload}" 未在 .codewiki/ 或项目根目录中找到。`);
                                }
                            } else {
                                vscode.window.showErrorMessage(`无法打开文件: ${filePathPayload}. 文件可能不存在或路径不正确。`);
                            }
                        }
                    } else {
                        vscode.window.showWarningMessage('请先打开一个工作区以查看文件。');
                    }
                } else {
                    vscode.window.showErrorMessage('无效的文件路径。');
                }
                break;
            }
        }
    }

    private async _updatePrompts() {
        const prompts = await this._stateManager.getPrompts();
        const updateMessage = { command: 'updatePrompts', payload: prompts };
        this._view?.webview.postMessage(updateMessage);
        this._focusEditorView?.webview.postMessage(updateMessage);
    }

    private _getHtmlForWebview(webview: vscode.Webview): string {
        const scriptUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'dist', 'webview.js'));
        const styleUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'src', 'webview', 'css', 'main.css'));
        const codiconsUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'node_modules', '@vscode/codicons', 'dist', 'codicon.css'));

        const nonce = getNonce();

        return `<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta http-equiv="Content-Security-Policy" content="default-src 'none'; font-src ${webview.cspSource}; style-src ${webview.cspSource}; script-src 'nonce-${nonce}';">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                
                <link href="${codiconsUri}" rel="stylesheet" />
                <link href="${styleUri}" rel="stylesheet" />
                
                <title>CodeWiki</title>
            </head>
            <body>
                <div id="root"></div>
                <script nonce="${nonce}" type="module" src="${scriptUri}"></script>
            </body>
            </html>`;
    }
}

function getNonce() {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}

--------------------------------------------------------------------------------

--- file_path: extension/StateManager.ts ---
import * as vscode from 'vscode';
import { Conversation, ModelConfig, Prompt } from '../common/types';

const CONVERSATIONS_KEY = 'codewiki_conversations';
const PROMPTS_KEY = 'codewiki_prompts';
const MODEL_CONFIGS_KEY = 'codewiki_model_configs';

/**
 * Manages the state of the extension, persisting data in VS Code's global state.
 * This class acts as the single source of truth for all persistent data.
 */
export class StateManager {
    constructor(private readonly globalState: vscode.Memento) {}

    //== Conversation Management ==//

    public async getConversations(): Promise<Conversation[]> {
        return this.globalState.get<Conversation[]>(CONVERSATIONS_KEY, []);
    }

    public async saveConversation(conversation: Conversation): Promise<void> {
        const conversations = await this.getConversations();
        const index = conversations.findIndex(c => c.id === conversation.id);
        if (index !== -1) {
            conversations[index] = conversation;
        } else {
            conversations.push(conversation);
        }
        await this.globalState.update(CONVERSATIONS_KEY, conversations);
    }

    public async deleteConversation(id: string): Promise<void> {
        const conversations = await this.getConversations();
        const filteredConversations = conversations.filter(c => c.id !== id);
        await this.globalState.update(CONVERSATIONS_KEY, filteredConversations);
    }

    //== Prompt Management ==//

    public async getPrompts(): Promise<Prompt[]> {
        return this.globalState.get<Prompt[]>(PROMPTS_KEY, []);
    }

    public async savePrompt(prompt: Prompt): Promise<void> {
        const prompts = await this.getPrompts();
        const index = prompts.findIndex(p => p.id === prompt.id);
        if (index !== -1) {
            prompts[index] = prompt;
        } else {
            prompts.push(prompt);
        }
        await this.globalState.update(PROMPTS_KEY, prompts);
    }

    public async deletePrompt(id: string): Promise<void> {
        const prompts = await this.getPrompts();
        const filteredPrompts = prompts.filter(p => p.id !== id);
        await this.globalState.update(PROMPTS_KEY, filteredPrompts);
    }

    //== Model Config Management ==//

   public async getModelConfigs(): Promise<ModelConfig[]> {
        // 直接从 globalState 获取配置，如果不存在，则返回一个空数组。
        return this.globalState.get<ModelConfig[]>(MODEL_CONFIGS_KEY, []);
    }

    public async saveModelConfigs(configs: ModelConfig[]): Promise<void> {
        // Ensure only one model is default
        let defaultFound = false;
        configs.forEach(config => {
            if (config.isDefault) {
                if (defaultFound) {
                    config.isDefault = false; // Unset other defaults
                } else {
                    defaultFound = true;
                }
            }
        });

        // If no default is set, make the first one default
        if (!defaultFound && configs.length > 0) {
            configs[0].isDefault = true;
        }

        await this.globalState.update(MODEL_CONFIGS_KEY, configs);
    }
}


--------------------------------------------------------------------------------

--- file_path: extension/agents/AgentContext.ts ---
// src/extension/agents/AgentContext.ts (修改后完整文件)

import * as vscode from 'vscode';
import { ModelConfig } from '../../common/types';
import { LLMService } from '../services/LLMService';
import { AgentLogger } from '../services/logging';
import { StatsTracker } from '../services/StatsTracker'; // <-- 新增 import
import { ToolRegistry } from '../services/ToolRegistry';

/**
 * 定义了Agent执行时所需的完整上下文。
 * 这个对象会作为依赖注入容器，在Agent的各个组件之间传递。
 */
export interface AgentContext {
    llmService: LLMService;
    toolRegistry: ToolRegistry;
    logger: AgentLogger;
    modelConfig: ModelConfig;
    statsTracker: StatsTracker; // <-- 新增

    // 可选的运行目录，用于记录详细的过程文件。
    // 如果提供了这个目录，执行器等组件可以将其中间产物写入文件。
    runDir?: vscode.Uri; 
}

--------------------------------------------------------------------------------

--- file_path: extension/agents/CustomAgentExecutor.ts ---
// src/extension/agents/CustomAgentExecutor.ts (修改后完整文件)

import { BaseLanguageModel } from '@langchain/core/language_models/base';
import { StructuredTool } from '@langchain/core/tools';
import { ChatPromptTemplate } from '@langchain/core/prompts';
import { AIMessage, BaseMessage, HumanMessage, SystemMessage } from '@langchain/core/messages';
import { StringOutputParser } from '@langchain/core/output_parsers';

export interface ToolChainStep {
    tool: string;
    input: string | Record<string, any>;
    output_variable: string;
}
export interface LlmPromptTemplate {
    system: string;
    human: string;
}
export interface AgentExecutorCallbacks {
    onToolStart?: (toolName: string, input: any) => void;
    onToolEnd?: (toolName:string, output: string) => void;
    onLlmStart?: (finalSystemPrompt: string, finalHumanPrompt: string) => void;
    onLlmStream?: (chunk: string) => void;
    onLlmEnd?: (finalResult: string) => void;
    onError?: (error: Error) => void;
}


export class CustomAgentExecutor {
    private tools: Map<string, StructuredTool>;
    private finalLlm: BaseLanguageModel;

    constructor(tools: StructuredTool[], finalLlm: BaseLanguageModel) {
        this.tools = new Map(tools.map(tool => [tool.name, tool]));
        this.finalLlm = finalLlm;
    }

    // --- 修改点：run 方法现在返回 Promise<string> ---
    public async run(
        tool_chain: ToolChainStep[],
        initialInputs: Record<string, string>,
        llm_prompt_template: LlmPromptTemplate,
        callbacks: AgentExecutorCallbacks
    ): Promise<string> { // <-- 返回类型修改
        return new Promise(async (resolve, reject) => {
            const context: Record<string, any> = { ...initialInputs };
        
            try {
                for (const step of tool_chain) {
                    const tool = this.tools.get(step.tool);
                    if (!tool) {
                        throw new Error(`Tool "${step.tool}" not found.`);
                    }
                    
                    const toolInput = this.resolveInput(step.input, context);
                    callbacks.onToolStart?.(tool.name, toolInput);

                    const toolOutputString = await tool.call(toolInput);
                    const toolOutputParsed = this.parseToolOutput(toolOutputString);
                    context[step.output_variable] = toolOutputParsed;

                    const outputSummary = toolOutputString.length > 500 ? `${toolOutputString.substring(0, 500)}...` : toolOutputString;
                    callbacks.onToolEnd?.(tool.name, outputSummary);
                }
                
                const systemMessageContent = this.resolveInput(llm_prompt_template.system, context) as string;
                const humanMessageContent = this.resolveInput(llm_prompt_template.human, context) as string;

                callbacks.onLlmStart?.(systemMessageContent, humanMessageContent);

                const finalPrompt = ChatPromptTemplate.fromMessages([
                    new SystemMessage(systemMessageContent),
                    new HumanMessage(humanMessageContent)
                ]);

                const finalChain = finalPrompt.pipe(this.finalLlm).pipe(new StringOutputParser());

                const stream = await finalChain.stream({});
                let fullReply = '';
                for await (const chunk of stream) {
                    fullReply += chunk;
                    callbacks.onLlmStream?.(chunk);
                }
                callbacks.onLlmEnd?.(fullReply);
                
                resolve(fullReply); // --- 修改点：用最终结果 resolve Promise ---

            } catch (error: any) {
                const err = error instanceof Error ? error : new Error(String(error));
                callbacks.onError?.(err);
                reject(err); // --- 修改点：用错误 reject Promise ---
            }
        });
    }

    private resolveInput(inputTemplate: string | Record<string, any>, context: Record<string, any>): any {
        // ... 此方法实现保持不变 ...
        if (typeof inputTemplate === 'string') {
            const match = inputTemplate.match(/^\{(\w+)\}$/);
            if (match && context[match[1]] !== undefined) {
                return context[match[1]];
            }
            return inputTemplate.replace(/\{(\w+)\}/g, (m, key) => {
                return context[key] !== undefined ? String(context[key]) : m;
            });
        }
        const resolvedObject: Record<string, any> = {};
        for (const key in inputTemplate) {
            const value = inputTemplate[key];
            resolvedObject[key] = this.resolveInput(value, context);
        }
        return resolvedObject;
    }

    private parseToolOutput(outputString: string): any {
        // ... 此方法实现保持不变 ...
        try {
            if ((outputString.startsWith('[') && outputString.endsWith(']')) || (outputString.startsWith('{') && outputString.endsWith('}'))) {
                return JSON.parse(outputString);
            }
        } catch (e) {}
        return outputString;
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/agents/executors/MapReduceExecutor.ts ---
// file_path: extension/agents/executors/MapReduceExecutor.ts
import * as vscode from 'vscode';
import * as path from 'path';
import * as yaml from 'js-yaml';
import { get_encoding, Tiktoken } from 'tiktoken';
import { v4 as uuidv4 } from 'uuid'; // 修正: 添加 import
import { HumanMessage, SystemMessage } from '@langchain/core/messages';
import { AgentContext } from '../AgentContext';
import { StringOutputParser } from '@langchain/core/output_parsers'; // 修正: 添加 import

// 接口定义
interface MapReducePrompt {
    title?: string;
    description?: string;
    input_variables: { name: string; description: string; type: string; default?: string }[];
    map_prompt_template: { system: string; human: string };
    reduce_prompt_template: { system: string; human: string };
    max_tokens_per_batch?: number;
}

interface FileData {
    path: string;
    content: string;
    tokenCount: number;
}

// 辅助函数
async function getAllFilePaths(dirUri: vscode.Uri): Promise<vscode.Uri[]> {
    let files: vscode.Uri[] = [];
    const entries = await vscode.workspace.fs.readDirectory(dirUri);
    for (const [name, type] of entries) {
        const entryUri = vscode.Uri.joinPath(dirUri, name);
        if (type === vscode.FileType.File) {
            if (!name.startsWith('.') && !['node_modules', 'dist', 'out'].some(part => entryUri.path.includes(`/${part}/`))) {
                files.push(entryUri);
            }
        } else if (type === vscode.FileType.Directory) {
            if (!name.startsWith('.') && !['node_modules', 'dist', 'out'].includes(name)) {
                files = files.concat(await getAllFilePaths(entryUri));
            }
        }
    }
    return files;
}

export class MapReduceExecutor {
    constructor(private readonly context: AgentContext) {}

    public async run(runId: string, yamlContent: string, userInputs: Record<string, any>): Promise<string> {
        const { logger, llmService, modelConfig, runDir } = this.context;
        let tokenizer: Tiktoken | null = null;
        
        try {
            const prepTaskId = uuidv4(); 
            const prepStepName = "解析与准备";
            logger.onStepStart({ runId, taskId: prepTaskId, stepName: prepStepName, status: 'running' });
            
            const actionPrompt = yaml.load(yamlContent) as MapReducePrompt;
            const modulePath = userInputs['module_path'];
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders) throw new Error("未打开工作区文件夹。");
            
            const workspaceRoot = workspaceFolders[0].uri;
            const absoluteModulePath = vscode.Uri.joinPath(workspaceRoot, modulePath);
            const fileUris = await getAllFilePaths(absoluteModulePath);
            tokenizer = get_encoding("cl100k_base");
            
            const fileDataPromises = fileUris.map(async (uri): Promise<FileData> => {
                if (!tokenizer) throw new Error("Tokenizer not initialized.");
                const contentBytes = await vscode.workspace.fs.readFile(uri);
                const content = Buffer.from(contentBytes).toString('utf-8');
                return { path: path.relative(workspaceRoot.fsPath, uri.fsPath).replace(/\\/g, '/'), content, tokenCount: tokenizer.encode(content).length };
            });
            const allFiles = await Promise.all(fileDataPromises);
            logger.onStepUpdate({ runId, taskId: prepTaskId, type: 'output', data: { name: "文件列表", content: `找到 ${allFiles.length} 个文件。` } });

            const MAX_TOKENS_PER_BATCH = actionPrompt.max_tokens_per_batch || 12000;
            const batches: FileData[][] = [];
            let currentBatch: FileData[] = [];
            let currentBatchTokens = 0;
            for (const file of allFiles) {
                if (file.tokenCount > MAX_TOKENS_PER_BATCH) { continue; }
                if (currentBatchTokens + file.tokenCount > MAX_TOKENS_PER_BATCH) { batches.push(currentBatch); currentBatch = []; currentBatchTokens = 0; }
                currentBatch.push(file);
                currentBatchTokens += file.tokenCount;
            }
            if (currentBatch.length > 0) { batches.push(currentBatch); }
            logger.onStepUpdate({ runId, taskId: prepTaskId, type: 'output', data: { name: "批次信息", content: `创建了 ${batches.length} 个批次。` } });
            logger.onStepEnd({ runId, taskId: prepTaskId, stepName: prepStepName, status: 'completed' }); // 修正: 添加 stepName

            const mapStepName = "Map阶段: 并行分析";
            logger.onStepStart({ runId, stepName: mapStepName, status: 'running' }); // 这个是父步骤的开始

            const llm = await llmService.createModel({ modelConfig, temperature: 0.1, streaming: false });
            const mapAnalysisPromises = batches.map(async (batch, i) => {
                const mapTaskId = uuidv4(); 
                const mapTaskName = `分析批次 ${i + 1}/${batches.length}`;
                logger.onStepStart({ runId, taskId: mapTaskId, stepName: mapTaskName, status: 'running' });
                
                try {
                    const batchContent = batch.map(f => `--- FILE: ${f.path} ---\n${f.content}`).join('\n\n');
                    const humanPrompt = actionPrompt.map_prompt_template.human.replace('{code_files_collection}', batchContent);
                    logger.onStepUpdate({ runId, taskId: mapTaskId, type: 'llm-request', data: { system: actionPrompt.map_prompt_template.system, human: humanPrompt } });
                    
                    const response = await llmService.scheduleLlmCall(() => llm.invoke([new SystemMessage(actionPrompt.map_prompt_template.system), new HumanMessage(humanPrompt)]));
                    const responseContent = response.content as string;

                    logger.onStepUpdate({ runId, taskId: mapTaskId, type: 'output', data: { name: "批次摘要", content: responseContent } });
                    logger.onStepEnd({ runId, taskId: mapTaskId, stepName: mapTaskName, status: 'completed' }); // 修正: 添加 stepName
                    return responseContent;
                } catch (e: any) {
                    logger.onStepEnd({ runId, taskId: mapTaskId, stepName: mapTaskName, status: 'failed', error: e.message }); // 修正: 添加 stepName
                    throw e;
                }
            });
            const mapResults = await Promise.all(mapAnalysisPromises);
            logger.onStepEnd({ runId, stepName: mapStepName, status: 'completed' }); // 修正: 父步骤的结束, 添加 stepName

            const reduceTaskId = uuidv4(); 
            const reduceStepName = "Reduce阶段: 综合摘要";
            logger.onStepStart({ runId, taskId: reduceTaskId, stepName: reduceStepName, status: 'running' });

            const combinedMarkdownSummaries = mapResults.join("\n\n");
            logger.onStepUpdate({ runId, taskId: reduceTaskId, type: 'input', data: { name: "所有摘要", content: combinedMarkdownSummaries } });
            
            const reduceLlm = await llmService.createModel({ modelConfig, temperature: 0.5, streaming: true });
            let humanReducePrompt = actionPrompt.reduce_prompt_template.human;
            for (const key in userInputs) {
                humanReducePrompt = humanReducePrompt.replace(new RegExp(`\\{${key}\\}`, 'g'), userInputs[key]);
            }
            humanReducePrompt = humanReducePrompt.replace('{combined_markdown_summaries}', combinedMarkdownSummaries);
            
            logger.onStepUpdate({ runId, taskId: reduceTaskId, type: 'llm-request', data: { system: actionPrompt.reduce_prompt_template.system, human: humanReducePrompt } });

            const reduceChain = reduceLlm.pipe(new StringOutputParser()); 
            const stream = await reduceChain.stream([ new SystemMessage(actionPrompt.reduce_prompt_template.system), new HumanMessage(humanReducePrompt) ]);

            let finalContent = '';
            for await (const chunk of stream) {
                const chunkContent = chunk as string; 
                finalContent += chunkContent;
                // logger.onStreamChunk({ runId, taskId: reduceTaskId, content: chunkContent });
            }

            logger.onStepUpdate({ runId, taskId: reduceTaskId, type: 'output', data: { name: "最终文档", content: finalContent }, metadata: { type: 'markdown' } });
            logger.onStepEnd({ runId, taskId: reduceTaskId, stepName: reduceStepName, status: 'completed' }); // 修正: 添加 stepName
            
            return finalContent;

        } catch (error: any) {
            const err = error instanceof Error ? error : new Error(String(error));
            throw err;
        } finally {
            if (tokenizer) {
                tokenizer.free();
            }
        }
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/agents/executors/ToolChainExecutor.ts ---
// file_path: extension/agents/executors/ToolChainExecutor.ts
import * as vscode from 'vscode';
import * as yaml from 'js-yaml';
import { v4 as uuidv4 } from 'uuid';
import { ToolChainStep, LlmPromptTemplate } from '../CustomAgentExecutor'; 
import { AgentContext } from '../AgentContext';
import { SystemMessage, HumanMessage } from '@langchain/core/messages';
import { StringOutputParser } from '@langchain/core/output_parsers';

interface ActionPrompt {
    tool_chain: ToolChainStep[];
    llm_prompt_template: LlmPromptTemplate;
}

export class ToolChainExecutor {
    constructor(private readonly context: AgentContext) {}

    public async run(runId: string, yamlContent: string, userInputs: Record<string, any>): Promise<string> {
        const { logger, llmService, toolRegistry, modelConfig, runDir, statsTracker } = this.context;
        let finalResult = '';

        try {
            const parseTaskId = uuidv4();
            const parseStepName = "解析YAML配置";
            logger.onStepStart({ runId, taskId: parseTaskId, stepName: parseStepName, status: 'running' });
            
            const actionPrompt = yaml.load(yamlContent) as ActionPrompt;

            if (!actionPrompt.tool_chain || !actionPrompt.llm_prompt_template) {
                throw new Error("无效的Action Prompt YAML格式。缺少 'tool_chain' 或 'llm_prompt_template'。");
            }
            logger.onStepEnd({ runId, taskId: parseTaskId, stepName: parseStepName, status: 'completed' }); // 修正: 添加 stepName

            const executionContext: Record<string, any> = { ...userInputs };

            for (const step of actionPrompt.tool_chain) { 
                const toolTaskId = uuidv4();
                const toolStepName = `执行工具: ${step.tool}`; // 使用这个作为 stepName
                logger.onStepStart({ runId, taskId: toolTaskId, stepName: toolStepName, status: 'running' });

                const tool = toolRegistry.getTool(step.tool);
                if (!tool) {
                    throw new Error(`工具 "${step.tool}" 未找到。`);
                }
                
                const toolInput = this.resolveInput(step.input, executionContext);
                logger.onStepUpdate({ runId, taskId: toolTaskId, type: 'input', data: { name: "工具输入", content: toolInput } });
                
                const toolOutputString = await tool.call(toolInput) as string; 
                const toolOutputParsed = this.parseToolOutput(toolOutputString);
                executionContext[step.output_variable] = toolOutputParsed;
                
                logger.onStepUpdate({ runId, taskId: toolTaskId, type: 'output', data: { name: "工具输出", content: toolOutputString } });
                logger.onStepEnd({ runId, taskId: toolTaskId, stepName: toolStepName, status: 'completed' }); // 修正: 添加 stepName
            }
            
            const llmTaskId = uuidv4();
            const llmStepName = "生成最终响应";
            logger.onStepStart({ runId, taskId: llmTaskId, stepName: llmStepName, status: 'running' });
            
            const systemMessageContent = this.resolveInput(actionPrompt.llm_prompt_template.system, executionContext);
            const humanMessageContent = this.resolveInput(actionPrompt.llm_prompt_template.human, executionContext);

            const llmRequest = { system: systemMessageContent, human: humanMessageContent };
            logger.onStepUpdate({ runId, taskId: llmTaskId, type: 'llm-request', data: llmRequest });
            if (runDir) {
                await vscode.workspace.fs.writeFile(vscode.Uri.joinPath(runDir, 'llm_request.txt'), Buffer.from(`[SYSTEM]\n${systemMessageContent}\n\n[HUMAN]\n${humanMessageContent}`, 'utf8'));
            }

            const finalLlm = await llmService.createModel({ modelConfig, streaming: true, temperature: 0.7 });
            const finalChain = finalLlm.pipe(new StringOutputParser());
            const stream = await finalChain.stream([ new SystemMessage(systemMessageContent), new HumanMessage(humanMessageContent) ]);
            
            for await (const chunk of stream) {
                finalResult += chunk;
                // logger.onStreamChunk({ runId, taskId: llmTaskId, content: chunk as string });
            }
            statsTracker.add(humanMessageContent, finalResult);
            
            logger.onStepUpdate({ runId, taskId: llmTaskId, type: 'output', data: { name: "LLM响应", content: finalResult }, metadata: { type: 'markdown' } });
            if (runDir) {
                await vscode.workspace.fs.writeFile(vscode.Uri.joinPath(runDir, 'llm_response.md'), Buffer.from(finalResult, 'utf8'));
            }
            logger.onStepEnd({ runId, taskId: llmTaskId, stepName: llmStepName, status: 'completed' }); // 修正: 添加 stepName

            return finalResult;

        } catch (error: any) {
            const err = error instanceof Error ? error : new Error(String(error));
            // 如果错误发生在特定步骤，应该在该步骤的 catch 中记录 onStepEnd(failed)
            // 这里的 throw 会被 AgentService 捕获并调用 onAgentEnd(failed)
            throw err;
        }
    }

    private resolveInput(inputTemplate: any, context: Record<string, any>): any {
        if (typeof inputTemplate === 'string') {
            const match = inputTemplate.match(/^\{(\w+)\}$/);
            if (match && context[match[1]] !== undefined) {
                return context[match[1]];
            }
            return inputTemplate.replace(/\{(\w+)\}/g, (m, key) => {
                return context[key] !== undefined ? String(context[key]) : m;
            });
        }
        if (typeof inputTemplate !== 'object' || inputTemplate === null) {
            return inputTemplate;
        }
        const resolvedObject: Record<string, any> = {};
        for (const key in inputTemplate) {
            const value = inputTemplate[key];
            resolvedObject[key] = this.resolveInput(value, context);
        }
        return resolvedObject;
    }

    private parseToolOutput(outputString: string): any {
        try {
            if ((outputString.startsWith('[') && outputString.endsWith(']')) || (outputString.startsWith('{') && outputString.endsWith('}'))) {
                return JSON.parse(outputString);
            }
        } catch (e) {}
        return outputString;
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/agents/orchestrators/ProjectDocumentationOrchestrator.ts ---
// file_path: extension/agents/orchestrators/ProjectDocumentationOrchestrator.ts
import * as vscode from 'vscode';
import * as path from 'path';
import * as yaml from 'js-yaml';
import { get_encoding, Tiktoken } from 'tiktoken';
import { v4 as uuidv4 } from 'uuid';
import { BaseMessage, HumanMessage } from '@langchain/core/messages';
import { StringOutputParser } from '@langchain/core/output_parsers';
import { AgentContext } from '../AgentContext';
import { MapReduceExecutor } from '../executors/MapReduceExecutor';
import { ToolChainExecutor } from '../executors/ToolChainExecutor';

// 接口定义
interface Module {
    name: string;
    path: string;
    description: string;
    normalizedPath?: string;
}

interface PlannerOutput {
    projectName: string;
    language: string;
    modules: Module[];
}

interface ModuleDoc extends Module {
    content: string;
}

interface PromptsCollection {
    plannerPrompt: string;
    directAnalysisPrompt: string;
    mapReduceAnalysisPrompt: string;
    synthesisPrompt: string;
}

export class ProjectDocumentationOrchestrator {
    private readonly MAX_TOKENS_FOR_DIRECT_ANALYSIS = 64000;
    private tokenizer!: Tiktoken;
    private runDir!: vscode.Uri;

    constructor(
        private readonly context: AgentContext,
        private readonly prompts: PromptsCollection
    ) {}

    public async run(runId: string) {
        this.tokenizer = get_encoding("cl100k_base");

        const { logger } = this.context;
        logger.show(true);

        const workspaceRoot = vscode.workspace.workspaceFolders?.[0].uri;
        if (!workspaceRoot) {
            throw new Error("请先打开一个工作区文件夹。");
        }

        // 移除 try/catch, 让错误向上冒泡到 AgentService
        const runFolderName = `doc-gen_${new Date().toISOString().replace(/[:.]/g, '-')}`;
        this.runDir = vscode.Uri.joinPath(workspaceRoot, '.codewiki', 'runs', runFolderName);
        await vscode.workspace.fs.createDirectory(this.runDir);
        logger.info(`日志和结果将保存在: ${this.runDir.fsPath}`);

        const plan = await this.runPlanningPhase(runId);
        const moduleDocs = await this.runModuleAnalysisPhase(runId, plan);
        const finalDoc = await this.runSynthesisPhase(runId, plan, moduleDocs);

        await this.saveFinalDocument(finalDoc);

        // 移除 onAgentEnd 调用。AgentService 将负责此事
        // logger.onAgentEnd({ runId, status: 'completed', finalOutput: "执行成功" });

        if (this.tokenizer) { 
            this.tokenizer.free();
        }
    }

    private async runPlanningPhase(runId: string): Promise<PlannerOutput> {
        const { logger, toolRegistry, llmService, modelConfig, statsTracker } = this.context; // <-- 添加 statsTracker
        const taskId = uuidv4();
        const stepName = "规划: 分析项目结构"; // This is the stepName
        logger.onStepStart({ runId, taskId, stepName, status: 'running' });

        const treeTool = toolRegistry.getTool('get_directory_tree')!;
        const fileTree = await treeTool.call({ path: '.', language: 'unknown' }) as string;
        logger.onStepUpdate({ runId, taskId, type: 'input', data: { name: "文件树", content: fileTree } });

        const plannerLlm = await llmService.createModel({ modelConfig, temperature: 0.1 });
        const plannerPromptTemplate = (yaml.load(this.prompts.plannerPrompt) as any).llm_prompt_template.human;
        const prompt = plannerPromptTemplate.replace('{file_tree}', fileTree);
        logger.onStepUpdate({ runId, taskId, type: 'llm-request', data: { system: "...", human: prompt }});

        await vscode.workspace.fs.writeFile(
            vscode.Uri.joinPath(this.runDir, '01_planning_request.txt'),
            Buffer.from(prompt, 'utf8')
        );

        const response = await llmService.scheduleLlmCall(() => plannerLlm.invoke([new HumanMessage(prompt)]));
        const responseContent = response.content as string;

        statsTracker.add(prompt, responseContent); // 记录 Token

        await vscode.workspace.fs.writeFile(
            vscode.Uri.joinPath(this.runDir, '01_planning_response.txt'),
            Buffer.from(responseContent, 'utf8')
        );

        try {
            const jsonString = responseContent.match(/\{[\s\S]*\}/)?.[0];
            if (!jsonString) throw new Error("大模型未能返回有效的JSON规划。");

            const plan = JSON.parse(jsonString) as PlannerOutput;

            logger.onStepUpdate({ runId, taskId, type: 'output', data: { name: "项目规划", content: plan } });
            // highlight-start
            logger.onStepEnd({ runId, taskId, stepName, status: 'completed' });
            // highlight-end
            return plan;
        } catch (e: any) {
            // highlight-start
            logger.onStepEnd({ runId, taskId, stepName, status: 'failed', error: e.message });
            // highlight-end
            throw new Error(`解析规划输出失败: ${e.message}`);
        }
    }

    private async runModuleAnalysisPhase(runId: string, plan: PlannerOutput): Promise<ModuleDoc[]> {
        const { logger, llmService, toolRegistry } = this.context;
        const workspaceRoot = vscode.workspace.workspaceFolders?.[0].uri;
        if (!workspaceRoot) {
            throw new Error("No workspace folder open.");
        }

        const filterTaskId = uuidv4();
        const filterStepName = "过滤和验证模块";
        logger.onStepStart({ runId, taskId: filterTaskId, stepName: filterStepName, status: 'running' });

        const pathCheckPromises = plan.modules.map(async (m) => {
            const modulePath = m.path.trim();
            if (modulePath === '.' || modulePath === './' || modulePath === '' || modulePath === '/') {
                logger.warn(`- 已跳过模块 '${m.name}' (路径: '${m.path}'), 因其指向根目录。`);
                return null;
            }
            try {
                const absoluteUri = vscode.Uri.joinPath(workspaceRoot, modulePath);
                const stat = await vscode.workspace.fs.stat(absoluteUri);
                if (stat.type !== vscode.FileType.Directory) {
                    logger.warn(`- 已跳过模块 '${m.name}' (路径: '${m.path}'), 因其指向单个文件而非目录。`);
                    return null;
                }
                return m;
            } catch (error) {
                logger.warn(`- 已跳过模块 '${m.name}' (路径: '${m.path}'), 因路径不存在。`);
                return null;
            }
        });

        const validDirectoryModules = (await Promise.all(pathCheckPromises)).filter((m): m is Module => m !== null);

        let modules = validDirectoryModules.map(m => ({
            ...m,
            normalizedPath: m.path.trim().replace(/^\.?[\\\/]/, '').replace(/[\\\/]$/, '')
        }));

        modules.sort((a, b) => (b.normalizedPath?.length || 0) - (a.normalizedPath?.length || 0));

        const finalModules: Module[] = [];
        const coveredPaths = new Set<string>();

        for (const currentModule of modules) {
            if (!currentModule.normalizedPath) continue;
            let isCovered = false;
            for (const coveredPath of coveredPaths) {
                if (coveredPath.startsWith(currentModule.normalizedPath + '/')) {
                    isCovered = true;
                    break;
                }
            }
            if (!isCovered) {
                finalModules.push(currentModule);
                coveredPaths.add(currentModule.normalizedPath);
            } else {
                 logger.warn(`- 跳过模块 '${currentModule.name}' (路径: '${currentModule.path}'), 因其包含已被选中的更具体的子模块。`);
            }
        }

        finalModules.reverse();

        const finalPlan: PlannerOutput = {
            ...plan,
            modules: finalModules.map(({ normalizedPath, ...rest }) => rest)
        };

        await vscode.workspace.fs.writeFile(
            vscode.Uri.joinPath(this.runDir, 'plan.json'),
            Buffer.from(JSON.stringify(finalPlan, null, 2), 'utf8')
        );


        if (finalModules.length < plan.modules.length) {
            const skippedCount = plan.modules.length - finalModules.length;
            logger.info(`- 过滤完成，共跳过 ${skippedCount} 个根目录、文件路径或重叠的模块。`);
        } else {
            logger.info(`- 所有模块路径均为有效目录且不重叠，将分析全部 ${finalModules.length} 个模块。`);
        }

        logger.onStepUpdate({ runId, taskId: filterTaskId, type: 'output', data: { name: "唯一模块", content: `已过滤，将分析 ${finalModules.length} 个模块。` } });
        // highlight-start
        logger.onStepEnd({ runId, taskId: filterTaskId, stepName: filterStepName, status: 'completed' });
        // highlight-end

        const analysisStepName = "分析: 并行处理模块";
        logger.info(`[DEBUG] Attempting to start parent step: ${analysisStepName}`);
        logger.onStepStart({ runId, stepName: analysisStepName, status: 'running' }); 
        const analysisPromises = finalModules.map((module, index) =>
            this.analyzeSingleModule(runId, module, plan.language, index + 1, finalModules.length)
        );
        const results = await Promise.all(analysisPromises);
        // highlight-start
        logger.onStepEnd({ runId, stepName: analysisStepName, status: 'completed' }); // This is the parent step for module analysis
        // highlight-end
        return results;
    }

    private async analyzeSingleModule(runId: string, module: Module, language: string, index: number, total: number): Promise<ModuleDoc> {
        const { logger } = this.context;
        const taskId = uuidv4();
        const stepName = `分析模块: '${module.name}' (${index}/${total})`;
        logger.info(`[DEBUG] Attempting to start sub-step: ${stepName} with taskId: ${taskId}`);
        logger.onStepStart({ runId, taskId, stepName, status: 'running' });

        const moduleAnalysisDir = vscode.Uri.joinPath(this.runDir, `module_${module.path.replace(/[\/\\]/g, '_')}`);
        await vscode.workspace.fs.createDirectory(moduleAnalysisDir);

        const moduleContext: AgentContext = { ...this.context, runDir: moduleAnalysisDir };

        const contentTool = this.context.toolRegistry.getTool('get_all_files_content') as any;
        const allContent = await contentTool.call({ path: module.path, language }) as string;
        const tokenCount = this.tokenizer.encode(allContent).length;

        let executor: ToolChainExecutor | MapReduceExecutor;
        let promptYaml: string;
        let strategy: string;

        if (tokenCount <= this.MAX_TOKENS_FOR_DIRECT_ANALYSIS) {
            strategy = "直接分析 (ToolChain)";
            executor = new ToolChainExecutor(moduleContext);
            promptYaml = this.prompts.directAnalysisPrompt;
        } else {
            strategy = "Map-Reduce分析";
            executor = new MapReduceExecutor(moduleContext);
            promptYaml = this.prompts.mapReduceAnalysisPrompt;
        }
        logger.onStepUpdate({ runId, taskId, type: 'input', data: { name: "分析策略", content: strategy, "Token数": tokenCount } });

        try {
            const docContent = await executor.run(runId, promptYaml, { module_path: module.path, language, task_description: module.description });

            const docPath = vscode.Uri.joinPath(this.runDir, `module_${module.name.replace(/[\s\/]/g, '_')}.md`);
            await vscode.workspace.fs.writeFile(docPath, Buffer.from(docContent, 'utf8'));

            logger.onStepUpdate({ runId, taskId, type: 'output', data: { name: "模块文档", content: docContent }, metadata: { type: 'file', path: docPath.fsPath } });
            // highlight-start
            logger.onStepEnd({ runId, taskId, stepName, status: 'completed' });
            // highlight-end
            return { ...module, content: docContent };
        } catch (e: any) {
            // highlight-start
            logger.onStepEnd({ runId, taskId, stepName, status: 'failed', error: e.message });
            // highlight-end
            throw e; // Re-throw to be caught by the main run() method's try-catch
        }
    }

    private async runSynthesisPhase(runId: string, plan: PlannerOutput, moduleDocs: ModuleDoc[]): Promise<string> {
        const { logger, llmService, modelConfig, statsTracker } = this.context; // <-- 添加 statsTracker
        const taskId = uuidv4();
        const stepName = "综合: 生成最终文档";
        logger.onStepStart({ runId, taskId, stepName, status: 'running' });

        const synthesisLlm = await llmService.createModel({ modelConfig, temperature: 0.4, streaming: true });

        const synthesisPromptTemplate = (yaml.load(this.prompts.synthesisPrompt) as any).llm_prompt_template.human;
        const moduleOverviews = moduleDocs.map(m => `- **${m.name} (${m.path})**: ${m.description}`).join('\n');
        const detailedModuleDocs = moduleDocs.map(doc => `\n### 模块: ${doc.name}\n${doc.content}\n`).join('\n---\n');
        const prompt = synthesisPromptTemplate.replace('{projectName}', plan.projectName).replace('{language}', plan.language).replace('{module_overviews}', moduleOverviews).replace('{detailed_module_docs}', detailedModuleDocs);

        logger.onStepUpdate({ runId, taskId, type: 'llm-request', data: { system: "...", human: prompt }});

        await vscode.workspace.fs.writeFile(
            vscode.Uri.joinPath(this.runDir, '03_synthesis_request.txt'),
            Buffer.from(prompt, 'utf8')
        );

        const chain = synthesisLlm.pipe(new StringOutputParser());
        const stream = await chain.stream([new HumanMessage(prompt)]);

        let finalDoc = '';
        for await (const chunk of stream) {
            const chunkContent = chunk as string;
            finalDoc += chunkContent;
            // logger.onStreamChunk({ runId, taskId, content: chunkContent });
        }

        statsTracker.add(prompt, finalDoc); // 记录 Token

        await vscode.workspace.fs.writeFile(
            vscode.Uri.joinPath(this.runDir, '03_synthesis_response.txt'),
            Buffer.from(finalDoc, 'utf8')
        );

        // 1. 获取最终文档的路径
        const finalDocPath = await this.getFinalDocPath();

        // 2. 发送 StepUpdate，其中 metadata 指向文件路径，data.content 可以是简短描述
        logger.onStepUpdate({ 
            runId, 
            taskId, 
            type: 'output', 
            data: { name: "最终项目文档", content: `文档已生成: ${path.basename(finalDocPath.fsPath)}` },
            metadata: { type: 'file', path: finalDocPath.fsPath } // <-- 这是关键
        });

        logger.onStepEnd({ runId, taskId, stepName, status: 'completed' });
        return finalDoc;
    }

    private async saveFinalDocument(content: string) {
        const finalDocPath = vscode.Uri.joinPath(this.runDir, '项目总体设计文档.md');
        await vscode.workspace.fs.writeFile(finalDocPath, Buffer.from(content, 'utf8'));

        vscode.window.showInformationMessage(`文档已保存至: ${finalDocPath.fsPath}`, '打开文件').then(selection => {
            if (selection === '打开文件') {
                vscode.window.showTextDocument(finalDocPath);
            }
        });
    }

     private async getFinalDocPath(): Promise<vscode.Uri> {
        return vscode.Uri.joinPath(this.runDir, '项目总体设计文档.md');
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/config/fileFilters.ts ---
// src/extension/config/fileFilters.ts

/**
 * Defines a language's file filtering rules.
 */
export interface LanguageFilter {
    // Included file extensions
    include: string[];
    // Specific files or patterns to explicitly exclude
    exclude: string[];
}

/**
 * Generic exclusion list, applicable to all languages and projects.
 */
export const GENERIC_EXCLUDE = [
    'node_modules',
    'dist',
    'out',
    'build',
    'target', // Common for Java (Maven/Gradle)
    'bin',
    'vendor',
    '.git',
    '.svn',
    '.hg',
    '__pycache__',
    '.vscode',
    '.idea',
    'package-lock.json',
    'yarn.lock',
    'pnpm-lock.yaml',
    'go.sum',
    '.DS_Store'
];

/**
 * Language-specific filtering rules.
 */
export const languageFilters: Record<string, LanguageFilter> = {
    typescript: {
        include: ['.ts', '.tsx'],
        exclude: ['.d.ts', '.spec.ts', '.test.ts'],
    },
    javascript: {
        include: ['.js', '.jsx'],
        exclude: ['.spec.js', '.test.js'],
    },
    python: {
        include: ['.py'],
        exclude: [],
    },
    go: {
        include: ['.go'],
        exclude: ['_test.go'],
    },
    // highlight-start
    java: {
        include: ['.java'],
        // Java testing is typically directory-based (src/test/java),
        // which is handled by module selection rather than file-level filtering.
        exclude: [], 
    },
    c: {
        // Headers (.h) are crucial for understanding interfaces and must be included.
        include: ['.c', '.h'],
        exclude: [],
    },
    cpp: { // Using 'cpp' as the key for C++
        // C++ has various extensions for source and header files.
        // Including the most common ones. Headers are critical.
        include: ['.cpp', '.hpp', '.cc', '.cxx', '.h'],
        exclude: [],
    },
    // highlight-end
    unknown: { // Default rule when language isn't identified
        include: [
            '.ts', '.tsx', '.js', '.jsx', '.py', '.go', 
            // highlight-start
            '.java', '.c', '.h', '.cpp', '.hpp', '.cc', '.cxx', 
            // highlight-end
            '.cs', '.rb', '.php', '.rs'
        ],
        exclude: ['.spec.ts', '.test.ts', '.spec.js', '.test.js', '_test.go'],
    }
};

--------------------------------------------------------------------------------

--- file_path: extension/extension.ts ---
// src/extension/extension.ts (修改后完整文件)

import * as vscode from 'vscode';
import { CodeWikiViewProvider } from './CodeWikiViewProvider';
import { StateManager } from './StateManager';
import { LLMService } from './services/LLMService';
import { AgentService } from './services/AgentService'; // <-- 新的 import

export async function activate(context: vscode.ExtensionContext) {
    // --- 服务初始化 ---
    const stateManager = new StateManager(context.globalState);
    const llmService = new LLMService();
    const agentService = new AgentService(llmService); // <-- 创建 AgentService

    // 获取默认模型并初始化服务
    const modelConfigs = await stateManager.getModelConfigs();
    const defaultConfig = modelConfigs.find(c => c.isDefault) || modelConfigs[0];
    if (defaultConfig) {
        await agentService.initialize(defaultConfig);
    } else {
        console.warn("No default model config found. Agent Service might not function correctly.");
    }
    // --- 结束服务初始化 ---


    const provider = new CodeWikiViewProvider(context.extensionUri, context, agentService); // <-- 注入 AgentService

    context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(CodeWikiViewProvider.viewType, provider)
    );

    // --- 命令注册 ---
    const generateProjectDocDisposable = vscode.commands.registerCommand('codewiki.generateProjectDocumentation', async () => {
        const modelConfigs = await stateManager.getModelConfigs();
        const defaultConfig = modelConfigs.find(c => c.isDefault) || modelConfigs[0];
            
        if (!defaultConfig) {
            vscode.window.showErrorMessage("No default model configuration found. Please configure a model in the CodeWiki settings.");
            return;
        }

        // 调用变得非常简单
        await agentService.runProjectDocumentation(defaultConfig);
    });
    
    context.subscriptions.push(generateProjectDocDisposable);

    // 移除了旧的 codewiki.runAgent 命令，因为它的逻辑已经被新的架构和Webview触发器所取代。
}

export function deactivate() {}

--------------------------------------------------------------------------------

--- file_path: extension/services/AgentService.ts ---
// src/extension/services/AgentService.ts (完整文件)

import * as vscode from 'vscode';
import { v4 as uuidv4 } from 'uuid';
import { ModelConfig, AgentPlan } from '../../common/types';
import { AgentContext } from '../agents/AgentContext';
import { ProjectDocumentationOrchestrator } from '../agents/orchestrators/ProjectDocumentationOrchestrator';
import { ToolChainExecutor } from '../agents/executors/ToolChainExecutor';
import { MapReduceExecutor } from '../agents/executors/MapReduceExecutor';
import { AgentLogger, VscodeOutputChannelLogger, WebviewLogger } from './logging';
import { LLMService } from './LLMService';
import { ToolRegistry } from './ToolRegistry';
import { StatsTracker } from './StatsTracker'; 

// 在文件顶部或一个新文件中定义Agent元数据
/**
 * Agent元数据定义。
 * 这是所有可用Agent的“注册表”，定义了它们的ID、名称、步骤和所需参数。
 */
const AGENT_DEFINITIONS: Record<string, AgentPlan> = {
    'docgen-project': {
        agentId: 'docgen-project',
        agentName: '项目级文档生成',
        steps: [
            { name: "规划: 分析项目结构", description: "使用LLM分析文件树，识别核心模块。", promptFiles: ['project_planner.yml'] },
            { name: "分析: 并行处理模块", description: "对每个模块进行深入分析，可能使用直接或Map-Reduce策略。", promptFiles: ['module_analysis_direct.yml', 'module_analysis_mapreduce.yml'] },
            { name: "综合: 生成最终文档", description: "将所有模块的分析结果汇编成一篇完整的技术文档。", promptFiles: ['project_synthesis.yml'] }
        ],
        parameters: [] // 此Agent无需用户输入额外参数
    },
    'docgen-module-direct': {
        agentId: 'docgen-module-direct',
        agentName: '模块级文档 (直接分析)',
        steps: [
            { name: "执行工具链", description: "按顺序执行文件读取和分析工具。", promptFiles: ['module_analysis_direct.yml'] },
            { name: "生成最终响应", description: "使用LLM整合工具输出，生成模块文档。" }
        ],
        parameters: [
            { name: 'module_path', description: '需要分析的模块/文件夹路径', type: 'path' }
        ]
    },
    'docgen-module-mapreduce': {
        agentId: 'docgen-module-mapreduce',
        agentName: '模块级文档 (摘要总结)',
        steps: [
            { name: "准备: 文件分批", description: "扫描指定路径下的所有文件并根据Token限制进行分批。" },
            { name: "Map阶段: 并行分析", description: "并行调用LLM为每个文件批次生成摘要。", promptFiles: ['module_analysis_mapreduce.yml'] },
            { name: "Reduce阶段: 综合摘要", description: "将所有批次的摘要合并，并由LLM生成最终的模块文档。" }
        ],
        parameters: [
            { name: 'module_path', description: '需要分析的模块/文件夹路径', type: 'path' }
        ]
    }
};

// 辅助函数：用于加载外部YAML文件
async function loadPromptFile(workspaceRoot: vscode.Uri, fileName: string): Promise<string> {
    const promptUri = vscode.Uri.joinPath(workspaceRoot, '.codewiki', fileName);
    try {
        const fileContent = await vscode.workspace.fs.readFile(promptUri);
        return Buffer.from(fileContent).toString('utf-8');
    } catch (e) {
        throw new Error(`无法加载提示词文件: ${fileName}。请确保它存在于 '.codewiki' 目录中。`);
    }
}


/**
 * AgentService 是UI层（如Commands, Webviews）与后台Agent执行逻辑之间的唯一接口。
 * 它负责组装Agent运行所需的一切，并启动它们。
 */
export class AgentService {
    private toolRegistry: ToolRegistry;
    
    constructor(private llmService: LLMService) {
        this.toolRegistry = new ToolRegistry(this.llmService);
    }
    
    public async initialize(defaultModelConfig: ModelConfig): Promise<void> {
        await this.toolRegistry.initialize(defaultModelConfig);
        console.log("AgentService initialized successfully.");
    }

    /**
     * 根据 Agent ID 获取其预定义的计划（元数据）。
     * @param agentId Agent的唯一标识符。
     * @returns 返回 AgentPlan 对象，如果未找到则返回 null。
     */
    public getAgentPlan(agentId: string): AgentPlan | null {
        const plan = AGENT_DEFINITIONS[agentId];
        return plan ? { ...plan } : null; // 返回一个副本以避免意外修改
    }

    public async prepareAndRunAgent(
        agentId: string,
        userInputs: Record<string, any>,
        modelConfig: ModelConfig,
        logger: AgentLogger
    ) {
        const runId = uuidv4();
        const agentPlan = this.getAgentPlan(agentId);
        
        if (!agentPlan) {
            const errorMsg = `Agent with ID "${agentId}" not found.`;
            logger.onAgentEnd({ runId, status: 'failed', error: errorMsg });
            return;
        }
        
        // 填充从前端接收到的参数值
        agentPlan.parameters.forEach(param => {
            if (userInputs[param.name] !== undefined) {
                param.value = userInputs[param.name];
            }
        });

        const statsTracker = new StatsTracker();
        
        const context: AgentContext = {
            logger,
            llmService: this.llmService,
            toolRegistry: this.toolRegistry,
            modelConfig,
            statsTracker // 注入到上下文中

        };
        
        const workspaceRoot = vscode.workspace.workspaceFolders?.[0].uri;
        if (!workspaceRoot) {
            logger.onAgentEnd({ runId, status: 'failed', error: 'No workspace folder open.' });
            return;
        }

        // --- 核心逻辑重构 ---
        let finalOutput: any = "执行成功"; // 默认成功消息

        try {
            switch (agentId) {
                case 'docgen-project': {
                    const projPrompts = {
                        plannerPrompt: await loadPromptFile(workspaceRoot, 'project_planner.yml'),
                        directAnalysisPrompt: await loadPromptFile(workspaceRoot, 'module_analysis_direct.yml'),
                        mapReduceAnalysisPrompt: await loadPromptFile(workspaceRoot, 'module_analysis_mapreduce.yml'),
                        synthesisPrompt: await loadPromptFile(workspaceRoot, 'project_synthesis.yml'),
                    };
                    const orchestrator = new ProjectDocumentationOrchestrator(context, projPrompts);
                    // Orchestrator 只负责执行，不负责上报最终状态
                    await orchestrator.run(runId);
                    break;
                }
                
                case 'docgen-module-direct': {
                    const directPromptYaml = await loadPromptFile(workspaceRoot, 'module_analysis_direct.yml');
                    const modulePathParam = agentPlan.parameters.find(p => p.name === 'module_path');
                    if (!modulePathParam || !modulePathParam.value) {
                         throw new Error("Missing required parameter: module_path");
                    }
                    const directInputs = { module_path: modulePathParam.value };

                    const toolchainExecutor = new ToolChainExecutor(context);
                    // 捕获执行器的结果作为 finalOutput
                    finalOutput = await toolchainExecutor.run(runId, directPromptYaml, directInputs);
                    break;
                }

                case 'docgen-module-mapreduce': {
                    const mapreducePromptYaml = await loadPromptFile(workspaceRoot, 'module_analysis_mapreduce.yml');
                    const modulePathParam = agentPlan.parameters.find(p => p.name === 'module_path');
                    if (!modulePathParam || !modulePathParam.value) {
                         throw new Error("Missing required parameter: module_path");
                    }
                    const mapreduceInputs = { module_path: modulePathParam.value };

                    const mapReduceExecutor = new MapReduceExecutor(context);
                     // 捕获执行器的结果作为 finalOutput
                    finalOutput = await mapReduceExecutor.run(runId, mapreducePromptYaml, mapreduceInputs);
                    break;
                }

                default:
                    throw new Error(`Execution for agent "${agentId}" is not yet implemented.`);
            }
            
            // 如果成功执行到这里，计算最终统计数据并发送成功事件
            const finalStats = statsTracker.getFinalStats();
            logger.onAgentEnd({ runId, status: 'completed', finalOutput, stats: finalStats });

        } catch (error: any) {
            // 如果任何步骤失败，计算统计数据并发送失败事件
            const finalStats = statsTracker.getFinalStats();
            logger.onAgentEnd({ runId, status: 'failed', error: error.message, stats: finalStats });
        }
    }

    public async runProjectDocumentation(modelConfig: ModelConfig) {
        const logger = new VscodeOutputChannelLogger("CodeWiki Project Documentation");
        await this.prepareAndRunAgent('docgen-project', {}, modelConfig, logger);
    }
    
    public async runActionFromWebview(
        yamlContent: string, 
        userInputs: Record<string, any>, 
        modelConfig: ModelConfig,
        webview: vscode.Webview
    ) {
        const logger = new WebviewLogger(webview);
        const statsTracker = new StatsTracker(); // <-- 为 webview action 也创建 tracker
        const context: AgentContext = {
            logger,
            llmService: this.llmService,
            toolRegistry: this.toolRegistry,
            modelConfig,
            statsTracker,
        };
        const runId = uuidv4();

        try {
            const executor = new ToolChainExecutor(context);
            const result = await executor.run(runId, yamlContent, userInputs);
            const finalStats = statsTracker.getFinalStats();
            logger.onAgentEnd({ runId, status: 'completed', finalOutput: result, stats: finalStats });

        } catch (error: any) {
            if (!(error as any).__logged) {
                 const finalStats = statsTracker.getFinalStats();
                 logger.onAgentEnd({ runId, status: 'failed', error: error.message, stats: finalStats });
            }
        }
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/services/LLMService.ts ---
// src/extension/LLMService.ts

import vscode from 'vscode';
import { ChatMessage, ModelConfig } from '../../common/types';
import { ChatOpenAI } from '@langchain/openai';
import { HumanMessage, AIMessage, BaseMessage } from '@langchain/core/messages';
import { BaseChatModel } from '@langchain/core/language_models/chat_models';
import { ChatGoogleGenerativeAI } from '@langchain/google-genai';

/**
 * 标志位：设置为 true 以使用 Gemini，设置为 false 则使用 settings.json 中的模型配置。
 * 使用 Gemini 前，请确保已安装 `@langchain/google-genai` 并在 `.codewiki/.env` 文件中配置了 GOOGLE_API_KEY。
 */
const USE_GEMINI = false;

/**
 * 创建模型实例时使用的选项。
 */
export interface CreateModelOptions {
    // 当不使用 Gemini 时，需要此配置来创建 OpenAI 或兼容模型
    modelConfig: ModelConfig; 
    temperature?: number;
    streaming?: boolean;
}

/**
 * 定义一个可以放入队列的LLM任务。
 * 它包含一个返回Promise的函数，以及用于解决该Promise的resolver和rejecter。
 */
type LlmTask<T> = {
    task: () => Promise<T>;
    resolve: (value: T) => void;
    reject: (reason?: any) => void;
};

/**
 * 从工作区的 .codewiki/.env 文件中安全地读取 Google API 密钥。
 * @returns {Promise<string | undefined>} 返回 API 密钥或 undefined。
 */
async function getGoogleApiKey(): Promise<string | undefined> {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) {
        return undefined;
    }
    const workspaceRoot = workspaceFolders[0].uri;
    const envPath = vscode.Uri.joinPath(workspaceRoot, '.codewiki', '.env');

    try {
        const contentBytes = await vscode.workspace.fs.readFile(envPath);
        const content = Buffer.from(contentBytes).toString('utf-8');
        const lines = content.split('\n');
        for (const line of lines) {
            const trimmedLine = line.trim();
            if (trimmedLine.startsWith('GOOGLE_API_KEY=')) {
                return trimmedLine.substring('GOOGLE_API_KEY='.length).trim();
            }
        }
    } catch (error) {
        if (!(error instanceof vscode.FileSystemError && error.code === 'FileNotFound')) {
            console.error("Error reading .codewiki/.env file:", error);
        }
    }
    return undefined;
}


/**
 * 服务类，用于与大语言模型交互。
 * 此类现在是创建模型实例的唯一入口点，整合了 OpenAI 和 Gemini 的逻辑。
 */
export class LLMService {
    private _abortController: AbortController | null = null;
    private requestQueue: LlmTask<any>[] = [];
    private isProcessingQueue = false;
    private readonly RATE_LIMIT_DELAY_MS = 1500; // 为1 QPS设置1.5秒延迟，提供安全缓冲

    constructor() {}

    /**
     * 统一的模型创建工厂方法。
     * 根据 USE_GEMINI 标志和传入的选项，创建并返回一个 LLM 实例。
     * @param options - 创建模型所需的配置，包括温度、是否流式等。
     * @returns {Promise<BaseChatModel>} 一个配置好的 LangChain 模型实例。
     */
    public async createModel(options: CreateModelOptions): Promise<BaseChatModel> {
        const { modelConfig, temperature = 0.7, streaming = false } = options;

        if (USE_GEMINI) {
            console.log("[LLMService] Creating model using Google Gemini.");
            const apiKey = await getGoogleApiKey();
            if (!apiKey) {
                throw new Error("Gemini execution failed: 'GOOGLE_API_KEY' not found in your .codewiki/.env file.");
            }
            // Gemini 对温度的支持可能与 OpenAI 不同，这里直接传入
            return new ChatGoogleGenerativeAI({
                model: "gemini-2.5-flash", 
                apiKey: apiKey,
                temperature,
                // Gemini 的 streaming 是通过 .stream() 方法控制的，这里设置 streaming 属性可能无效，但为了接口统一保留
            });
        }
        
        // 默认使用 OpenAI 或兼容的代理
        const url = new URL(modelConfig.baseUrl);
        if (!url.pathname.includes('/v1')) {
            url.pathname = ('/v1' + url.pathname).replace(/\/+/g, '/');
        }
        const finalBaseUrl = url.toString().replace(/\/$/, '');

        return new ChatOpenAI({
            modelName: modelConfig.modelId,
            apiKey: modelConfig.apiKey,
            streaming,
            temperature,
            configuration: {
                baseURL: finalBaseUrl,
            }
        });
    }

    /**
     * 将一个非流式的LLM调用任务加入队列，并由调度器按速率限制执行。
     * 这是所有Agent和Tool进行非流式调用的新入口点。
     * @param task 一个返回LLM调用Promise的函数，例如 `() => llm.invoke(messages)`
     * @returns 一个在任务完成时解析的Promise
     */
    public scheduleLlmCall<T>(task: () => Promise<T>): Promise<T> {
        console.log(`[LLMService] A new call was scheduled. Queue size: ${this.requestQueue.length + 1}`);
        return new Promise<T>((resolve, reject) => {
            this.requestQueue.push({ task, resolve, reject });
            this.processQueue();
        });
    }

    private async processQueue() {
        if (this.isProcessingQueue || this.requestQueue.length === 0) {
            return;
        }

        this.isProcessingQueue = true;
        const { task, resolve, reject } = this.requestQueue.shift()!;
        
        console.log(`[LLMService] Executing call from queue. Remaining: ${this.requestQueue.length}`);

        try {
            const result = await task();
            resolve(result);
        } catch (error) {
            console.error("[LLMService] Error executing task from queue:", error);
            reject(error);
        } finally {
            // 在完成（无论成功或失败）后，等待指定的延迟
            await new Promise(res => setTimeout(res, this.RATE_LIMIT_DELAY_MS));
            
            this.isProcessingQueue = false;
            // 尝试处理队列中的下一个项目
            this.processQueue();
        }
    }
    // highlight-end

    /**
     * 获取模型的流式补全。
     * @param messages 聊天消息历史
     * @param config 选定的模型配置
     * @param onData 接收到数据块时的回调
     * @param onEnd 完成时的回调
     * @param onError 出错时的回调
     */
    public async getCompletion(
        messages: ChatMessage[],
        config: ModelConfig,
        onData: (chunk: string) => void,
        onEnd: () => void,
        onError: (error: any) => void
    ): Promise<void> {
        this._abortController = new AbortController();
        const signal = this._abortController.signal;
        let llm: BaseChatModel;

        try {
            // 使用新的工厂方法创建模型实例
            llm = await this.createModel({
                modelConfig: config,
                streaming: true,
                temperature: 0.7 // Standard temperature for chat
            });

            const langchainMessages: BaseMessage[] = messages.map(msg => {
                return msg.role === 'user' ? new HumanMessage(msg.content) : new AIMessage(msg.content);
            });

            const stream = await llm.stream(langchainMessages, {
                signal: signal,
            });

            for await (const chunk of stream) {
                if (chunk.content) {
                    onData(chunk.content as string);
                }
            }

        } catch (error: any) {
            if (signal.aborted) {
                console.log('Request aborted by user.');
            } else {
                console.error("--- LANGCHAIN REQUEST FAILED ---");
                // 构造错误信息，因为我们不知道是哪个URL
                 if (error instanceof Error) {
                     console.error("Full Error Object:", error);
                     onError(error);
                 } else {
                     console.error("Unknown Error:", error);
                     onError(new Error(String(error)));
                 }
                console.error("--- END OF ERROR ---");
            }
        } finally {
            onEnd();
            this._abortController = null;
        }
    }

    public abortRequest() {
        if (this._abortController) {
            this._abortController.abort();
        }
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/services/StatsTracker.ts ---
// src/extension/services/StatsTracker.ts
import { get_encoding, Tiktoken } from "tiktoken";

export interface AgentRunStats {
    duration: string;
    totalTokens: number;
    promptTokens: number;
    completionTokens: number;
}

/**
 * 在单次 Agent 运行期间跟踪和计算统计信息。
 */
export class StatsTracker {
    private startTime: number;
    private totalPromptTokens: number = 0;
    private totalCompletionTokens: number = 0;
    private tokenizer: Tiktoken;

    constructor() {
        this.startTime = Date.now();
        // 使用一个通用的编码器来估算，cl100k_base 适用于大多数现代 OpenAI 模型
        this.tokenizer = get_encoding("cl100k_base");
    }

    /**
     * 记录一次LLM调用的Token消耗。
     * @param prompt - 发送给模型的完整提示文本。
     * @param completion - 从模型接收到的完整响应文本。
     */
    public add(prompt: string, completion: string): void {
        try {
            const promptTokens = this.tokenizer.encode(prompt).length;
            const completionTokens = this.tokenizer.encode(completion).length;
            
            this.totalPromptTokens += promptTokens;
            this.totalCompletionTokens += completionTokens;
        } catch (e) {
            console.error("Token counting failed:", e);
        }
    }

    /**
     * 计算并返回最终的统计数据。
     * @returns {AgentRunStats} 最终的统计对象。
     */
    public getFinalStats(): AgentRunStats {
        const endTime = Date.now();
        const durationMs = endTime - this.startTime;
        const durationSec = (durationMs / 1000).toFixed(2);
        
        // 释放 tokenizer 资源
        this.tokenizer.free();

        return {
            duration: `${durationSec}s`,
            promptTokens: this.totalPromptTokens,
            completionTokens: this.totalCompletionTokens,
            totalTokens: this.totalPromptTokens + this.totalCompletionTokens,
        };
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/services/ToolRegistry.ts ---
// src/extension/services/ToolRegistry.ts (完整文件)

import { StructuredTool } from '@langchain/core/tools';
import { ModelConfig } from '../../common/types';
import { GetFileSummariesTool, GetFilesContentByListTool, GetAllFilesContentTool, GetDirectoryTreeTool } from '../tools/fileSystemTools';
import { createFileSelectorLLMTool } from '../tools/llmTools';
import { LLMService } from './LLMService';

/**
 * 负责在扩展启动时初始化所有工具，并按需提供。
 * 这是一个集中管理工具的单例服务。
 */
export class ToolRegistry {
    private tools = new Map<string, StructuredTool>();

    constructor(private llmService: LLMService) {}

    /**
     * 初始化所有工具，特别是那些需要LLM实例的工具。
     * @param defaultModelConfig 用于创建工具内部LLM的默认模型配置。
     */
    public async initialize(defaultModelConfig: ModelConfig): Promise<void> {
        // 为工具创建一个专用的、非流式的LLM实例
        const toolLlm = await this.llmService.createModel({
            modelConfig: defaultModelConfig,
            temperature: 0.1,
            streaming: false,
        });

        const allTools: StructuredTool[] = [
            new GetFileSummariesTool(),
            new GetFilesContentByListTool(),
            new GetAllFilesContentTool(),
            new GetDirectoryTreeTool(),
            createFileSelectorLLMTool(toolLlm, this.llmService),
        ];

        for (const tool of allTools) {
            this.tools.set(tool.name, tool);
        }
        console.log("ToolRegistry initialized with tools:", Array.from(this.tools.keys()));
    }

    /**
     * 根据名称获取单个工具。
     * @param name 工具的名称。
     * @returns 返回工具实例，如果找不到则返回undefined。
     */
    public getTool(name: string): StructuredTool | undefined {
        return this.tools.get(name);
    }
    
    /**
     * 根据名称列表获取一组工具。
     * @param names 工具名称的数组。
     * @returns 返回工具实例的数组。
     * @throws 如果有任何一个工具找不到，则抛出错误。
     */
    public getTools(names: string[]): StructuredTool[] {
         return names.map(name => {
             const tool = this.getTool(name);
             if (!tool) {
                 throw new Error(`Tool "${name}" not found in registry.`);
             }
             return tool;
         });
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/services/logging.ts ---
// src/extension/services/logging.ts (修改后完整文件)

import * as vscode from 'vscode';
import { AgentPlan, StepExecution, StepUpdate, StepResult, StreamChunk, AgentResult } from '../../common/types';
import * as path from 'path'; // 引入 path 模块

/**
 * Agent 执行过程中的通用日志记录器接口。
 * 这使得核心逻辑可以与具体的UI（如OutputChannel或Webview）解耦。
 */
export interface AgentLogger {
    info(message: string): void;
    warn(message:string): void;
    error(message: string, error?: Error): void;
    log(message: string): void; // 用于原始输出，如LLM的流式数据
    logLine(message: string): void; // 新增：用于打印带换行的详细日志
    show(preserveFocus?: boolean): void; // 可选，用于显示日志面板

    // --- 新增的结构化事件方法 ---
    onPlanGenerated(plan: AgentPlan): void;
    onStepStart(step: StepExecution): void;
    onStepUpdate(update: StepUpdate): void;
    onStepEnd(result: StepResult): void;
    onStreamChunk(chunk: StreamChunk): void;
    onAgentEnd(result: AgentResult): void;
}

/**
 * AgentLogger接口的一个实现，它将日志写入VS Code的Output Channel。
 */
export class VscodeOutputChannelLogger implements AgentLogger {
    private readonly channel: vscode.OutputChannel;
    private streamBuffer: { [key: string]: string } = {}; // 用于缓存流式数据

    constructor(channelName: string) {
        this.channel = vscode.window.createOutputChannel(channelName);
    }

    public info(message: string): void {
        this.channel.appendLine(`[INFO] ${message}`);
    }

    public warn(message: string): void {
        this.channel.appendLine(`[WARN] ${message}`);
    }

    public error(message: string, error?: Error): void {
        this.channel.appendLine(`[ERROR] ${message}`);
        if (error?.stack) {
            this.channel.appendLine(error.stack);
        }
    }

    public log(message: string): void {
        // 对于原始日志，我们不添加前缀，直接追加
        this.channel.append(message);
    }
    
    public logLine(message: string): void {
        this.channel.appendLine(message);
    }

    public show(preserveFocus: boolean = true): void {
        this.channel.show(preserveFocus);
    }

     /**
     * 新接口方法的优化实现
     */
    public onPlanGenerated(plan: AgentPlan): void {
        this.channel.appendLine(`[PLAN] Agent "${plan.agentName}" is ready.`);
        plan.steps.forEach((step, i) => {
            this.channel.appendLine(`  [Step ${i+1}] ${step.name}: ${step.description}`);
        });
    }

    public onStepStart(step: StepExecution): void {
        const id = step.taskId ? `${step.stepName} (Task: ${step.taskId})` : step.stepName;
        this.channel.appendLine(`\n--- [START] ${id} ---`);
        // 初始化当前任务的流式缓存
        if (step.taskId) {
            this.streamBuffer[step.taskId] = '';
        }
    }
    
    /**
     * 核心修改：对 onStepUpdate 的内容进行审查和简化
     */
    public onStepUpdate(update: StepUpdate): void {
        if (update.type === 'output') {
            // 检查元数据中是否包含文件路径信息
            if (update.metadata?.type === 'file' && typeof update.metadata.path === 'string') {
                // 如果是文件输出，只打印文件名
                const fileName = path.basename(update.metadata.path);
                this.channel.appendLine(`[OUTPUT] Generated file: ${fileName}`);
            } else {
                // 对于其他输出，提取内容并进行长度限制
                let outputStr = '';
                if (typeof update.data === 'object' && update.data !== null && 'content' in update.data) {
                    outputStr = String(update.data.content);
                } else {
                    outputStr = typeof update.data === 'string' ? update.data : JSON.stringify(update.data);
                }
                
                // // 如果内容过长，只打印摘要信息，否则打印完整内容
                // const MAX_LENGTH = 150;
                // if (outputStr.length > MAX_LENGTH) {
                //     this.channel.appendLine(`[OUTPUT] ${outputStr.substring(0, MAX_LENGTH)}... (Content too long)`);
                // } else {
                //     this.channel.appendLine(`[OUTPUT] ${outputStr}`);
                // }
            }
        }
        // 其他类型的 update (input, llm-request) 将被忽略，不打印
    }
    
    /**
     * 核心修改：onStepEnd 不再打印流式缓存，因为 onStreamChunk 已被禁用
     */
    public onStepEnd(result: StepResult): void {
        const id = result.taskId ? `${result.status.toUpperCase()} (Task: ${result.taskId})` : result.status.toUpperCase();
        
        // 如果失败，打印错误信息
        if (result.status === 'failed' && result.error) {
            this.channel.appendLine(`[ERROR] ${result.error}`);
        }
        
        this.channel.appendLine(`--- [${id}] ---`);
        // 不再需要处理 streamBuffer
    }

    /**
     * 核心修改：onStreamChunk 完全禁用，不执行任何操作
     */
    public onStreamChunk(chunk: StreamChunk): void {
        // Do nothing. We don't want to log stream chunks to the output channel.
    }

    public onAgentEnd(result: AgentResult): void {
        this.channel.appendLine(`\n====== [AGENT ${result.status.toUpperCase()}] ======`);
        if(result.error) {
            this.error("Agent failed", new Error(result.error));
        }
    }
}

/**
 * AgentLogger接口的一个实现，它将日志通过postMessage发送到Webview。
 */
export class WebviewLogger implements AgentLogger {
    constructor(private webview: vscode.Webview) {}

    info(message: string): void {
        // 只发送简洁的状态更新
        this.webview.postMessage({ command: 'agentStatusUpdate', payload: { status: 'info', message }});
    }

    warn(message: string): void {
        this.webview.postMessage({ command: 'agentStatusUpdate', payload: { status: 'warn', message }});
    }

    error(message: string, error?: Error): void {
        const errorMessage = error ? `${message}: ${error.message}` : message;
        this.webview.postMessage({ command: 'requestFailed', payload: { error: errorMessage }});
    }

    log(message: string): void {
        // 流式数据有专门的命令
        this.webview.postMessage({ command: 'streamData', payload: message });
    }

    logLine(message: string): void {
        // 对于Webview，一行详细日志可以被视为一个'info'状态
        this.info(message);
    }

    show(preserveFocus?: boolean | undefined): void {
        // Webview 默认就是可见的，此方法可以为空
    }

    // --- highlight-start ---
    // --- 任务1实现：填充结构化事件发送方法 ---
    public onPlanGenerated(plan: AgentPlan): void {
        this.webview.postMessage({ command: 'agent:planGenerated', payload: plan });
    }
    public onStepStart(step: StepExecution): void {
        this.webview.postMessage({ command: 'agent:stepStart', payload: step });
    }
    public onStepUpdate(update: StepUpdate): void {
        this.webview.postMessage({ command: 'agent:stepUpdate', payload: update });
    }
    public onStepEnd(result: StepResult): void {
        this.webview.postMessage({ command: 'agent:stepEnd', payload: result });
    }
    public onStreamChunk(chunk: StreamChunk): void { 
        this.webview.postMessage({ command: 'agent:streamChunk', payload: chunk });
    }
    public onAgentEnd(result: AgentResult): void {
        this.webview.postMessage({ command: 'agent:end', payload: result });
    }
    // --- highlight-end ---
}

--------------------------------------------------------------------------------

--- file_path: extension/tools/fileSystemTools.ts ---
// src/extension/tools/fileSystemTools.ts (完整文件)

import * as vscode from 'vscode';
import * as path from 'path';
import { z } from 'zod';
import { StructuredTool } from '@langchain/core/tools';
import { languageFilters, GENERIC_EXCLUDE, LanguageFilter } from '../config/fileFilters';

/**
 * 获取当前工作区的根路径。
 * @returns {string} 工作区根目录的绝对路径。
 * @throws {Error} 如果没有打开的工作区。
 */
function getWorkspaceRoot(): string {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders || workspaceFolders.length === 0) {
        throw new Error("没有打开的工作区。请先打开一个项目文件夹。");
    }
    return workspaceFolders[0].uri.fsPath;
}

/**
 * 新增的辅助函数，用于递归获取过滤后的文件路径。
 * @param dirUri 起始目录的URI
 * @param language 用于选择过滤规则的语言
 * @returns {Promise<vscode.Uri[]>} 过滤后的文件URI列表
 */
async function getFilteredFilePathsRecursive(dirUri: vscode.Uri, language: string = 'unknown'): Promise<vscode.Uri[]> {
    let files: vscode.Uri[] = [];
    const filter: LanguageFilter = languageFilters[language.toLowerCase()] || languageFilters.unknown;

    try {
        const entries = await vscode.workspace.fs.readDirectory(dirUri);

        for (const [name, type] of entries) {
            // 检查是否在通用排除列表中
            if (GENERIC_EXCLUDE.includes(name)) {
                continue;
            }

            const entryUri = vscode.Uri.joinPath(dirUri, name);
            if (type === vscode.FileType.File) {
                const extension = path.extname(name);
                const shouldInclude = filter.include.includes(extension);
                const shouldExclude = filter.exclude.some(pattern => name.endsWith(pattern));

                if (shouldInclude && !shouldExclude) {
                    files.push(entryUri);
                }
            } else if (type === vscode.FileType.Directory) {
                files = files.concat(await getFilteredFilePathsRecursive(entryUri, language));
            }
        }
    } catch (error) {
        console.warn(`Could not read directory ${dirUri.fsPath}:`, error);
    }
    return files;
}

/**
 * 一个LangChain工具，用于获取指定目录下所有文件的路径和内容摘要。
 * 摘要是文件的前20行。
 */
export class GetFileSummariesTool extends StructuredTool {
    static lc_name() {
        return "GetFileSummariesTool";
    }

    name = "get_file_summaries";
    description = "获取指定目录中所有文件的路径和内容摘要（文件的前20行）。用于在阅读完整文件之前，快速了解一个模块的结构。";

    schema = z.object({
        path: z.string().describe("从工作区根目录出发的相对路径。"),
        language: z.string().optional().describe("项目的编程语言 (例如 'typescript', 'python')，用于智能过滤文件。如果未提供，则使用通用规则。"),
    });

    protected async _call({ path: relativePath }: z.infer<typeof this.schema>): Promise<string> {
        try {
            const workspaceRoot = getWorkspaceRoot();
            const absolutePath = path.join(workspaceRoot, relativePath);

            const entries = await vscode.workspace.fs.readDirectory(vscode.Uri.file(absolutePath));
            const fileSummaries: string[] = [];

            for (const [name, type] of entries) {
                if (type === vscode.FileType.File) {
                    const filePath = path.join(absolutePath, name);
                    const fileUri = vscode.Uri.file(filePath);
                    
                    const contentBytes = await vscode.workspace.fs.readFile(fileUri);
                    const content = Buffer.from(contentBytes).toString('utf-8');
                    const summary = content.split('\n').slice(0, 20).join('\n');
                    
                    const fileRelativePath = path.relative(workspaceRoot, filePath);

                    fileSummaries.push(
                        `--- FILE: ${fileRelativePath.replace(/\\/g, '/')} ---\n${summary}\n--- END OF SUMMARY ---\n`
                    );
                }
            }

            if (fileSummaries.length === 0) {
                return `在目录 "${relativePath}" 中没有找到任何文件。`;
            }

            return fileSummaries.join('\n');
        } catch (error: any) {
            return `获取路径 "${relativePath}" 的文件摘要时出错: ${error.message}`;
        }
    }
}


/**
 * 一个LangChain工具，根据提供的文件路径列表，获取这些文件的完整内容。
 */
export class GetFilesContentByListTool extends StructuredTool {
    static lc_name() {
        return "GetFilesContentByListTool";
    }

    name = "get_files_content_by_list";
    description = "根据一个包含相对路径的列表，读取这些文件的完整内容。这个列表通常是文件选择工具的输出。";

    schema = z.object({
        file_paths: z.array(z.string()).describe("一个包含文件相对路径的数组，路径从工作区根目录开始计算。"),
    });

    protected async _call({ file_paths }: z.infer<typeof this.schema>): Promise<string> {
        if (!file_paths || file_paths.length === 0) {
            return "输入的文件列表为空，没有内容可以读取。";
        }

        try {
            const workspaceRoot = getWorkspaceRoot();
            const contentPromises = file_paths.map(async (relativePath) => {
                const absolutePath = path.join(workspaceRoot, relativePath);
                const fileUri = vscode.Uri.file(absolutePath);
                
                try {
                    const contentBytes = await vscode.workspace.fs.readFile(fileUri);
                    const content = Buffer.from(contentBytes).toString('utf-8');
                    return `--- FILE: ${relativePath.replace(/\\/g, '/')} ---\n${content}\n--- END OF FILE ---\n`;
                } catch (fileError: any) {
                    // 如果单个文件读取失败，返回错误信息而不是让整个工具失败
                    return `--- FILE: ${relativePath.replace(/\\/g, '/')} ---\n错误: 无法读取文件。 ${fileError.message}\n--- END OF FILE ---\n`;
                }
            });

            const allContents = await Promise.all(contentPromises);
            return allContents.join('\n');

        } catch (error: any) {
            // 捕获 getWorkspaceRoot 的错误
            return `获取文件内容时出错: ${error.message}`;
        }
    }
}

/**
 * 一个LangChain工具，用于递归获取指定目录下所有文件的完整内容。
 */
export class GetAllFilesContentTool extends StructuredTool {
    static lc_name() {
        return "GetAllFilesContentTool";
    }

    name = "get_all_files_content";
    description = "递归地获取指定目录及其所有子目录中所有文件的完整内容。当需要对一个模块的所有代码进行全面分析时使用。";

    schema = z.object({
        path: z.string().describe("从工作区根目录出发的相对路径。"),
        language: z.string().optional().describe("项目的编程语言 (例如 'typescript', 'python')，用于智能过滤文件。如果未提供，则使用通用规则。"),
    });

    /**
     * 递归遍历目录并收集文件内容。
     * @param dirUri 要遍历的目录的 URI。
     * @param workspaceRoot 工作区的根路径，用于计算相对路径。
     * @returns 一个包含文件内容和标记的字符串数组。
     */
    private async _traverseDirectory(dirUri: vscode.Uri, workspaceRoot: string): Promise<string[]> {
        let allContents: string[] = [];
        const entries = await vscode.workspace.fs.readDirectory(dirUri);

        for (const [name, type] of entries) {
            const entryUri = vscode.Uri.joinPath(dirUri, name);
            if (type === vscode.FileType.File) {
                const fileRelativePath = path.relative(workspaceRoot, entryUri.fsPath).replace(/\\/g, '/');
                try {
                    const contentBytes = await vscode.workspace.fs.readFile(entryUri);
                    const content = Buffer.from(contentBytes).toString('utf-8');
                    allContents.push(`--- FILE: ${fileRelativePath} ---\n${content}\n--- END OF FILE ---\n`);
                } catch (fileError: any) {
                    allContents.push(`--- FILE: ${fileRelativePath} ---\n错误: 无法读取文件。 ${fileError.message}\n--- END OF FILE ---\n`);
                }
            } else if (type === vscode.FileType.Directory) {
                // 如果是目录，则递归调用
                const subDirContents = await this._traverseDirectory(entryUri, workspaceRoot);
                allContents = allContents.concat(subDirContents);
            }
        }
        return allContents;
    }

    protected async _call({ path: relativePath, language }: z.infer<typeof this.schema>): Promise<string> {
        try {
            const workspaceRoot = getWorkspaceRoot();
            const absolutePath = path.join(workspaceRoot, relativePath);
            const dirUri = vscode.Uri.file(absolutePath);

            // highlight-start
            // 使用新的过滤辅助函数
            const fileUris = await getFilteredFilePathsRecursive(dirUri, language);
            // highlight-end

            if (fileUris.length === 0) {
                return `在目录 "${relativePath}" 及其子目录中没有找到与语言 '${language}' 相关的任何文件。`;
            }
            
            const contentPromises = fileUris.map(async (uri) => {
                 const fileRelativePath = path.relative(workspaceRoot, uri.fsPath).replace(/\\/g, '/');
                 try {
                    const contentBytes = await vscode.workspace.fs.readFile(uri);
                    const content = Buffer.from(contentBytes).toString('utf-8');
                    return `--- FILE: ${fileRelativePath} ---\n${content}\n--- END OF FILE ---\n`;
                 } catch (fileError: any) {
                    return `--- FILE: ${fileRelativePath} ---\n错误: 无法读取文件。 ${fileError.message}\n--- END OF FILE ---\n`;
                 }
            });
            
            const allContents = await Promise.all(contentPromises);
            return allContents.join('\n');

        } catch (error: any) {
            return `递归获取路径 "${relativePath}" 的所有文件内容时出错: ${error.message}`;
        }
    }
}

/**
 * 一个LangChain工具，用于生成指定路径的目录树结构。
 */
export class GetDirectoryTreeTool extends StructuredTool {
    static lc_name() {
        return "GetDirectoryTreeTool";
    }

    name = "get_directory_tree";
    // 更新描述，告知 AI 此工具输出紧凑的树状结构以节省 Token
    description = "生成给定路径的目录和文件树状结构图，并以紧凑的、节省 Token 的格式展示。会自动过滤掉常见的非源码目录（如 .git, .vscode, build, target 等）。用于快速了解项目的整体文件布局。";

    schema = z.object({
        path: z.string().describe("从工作区根目录出发的相对路径。"),
    });

    private readonly ignoreDirs: Set<string> = new Set([
        '.git',
        '.vscode',
        '.idea',
        'node_modules',
        'build',
        'dist',
        'target',
        'out',
        'bin',
        '.codewiki',
        '__pycache__',
    ]);

    /**
     * 递归生成格式化的目录树。
     * @param dirUri 要生成树的目录的 URI。
     * @param prefix 用于排版的树状前缀字符串 (例如 "│   " 或 "    ")。
     * @returns 一个包含格式化后树形结构行的字符串数组。
     */
    private async _generateTree(dirUri: vscode.Uri, prefix: string): Promise<string[]> {
        let treeLines: string[] = [];
        const entries = await vscode.workspace.fs.readDirectory(dirUri);

        // 先过滤掉需要忽略的目录/文件
        const filteredEntries = entries.filter(([name, _]) => !this.ignoreDirs.has(name));
        const count = filteredEntries.length;

        for (let i = 0; i < count; i++) {
            const [name, type] = filteredEntries[i];
            const isLast = i === count - 1; // 判断是否是当前目录的最后一个条目

            // 根据是否为最后一个条目，选择不同的连接符
            const connector = isLast ? '└── ' : '├── ';
            treeLines.push(`${prefix}${connector}${name}`);

            if (type === vscode.FileType.Directory) {
                // 为下一层递归计算新的前缀
                // 如果当前是最后一个，下一层的前缀使用空格；否则使用竖线连接
                const newPrefix = prefix + (isLast ? '    ' : '│   ');
                const subTreeLines = await this._generateTree(vscode.Uri.joinPath(dirUri, name), newPrefix);
                treeLines = treeLines.concat(subTreeLines);
            }
        }
        return treeLines;
    }

    protected async _call({ path: relativePath }: z.infer<typeof this.schema>): Promise<string> {
        try {
            const workspaceRoot = getWorkspaceRoot();
            if (!relativePath || relativePath === '/' || relativePath === '\\') {
                relativePath = '.';
            }
            const absolutePath = path.join(workspaceRoot, relativePath);
            const dirUri = vscode.Uri.file(absolutePath);

            try {
                const stat = await vscode.workspace.fs.stat(dirUri);
                if (stat.type !== vscode.FileType.Directory) {
                    return `错误：路径 "${relativePath}" 不是一个目录。`;
                }
            } catch (e) {
                return `错误：路径 "${relativePath}" 不存在或无法访问。`;
            }

            const displayRoot = relativePath === '.' ? '.' : `./${relativePath.replace(/\\/g, '/')}`;

            let treeLines = [displayRoot];
            // 初始调用时，前缀为空字符串 ""
            const subTree = await this._generateTree(dirUri, "");
            treeLines = treeLines.concat(subTree);

            if (treeLines.length === 1) {
                return `${displayRoot} (目录为空或所有内容均被过滤)`;
            }

            return treeLines.join('\n');
        } catch (error: any) {
            return `生成路径 "${relativePath}" 的目录树时出错: ${error.message}`;
        }
    }
}


--------------------------------------------------------------------------------

--- file_path: extension/tools/llmTools.ts ---
// src/extension/tools/llmTools.ts (完整文件)

import { z } from 'zod';
import { StructuredTool } from '@langchain/core/tools';
import { BaseLanguageModel } from '@langchain/core/language_models/base';
import { ChatPromptTemplate } from '@langchain/core/prompts';
import { StringOutputParser } from '@langchain/core/output_parsers';
import { LLMService } from '../services/LLMService'; // 导入 LLMService

// 这是 FileSelectorLLMTool 内部使用的 Prompt 模板
const SELECTION_PROMPT = `You are an expert software engineer assistant. Your task is to analyze a list of file summaries and select the most relevant files based on a user's task description.

Analyze the following file summaries:
---
{file_summaries}
---

The user's task is: "{task_description}"

Based on this, which files are the most critical for understanding and completing the task?

Please provide your answer as a clean, comma-separated list of file paths. Do NOT include any other text, explanations, or formatting.

Example response:
src/common/types.ts,src/extension/LLMService.ts,src/webview/views/ChatView.ts
`;

/**
 * 一个内部类，代表了 LLM-as-a-Tool 的具体实现。
 * 我们不直接导出它，而是通过工厂函数创建。
 */
class FileSelectorLLMTool extends StructuredTool {
    static lc_name() {
        return "FileSelectorLLMTool";
    }

    name = "file_selector_llm_tool";
    // highlight-start
    description = "分析文件摘要列表和任务描述，以智能地选择最相关的文件。输出是一个包含文件路径的数组。";
    // highlight-end
    
    // 该工具的输入 schema
    schema = z.object({
        file_summaries: z.string().describe("一个包含所有文件摘要的单一字符串，每个摘要由标记分隔。"),
        task_description: z.string().describe("用于指导文件选择的目标或任务的描述。"),
    });

    // 持有传入的 LLM 实例
    private llm: BaseLanguageModel;
    private llmService: LLMService; // 新增

    constructor(llm: BaseLanguageModel, llmService: LLMService) { // 修改构造函数
        super(); // 调用父类构造函数
        this.llm = llm;
        this.llmService = llmService; // 存储 LLMService 实例
    }

    protected async _call({ file_summaries, task_description }: z.infer<typeof this.schema>): Promise<string> {
        try {
            // 1. 构建专门用于文件筛选的 Prompt
            const selectionPrompt = ChatPromptTemplate.fromTemplate(SELECTION_PROMPT);

            // 2. 构建一个临时的、用于该工具内部的 LangChain "子链"
            //    它接收格式化的 prompt，调用 LLM，然后解析出字符串结果。
            const selectionChain = selectionPrompt
                .pipe(this.llm)
                .pipe(new StringOutputParser());

            // 3. 调用子链来执行 LLM 推理
            console.log("Scheduling file_selector_llm_tool with task:", task_description);
            const llmResult = await this.llmService.scheduleLlmCall(() => 
                selectionChain.invoke({
                    file_summaries,
                    task_description
                })
            );

            // 4. 解析 LLM 返回的结果
            //    LLM 可能返回一些额外的空格或换行符，我们进行清理。
            //    我们期望的结果是 "path/a.ts, path/b.ts, ..."
            const cleanedResult = llmResult.replace(/```/g, '').trim(); // 移除代码块标记和多余空格
            const filePaths = cleanedResult.split(',')
                .map(p => p.trim())
                .filter(p => p.length > 0 && p.includes('/')); // 过滤掉空字符串和无效条目

            if (filePaths.length === 0) {
                console.warn("File selector LLM did not return any valid file paths.");
                return "[]"; // 返回一个表示空数组的JSON字符串
            }
            
            // 5. 将结果（一个字符串数组）序列化为 JSON 字符串返回。
            //    这是因为 LangChain 工具的标准输出是 string。
            //    我们的自定义 Agent Executor (将在下一阶段实现) 将负责解析这个JSON。
            return JSON.stringify(filePaths);

        } catch (error: any) {
            console.error("Error in FileSelectorLLMTool:", error);
            return `在文件选择LLM调用期间出错: ${error.message}`;
        }
    }
}

/**
 * 工厂函数，用于创建和配置 FileSelectorLLMTool。
 * @param llm - 一个配置好的、可用于调用的 BaseLanguageModel 实例。
 * @param llmService - 用于调度LLM调用的服务实例。
 * @returns {StructuredTool} 一个配置好的、可直接使用的工具实例。
 */
export function createFileSelectorLLMTool(llm: BaseLanguageModel, llmService: LLMService): StructuredTool {
    return new FileSelectorLLMTool(llm, llmService);
}

--------------------------------------------------------------------------------

--- file_path: test/suite/index.ts ---


--------------------------------------------------------------------------------

--- file_path: webview/components/AgentRunBlock.ts ---
// --- file_path: webview/components/AgentRunBlock.ts ---

import { AgentPlan, AgentResult, StepExecution, StepUpdate, StreamChunk, AgentPlanStep, StepResult } from '../../common/types';
import { marked } from 'marked';
import { vscode } from '../vscode';

type AgentStatus = 'planning' | 'validating' | 'executing' | 'completed' | 'failed' | 'cancelled';

interface ExecutionStepState extends StepExecution {
    logs: { type: 'input' | 'output' | 'llm-request', data: any, metadata?: Record<string, any> }[];
    isCollapsed: boolean;
    streamedContent: string;
    error?: string;
}

export class AgentRunBlock {
    private element: HTMLElement;
    private plan: AgentPlan;
    private onExecute: (params: Record<string, any>) => void;
    private status: AgentStatus = 'planning';
    private executionState: Map<string, ExecutionStepState> = new Map();
    private agentResult: AgentResult | null = null;
    private animatedStepIds: Set<string> = new Set();
    private stepElementsCache: Map<string, HTMLElement> = new Map(); // <-- 新增：缓存步骤 DOM 元素

    constructor(
        container: HTMLElement,
        plan: AgentPlan,
        onExecute: (params: Record<string, any>) => void
    ) {
        this.element = container;
        this.plan = plan;
        this.onExecute = onExecute;
        this.element.className = 'agent-run-block';

        this.render();
        this.setupEventListeners();
    }

    public updateStep(step: StepExecution | StepResult) {
        console.log('[AgentRunBlock] updateStep called with:', step); // <--- ADD THIS
        // console.log('[AgentRunBlock] current executionState before update:', new Map(this.executionState)); // <--- ADD THIS
        let existing = this.executionState.get(step.taskId || step.stepName);
        if (existing) {
            existing.status = step.status;
            if (step.status === 'failed' && 'error' in step) {
                existing.error = (step as any).error;
            }
        } else {
            const newStepState: ExecutionStepState = { ...step, logs: [], isCollapsed: false, streamedContent: '' };
            if (step.status === 'failed' && 'error' in step) {
                newStepState.error = (step as any).error;
            }
            existing = newStepState;
        }
        this.executionState.set(step.taskId || step.stepName, existing);
        this.render();
    }

    public addStepLog(update: StepUpdate) {
        // Use the stepName from the plan if taskId is not present, or a global key for logs not tied to a specific step/task.
        const stepKey = update.taskId ||
            (this.plan.steps.find(s => s.name === update.metadata?.stepNameHint)?.name) || // Heuristic if backend can provide a hint
            'global_logs'; // Fallback for truly global logs not tied to a task

        const stepState = this.executionState.get(stepKey) || Array.from(this.executionState.values()).find(s => s.stepName === stepKey);

        if (stepState && (update.type === 'input' || update.type === 'output' || update.type === 'llm-request')) {
            stepState.logs.push({ type: update.type, data: update.data, metadata: update.metadata });
            this.render();
        }
    }

    public appendStreamChunk(chunk: StreamChunk) {
        // 优先使用 taskId。
        // 后端 Executor 在发送 StreamChunk 时应该总是包含 taskId。
        const stepKey = chunk.taskId;

        if (!stepKey) {
            // 如果 taskId 真的缺失了，这是一个潜在的问题，需要排查后端逻辑。
            // 暂时打印警告并忽略这个数据块，以避免运行时错误和不正确的状态更新。
            console.warn('AgentRunBlock: StreamChunk received without taskId. This might indicate an issue in the backend. Chunk:', chunk);
            return;
        }

        const stepState = this.executionState.get(stepKey);

        if (stepState) {
            stepState.streamedContent += chunk.content;
            this.render(); // 重新渲染以显示更新的流式内容
        } else {
            // 如果根据 taskId 找不到对应的 stepState，这也是一个潜在问题。
            // 可能 updateStep 还没有为这个 taskId 创建状态，或者 taskId 错误。
            console.warn(`AgentRunBlock: Could not find step state for taskId '${stepKey}' to append stream chunk. Known taskIds:`, Array.from(this.executionState.keys()), "Chunk:", chunk);
        }
    }

    public setAgentResult(result: AgentResult) {
        this.status = result.status;
        this.agentResult = result;
        this.render();
    }

    // --- 渲染逻辑 ---

    private render() {
        const isPlanningReadOnly = this.status !== 'planning' && this.status !== 'validating';

        // --- 规划视图 ---
        const planningViewContainer = this.element.querySelector('.planning-view-container');
        if (!planningViewContainer) { // 首次渲染或从执行视图切回
            this.element.innerHTML = `<div class="planning-view-container"></div><div class="executing-view-container"></div>`;
        }
        const planningContainer = this.element.querySelector('.planning-view-container') as HTMLElement;
        planningContainer.innerHTML = this.renderPlanningView(isPlanningReadOnly);


        // --- 执行视图 ---
        const executingViewContainer = this.element.querySelector('.executing-view-container') as HTMLElement;

        if (isPlanningReadOnly) {
            if (!executingViewContainer.classList.contains('active')) { // 首次进入执行视图
                this.animatedStepIds.clear(); // 重置动画状态
                this.stepElementsCache.clear(); // 清空缓存的 DOM 元素
                executingViewContainer.classList.add('active');
            }
            this.renderExecutingViewContents(executingViewContainer);
        } else {
            executingViewContainer.classList.remove('active');
            executingViewContainer.innerHTML = ''; // 清空执行视图内容
        }

        this.postRender();
    }

    private renderPlanningView(isReadOnly: boolean): string {
        // ... (此方法内容保持不变，只是它现在渲染到 planningContainer) ...
        const badgeClass = this.status === 'planning' || this.status === 'validating' ? 'planning' : 'completed';
        const badgeText = this.status === 'planning' || this.status === 'validating' ? '待执行' : '规划已锁定';

        return `
            <div class="planning-view ${isReadOnly ? 'read-only' : ''}">
                <div class="agent-header">
                    <h4>${this.plan.agentName}</h4>
                    <span class="badge ${badgeClass}">${badgeText}</span>
                </div>
                <div class="agent-plan-steps">
                    <h5>执行计划</h5>
                    ${this.plan.steps.map(step => this.renderStepCard(step)).join('')}
                </div>
                ${this.plan.parameters.length > 0 ? `
                    <div class="agent-parameters">
                        <h5>参数</h5>
                        ${this.plan.parameters.map(param => this.renderParameterInput(param, isReadOnly)).join('')}
                    </div>
                ` : ''}
                <div class="agent-actions" style="display: ${isReadOnly ? 'none' : 'flex'};">
                    <button class="execute-btn">开始执行</button>
                    <button class="cancel-btn secondary">取消</button>
                </div>
            </div>
        `;
    }

    // 新方法：渲染执行视图的整体框架和内容
    private renderExecutingViewContents(container: HTMLElement) {
        const statusClassMapping: Record<AgentStatus, string> = {
            planning: 'planning',
            validating: 'planning',
            executing: 'executing',
            completed: 'completed',
            failed: 'failed',
            cancelled: 'failed'
        };
        const statusClass = statusClassMapping[this.status] || 'executing';
        const statusText = this.status.charAt(0).toUpperCase() + this.status.slice(1);

        let executionStepsOuterContainer = container.querySelector('.execution-steps-outer-container') as HTMLElement;
        if (!executionStepsOuterContainer) {
            container.innerHTML = `
            <div class="executing-view">
                <div class="agent-header">
                    <h4>执行过程</h4>
                    <span class="badge ${statusClass}">${statusText}</span>
                </div>
                <div class="execution-steps-outer-container">
                    <!-- 步骤将在这里被选择性更新或创建 -->
                </div>
                <div class="final-result-container">
                    <!-- 最终结果将在这里被选择性更新或创建 -->
                </div>
            </div>
        `;
            executionStepsOuterContainer = container.querySelector('.execution-steps-outer-container') as HTMLElement;
        } else {
            const badge = container.querySelector('.executing-view .agent-header .badge') as HTMLElement;
            if (badge) {
                badge.className = `badge ${statusClass}`;
                badge.textContent = statusText;
            }
        }

        // 渲染或更新每个步骤
        this.plan.steps.forEach((planStep, index) => {
            const executionStepState = Array.from(this.executionState.values())
                .find(s => s.stepName === planStep.name);

            console.log(`[AgentRunBlock] Rendering plan step: "${planStep.name}". Found state:`, executionStepState); // <--- ADD THIS
            if (!executionStepState && planStep.name === "分析: 并行处理模块") {
                console.warn("[AgentRunBlock] State for '分析: 并行处理模块' not found!"); // <--- ADD THIS
            }

            if (!executionStepState) { // 如果此计划步骤还没有对应的执行状态，则不渲染
                // 确保如果之前渲染过，现在被移除了
                const existingEl = this.stepElementsCache.get(planStep.name);
                if (existingEl) {
                    existingEl.remove();
                    this.stepElementsCache.delete(planStep.name);
                }
                return;
            }

            const stepMapKey = executionStepState.taskId || executionStepState.stepName;
            let stepElement = this.stepElementsCache.get(stepMapKey);

            if (!stepElement) { // 元素不存在，创建它
                let animationClass = '';
                if (!this.animatedStepIds.has(stepMapKey)) {
                    animationClass = 'needs-animation';
                    this.animatedStepIds.add(stepMapKey);
                }

                const stepHtml = planStep.name === "分析: 并行处理模块"
                    ? this.getParallelAnalysisStepHtml(planStep, index, executionStepState, animationClass)
                    : this.getExecutionStepHtml(executionStepState, planStep, index, animationClass);

                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = stepHtml.trim();
                stepElement = tempDiv.firstChild as HTMLElement;

                if (stepElement) {
                    executionStepsOuterContainer.appendChild(stepElement);
                    this.stepElementsCache.set(stepMapKey, stepElement);
                }
            } else { // 元素已存在，更新它
                this.updateStepElement(stepElement, executionStepState, planStep, planStep.name === "分析: 并行处理模块", index);
            }
        });

        // 渲染或更新最终结果
        const finalResultContainer = container.querySelector('.final-result-container') as HTMLElement;
        if (this.agentResult) {
            this.renderOrUpdateFinalResult(finalResultContainer);
        } else {
            finalResultContainer.innerHTML = ''; // 清空
        }
    }

    // 获取单个执行步骤的 HTML 字符串 (用于初次创建)
    private getExecutionStepHtml(stepState: ExecutionStepState, planStep: { name: string }, index: number, animationClass: string): string {
        const state = stepState.status;
        const isCollapsed = stepState.isCollapsed;
        const taskIdAttr = stepState.taskId ? `data-task-id="${stepState.taskId}"` : '';

        return `
            <div class="execution-step ${state} ${animationClass}" data-step-name="${planStep.name}" ${taskIdAttr}>
                <div class="step-header">
                    <span class="status-icon">${this.getIconForStatus(state)}</span>
                    <span class="step-name"><b>Step ${index + 1}:</b> ${planStep.name}</span>
                    <span class="step-status">${state}</span>
                </div>
                <div class="step-content-wrapper">
                    ${this.renderStepInternals(stepState)}
                </div>
            </div>
        `;
    }

    // 获取并行分析步骤的 HTML 字符串 (用于初次创建)
    private getParallelAnalysisStepHtml(planStep: AgentPlanStep, index: number, parentStepState: ExecutionStepState, animationClass: string): string {
        const state = parentStepState.status;
        const taskIdAttr = parentStepState.taskId ? `data-task-id="${parentStepState.taskId}"` : '';
        // 注意：子步骤的初始渲染也在这里处理，因为它们是父步骤HTML的一部分
        const subStepsHtml = this.renderSubStepsContainer(parentStepState);

        return `
            <div class="execution-step ${state} ${animationClass}" data-step-name="${planStep.name}" ${taskIdAttr}>
                <div class="step-header">
                    <span class="status-icon">${this.getIconForStatus(state)}</span>
                    <span class="step-name"><b>Step ${index + 1}:</b> ${planStep.name}</span>
                    <span class="step-status">${state}</span>
                </div>
                <div class="step-content-wrapper">
                     <div class="sub-steps-container">
                        ${subStepsHtml}
                    </div>
                </div>
            </div>
        `;
    }

    // 更新已存在的步骤元素
    private updateStepElement(element: HTMLElement, stepState: ExecutionStepState, planStep: AgentPlanStep, isParallel: boolean, index: number) {
        // 更新状态相关的类和图标
        element.className = `execution-step ${stepState.status}`; // 移除旧的 animation 类
        const statusIconEl = element.querySelector('.status-icon');
        if (statusIconEl) statusIconEl.innerHTML = this.getIconForStatus(stepState.status);
        const stepStatusEl = element.querySelector('.step-status');
        if (stepStatusEl) stepStatusEl.textContent = stepState.status;

        // 更新折叠状态
        const contentWrapper = element.querySelector('.step-content-wrapper') as HTMLElement;
        if (contentWrapper) {
            // 直接设置 max-height 可能会被 CSS transition 覆盖，
            // 最好是通过添加/移除类来控制，或者确保 style 设置在 CSS 之后。
            // 为了简单，我们暂时直接设置 style，但 CSS 中 transition 也应对应 .step-content-wrapper
            contentWrapper.style.maxHeight = stepState.isCollapsed ? '0' : (isParallel ? '5000px' : '2000px');
            contentWrapper.style.padding = stepState.isCollapsed ? '0 15px' : '10px 15px';


            if (isParallel) {
                const subStepsContainer = contentWrapper.querySelector('.sub-steps-container') as HTMLElement;
                if (subStepsContainer) {
                    subStepsContainer.innerHTML = this.renderSubStepsContainer(stepState);
                }
            } else {
                contentWrapper.innerHTML = this.renderStepInternals(stepState);
            }
        }
    }

    // 渲染子步骤容器的内容
    private renderSubStepsContainer(parentStepState: ExecutionStepState): string {
        const subSteps = Array.from(this.executionState.values()).filter(s =>
            s.stepName.startsWith("分析模块:") && s.runId === parentStepState.runId
        );
        console.log('[ARB] Filtered subSteps:', subSteps.map(s => ({ name: s.stepName, taskId: s.taskId, status: s.status })));


        if (subSteps.length > 0) {
            return subSteps.map(sub => {
                const subStepMapKey = sub.taskId || sub.stepName;
                let subAnimationClass = '';
                if (!this.animatedStepIds.has(subStepMapKey)) {
                    subAnimationClass = 'needs-animation';
                    this.animatedStepIds.add(subStepMapKey);
                }
                return this.getSubStepHtml(sub, subAnimationClass); // 获取HTML字符串
            }).join('');
        } else if (parentStepState.status === 'running') {
            return '<div class="sub-step-placeholder">等待模块分析任务启动...</div>';
        }
        return '';
    }

    // 获取单个子步骤的 HTML (用于初次创建或完整重绘子步骤列表)
    private getSubStepHtml(subStep: ExecutionStepState, animationClass: string): string {
        const isSubStepCollapsed = subStep.isCollapsed ?? true;
        return `
            <div class="sub-step ${subStep.status} ${animationClass}" data-task-id="${subStep.taskId}">
                 <div class="sub-step-header">
                    <span class="status-icon">${this.getIconForStatus(subStep.status)}</span>
                    <span class="step-name">${subStep.stepName}</span>
                </div>
                <div class="sub-step-content-wrapper">
                    ${this.renderStepInternals(subStep)}
                </div>
            </div>
        `;
    }

    // 选择性地渲染或更新最终结果
    private renderOrUpdateFinalResult(container: HTMLElement) {
        if (!this.agentResult) {
            container.innerHTML = '';
            this.stepElementsCache.delete('__agent_final_result__');
            return;
        }

        let resultElement = this.stepElementsCache.get('__agent_final_result__');
        const resultKey = '__agent_final_result__';
        let animationClass = '';

        if (!resultElement) {
            if (!this.animatedStepIds.has(resultKey)) {
                animationClass = 'needs-animation';
                this.animatedStepIds.add(resultKey);
            }
            const resultHtml = this.getFinalResultHtml(animationClass); // 方法来获取 HTML 字符串
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = resultHtml.trim();
            resultElement = tempDiv.firstChild as HTMLElement;
            if (resultElement) {
                container.innerHTML = ''; // 清空旧的（如果有）
                container.appendChild(resultElement);
                this.stepElementsCache.set(resultKey, resultElement);
            }
        } else {
            // 更新已存在的结果元素
            resultElement.className = `agent-final-result ${this.agentResult.status} ${animationClass}`; // animationClass 可能为空
            const iconEl = resultElement.querySelector('.result-header .codicon') as HTMLElement;
            const titleEl = resultElement.querySelector('.result-header span') as HTMLElement;
            const contentEl = resultElement.querySelector('.result-content') as HTMLElement;

            const isCompleted = this.agentResult.status === 'completed';
            if (iconEl) iconEl.className = `codicon ${isCompleted ? 'codicon-check-all' : 'codicon-error'}`;
            if (titleEl) titleEl.textContent = isCompleted ? 'Agent Execution Completed' : 'Agent Execution Failed';

            if (contentEl) {
                if (isCompleted) {
                    const output = this.agentResult.finalOutput;
                    if (typeof output === 'string' && (output.endsWith('.md') || output.endsWith('.txt') || output.includes('/'))) {
                        const fileName = output.includes('/') ? output.substring(output.lastIndexOf('/') + 1) : output;
                        contentEl.innerHTML = this.renderFileCard(output, fileName);
                    } else {
                        contentEl.innerHTML = `<p>${typeof output === 'string' ? output : JSON.stringify(output)}</p>`;
                    }
                } else {
                    contentEl.innerHTML = `<div class="error-text">${this.agentResult.error}</div>`;
                }
            }
        }
    }

    // 获取最终结果的 HTML (用于初次创建)
    private getFinalResultHtml(animationClass: string): string {
        if (!this.agentResult) return '';

        const resultClass = this.agentResult.status;
        const icon = resultClass === 'completed' ? '<i class="codicon codicon-check-all"></i>' : '<i class="codicon codicon-error"></i>';
        const title = resultClass === 'completed' ? 'Agent Execution Completed' : 'Agent Execution Failed';
        let contentHtml = '';

        if (resultClass === 'completed' && this.agentResult.stats) {
            // highlight-start
            // 如果执行成功并且有统计数据，则渲染统计信息
            const stats = this.agentResult.stats;
            contentHtml = `
                <div class="result-stats">
                    <div class="stat-item">
                        <i class="codicon codicon-clock"></i>
                        <span>耗时</span>
                        <strong>${stats.duration}</strong>
                    </div>
                    <div class="stat-item">
                        <i class="codicon codicon-symbol-event"></i>
                        <span>总 Tokens</span>
                        <strong>${stats.totalTokens.toLocaleString()}</strong>
                    </div>
                    <div class="stat-item">
                        <i class="codicon codicon-arrow-right"></i>
                        <span>输入 Tokens</span>
                        <strong>${stats.promptTokens.toLocaleString()}</strong>
                    </div>
                    <div class="stat-item">
                        <i class="codicon codicon-arrow-left"></i>
                        <span>输出 Tokens</span>
                        <strong>${stats.completionTokens.toLocaleString()}</strong>
                    </div>
                </div>
            `;
            // highlight-end
        } else if (resultClass !== 'completed') {
            // 对于失败状态，依然显示错误信息
            contentHtml = `<div class="error-text">${this.agentResult.error || '未知错误'}</div>`;
        }

        return `<div class="agent-final-result ${resultClass} ${animationClass}"><div class="result-header">${icon}<span>${title}</span></div><div class="result-content">${contentHtml}</div></div>`;
    }


    private renderExecutingView(): string {
        const statusClassMapping: Record<AgentStatus, string> = {
            planning: 'planning', validating: 'planning', executing: 'executing',
            completed: 'completed', failed: 'failed', cancelled: 'failed'
        };
        const statusClass = statusClassMapping[this.status] || 'executing';
        const statusText = this.status.charAt(0).toUpperCase() + this.status.slice(1);

        return `
            <div class="executing-view">
                <div class="agent-header">
                    <h4>执行过程</h4>
                    <span class="badge ${statusClass}">${statusText}</span>
                </div>
                <div class="execution-steps-container">
                    ${this.plan.steps.map((planStep, index) => {
            // Find the state for the main plan step
            const executionStepState = Array.from(this.executionState.values())
                .find(s => s.stepName === planStep.name);

            if (!executionStepState) {
                return '';
            }

            // Determine animation class for the main step
            const mainStepMapKey = executionStepState.taskId || executionStepState.stepName;
            let animationClass = '';
            if (!this.animatedStepIds.has(mainStepMapKey)) {
                animationClass = 'needs-animation';
                this.animatedStepIds.add(mainStepMapKey);
            }

            if (planStep.name === "分析: 并行处理模块") {
                return this.renderParallelAnalysisStep(planStep, index, executionStepState, animationClass);
            } else {
                return this.renderExecutionStep(executionStepState, planStep, index, animationClass);
            }
        }).join('')}
                </div>
                ${this.agentResult ? this.renderFinalResult() : ''}
            </div>
        `;
    }

    private renderStepCard(step: AgentPlanStep): string {
        return `
            <div class="step-card">
                <div class="step-card-name">${step.name}</div>
                <div class="step-card-desc">${step.description}</div>
                ${step.promptFiles && step.promptFiles.length > 0 ? `
                    <div class="prompt-files-container">
                        ${step.promptFiles.map(file => this.renderFileCard(file)).join('')}
                    </div>
                ` : ''}
            </div>
        `;
    }

    private renderParameterInput(param: { name: string, description: string, type: string, value?: any, isValid?: boolean, error?: string }, isReadOnly: boolean): string {
        const isInvalid = param.error ? 'invalid' : '';
        const value = param.value || '';
        return `
            <div class="parameter-item">
                <label for="param-${param.name}">${param.name}</label>
                <input type="text" id="param-${param.name}" name="${param.name}" placeholder="${param.description}" class="${isInvalid}" value="${value}" ${isReadOnly ? 'disabled' : ''}>
                ${param.error ? `<div class="error-text">${param.error}</div>` : ''}
            </div>
        `;
    }

    private renderStepInternals(stepState: ExecutionStepState): string {
        const logItemsHtml = stepState.logs.map(log => this.renderLogItem(log)).join('');

        let waitingPlaceholderHtml = '';
        const hasLlmRequest = stepState.logs.some(log => log.type === 'llm-request');
        const hasLlmResponse = !!stepState.streamedContent || stepState.logs.some(log => log.type === 'output');

        if (hasLlmRequest && !hasLlmResponse && stepState.status === 'running') { // Only show if running
            waitingPlaceholderHtml = `
                <div class="log-item llm-waiting-placeholder">
                    <div class="log-header">
                        <i class="codicon codicon-sync codicon-spin"></i>
                        <span>等待 LLM 响应<span class="loading-dots"></span></span>
                    </div>
                </div>
            `;
        }

        const streamHtml = stepState.streamedContent ? this.renderStreamedContent(stepState.streamedContent) : '';
        const errorHtml = stepState.error ? `<div class="step-error">${stepState.error}</div>` : '';

        return logItemsHtml + waitingPlaceholderHtml + streamHtml + errorHtml;
    }

    private renderExecutionStep(stepState: ExecutionStepState, planStep: { name: string }, index: number, animationClass: string): string {
        const state = stepState.status;
        const isCollapsed = stepState.isCollapsed;
        const taskIdAttr = stepState.taskId ? `data-task-id="${stepState.taskId}"` : '';

        return `
            <div class="execution-step ${state} ${animationClass}" data-step-name="${planStep.name}" ${taskIdAttr}>
                <div class="step-header">
                    <span class="status-icon">${this.getIconForStatus(state)}</span>
                    <span class="step-name"><b>Step ${index + 1}:</b> ${planStep.name}</span>
                    <span class="step-status">${state}</span>
                </div>
                <div class="step-content" style="max-height: ${isCollapsed ? '0' : '2000px'};">
                    ${this.renderStepInternals(stepState)}
                </div>
            </div>
        `;
    }

    private renderParallelAnalysisStep(planStep: AgentPlanStep, index: number, parentStepState: ExecutionStepState, animationClass: string): string {
        const state = parentStepState.status;
        const isCollapsed = parentStepState.isCollapsed;
        // Get sub-steps related to this parent step's runId
        const subSteps = Array.from(this.executionState.values()).filter(s =>
            s.stepName.startsWith("分析模块:") && s.runId === parentStepState.runId
        );
        const taskIdAttr = parentStepState.taskId ? `data-task-id="${parentStepState.taskId}"` : '';

        return `
            <div class="execution-step ${state} ${animationClass}" data-step-name="${planStep.name}" ${taskIdAttr}>
                <div class="step-header">
                    <span class="status-icon">${this.getIconForStatus(state)}</span>
                    <span class="step-name"><b>Step ${index + 1}:</b> ${planStep.name}</span>
                    <span class="step-status">${state}</span>
                </div>
                <div class="step-content" style="max-height: ${isCollapsed ? '0' : '5000px'};">
                    <div class="sub-steps-container">
                        ${subSteps.length > 0
                ? subSteps.map(sub => {
                    const subStepMapKey = sub.taskId || sub.stepName; // taskId should be present for sub-steps
                    let subAnimationClass = '';
                    if (!this.animatedStepIds.has(subStepMapKey)) {
                        subAnimationClass = 'needs-animation';
                        this.animatedStepIds.add(subStepMapKey);
                    }
                    return this.renderSubStep(sub, subAnimationClass);
                }).join('')
                : (parentStepState.status === 'running' ? '<div class="sub-step-placeholder">等待模块分析任务启动...</div>' : '')}
                    </div>
                </div>
            </div>
        `;
    }

    private renderSubStep(subStep: ExecutionStepState, animationClass: string): string {
        const isSubStepCollapsed = subStep.isCollapsed ?? true;
        return `
            <div class="sub-step ${subStep.status} ${animationClass}" data-task-id="${subStep.taskId}">
                 <div class="sub-step-header">
                    <span class="status-icon">${this.getIconForStatus(subStep.status)}</span>
                    <span class="step-name">${subStep.stepName}</span>
                </div>
                <div class="sub-step-content" style="max-height: ${isSubStepCollapsed ? '0' : '1000px'};">
                    ${this.renderStepInternals(subStep)}
                </div>
            </div>
        `;
    }

    private renderFileCard(filePath: string, displayName?: string): string {
        const fileName = displayName || filePath.split(/[\\/]/).pop() || 'file';
        let icon = 'codicon-file';
        if (fileName.endsWith('.md')) icon = 'codicon-markdown';
        if (fileName.endsWith('.json')) icon = 'codicon-json';
        if (fileName.endsWith('.yml') || fileName.endsWith('.yaml')) icon = 'codicon-symbol-keyword';
        if (fileName.endsWith('.txt')) icon = 'codicon-file-code';
        return `<div class="file-card" data-file-path="${filePath}" title="${filePath}"><i class="codicon ${icon}"></i><span>${fileName}</span></div>`;
    }

    private getIconForLogType(logType: string): string {
        switch (logType) {
            case 'input': return '<i class="codicon codicon-arrow-right"></i>';
            case 'output': return '<i class="codicon codicon-arrow-left"></i>';
            case 'llm-request': return '<i class="codicon codicon-comment"></i>';
            case 'llm-stream': return '<i class="codicon codicon-wand"></i>';
            default: return '';
        }
    }

    private renderLogItem(log: { type: string, data: any, metadata?: Record<string, any> }): string {
        let content = '';
        const logDataName = log.data && typeof log.data === 'object' && 'name' in log.data ? log.data.name : '';

        // 提取 log content 用于判断长度
        const logContent = log.data && typeof log.data === 'object' && 'content' in log.data
            ? (typeof log.data.content === 'string' ? log.data.content : JSON.stringify(log.data.content, null, 2))
            : (typeof log.data === 'string' ? log.data : JSON.stringify(log.data, null, 2));

        if (log.metadata?.type === 'file') {
            content = this.renderFileCard(log.metadata.path, logDataName);
        } else {
            // 使用已经提取的 logContent
            content = `<pre><code>${logContent}</code></pre>`;
        }

        const iconHtml = this.getIconForLogType(log.type);
        const titleText = `${log.type.toUpperCase()}${logDataName ? ': ' + logDataName : ''}`;

        // 启发式判断：如果是一个 input 类型的日志，并且内容很长（比如超过500字符且包含换行），
        // 就默认给它添加 'collapsed' 类。这能很好地匹配文件树的场景。
        const isLargeInput = log.type === 'input' && logContent.length > 500 && logContent.includes('\n');
        const collapsedClass = isLargeInput ? 'collapsed' : '';

        return `<div class="log-item log-${log.type} ${collapsedClass}"><div class="log-header">${iconHtml}<span>${titleText}</span></div><div class="log-content-wrapper">${content}</div></div>`;
    }

    private renderStreamedContent(content: string): string {
        const htmlContent = marked.parse(content, { gfm: true, breaks: true });
        return `<div class="log-item log-llm-stream"><div class="log-header">${this.getIconForLogType('llm-stream')}<span>LLM Response</span></div><div class="markdown-body">${htmlContent}</div></div>`;
    }

    private getIconForStatus(status: string): string {
        switch (status) {
            case 'running': return '<i class="codicon codicon-loading codicon-spin"></i>';
            case 'completed': return '<i class="codicon codicon-check"></i>';
            case 'failed': return '<i class="codicon codicon-error"></i>';
            case 'waiting': return '<i class="codicon codicon-more"></i>';
            default: return '';
        }
    }

    private renderFinalResult(): string {
        if (!this.agentResult) return '';

        let finalResultAnimationClass = '';
        if (!this.animatedStepIds.has('__agent_final_result__')) {
            finalResultAnimationClass = 'needs-animation';
            this.animatedStepIds.add('__agent_final_result__');
        }

        const resultClass = this.agentResult.status;
        const icon = resultClass === 'completed' ? '<i class="codicon codicon-check-all"></i>' : '<i class="codicon codicon-error"></i>';
        const title = resultClass === 'completed' ? 'Agent Execution Completed' : 'Agent Execution Failed';
        let contentHtml = '';

        if (resultClass === 'completed' && this.agentResult.stats) {
            const stats = this.agentResult.stats;
            contentHtml = `
                <div class="result-stats">
                    <div class="stat-item">
                        <i class="codicon codicon-clock"></i>
                        <span>耗时</span>
                        <strong>${stats.duration}</strong>
                    </div>
                    <div class="stat-item">
                        <i class="codicon codicon-symbol-event"></i>
                        <span>总 Tokens</span>
                        <strong>${stats.totalTokens.toLocaleString()}</strong>
                    </div>
                    <div class="stat-item">
                        <i class="codicon codicon-arrow-right"></i>
                        <span>输入 Tokens</span>
                        <strong>${stats.promptTokens.toLocaleString()}</strong>
                    </div>
                    <div class="stat-item">
                        <i class="codicon codicon-arrow-left"></i>
                        <span>输出 Tokens</span>
                        <strong>${stats.completionTokens.toLocaleString()}</strong>
                    </div>
                </div>
            `;
        } else if (resultClass !== 'completed') {
            contentHtml = `<div class="error-text">${this.agentResult.error || '未知错误'}</div>`;
        }
        return `<div class="agent-final-result ${resultClass} ${finalResultAnimationClass}"><div class="result-header">${icon}<span>${title}</span></div><div class="result-content">${contentHtml}</div></div>`;
    }

    private setupEventListeners() {
        this.element.addEventListener('click', (e) => { // 委托到根元素 this.element
            const target = e.target as HTMLElement;

            // 新增：处理日志卡片头部的点击事件，用于折叠/展开
            const logHeader = target.closest('.log-header');
            if (logHeader) {
                const logItem = logHeader.closest('.log-item');
                if (logItem) {
                    // 阻止事件冒泡，以防它触发了更外层（如步骤）的折叠事件
                    e.stopPropagation();
                    logItem.classList.toggle('collapsed');
                    return; // 处理完毕，提前返回
                }
            }

            // --- 规划视图的交互 ---
            const planningView = target.closest('.planning-view:not(.read-only)');
            if (planningView) {
                const executeBtn = target.closest('.execute-btn');
                if (executeBtn) {
                    // 收集参数并调用 onExecute
                    const params: Record<string, any> = {};
                    let allValid = true;

                    this.plan.parameters.forEach(p => {
                        const input = this.element.querySelector(`#param-${p.name}`) as HTMLInputElement;
                        if (input) {
                            const value = input.value.trim();
                            // 简单的非空验证
                            if (!value && p.type === 'path') { // 假设 path 类型是必需的
                                p.error = 'This field is required.';
                                allValid = false;
                            } else {
                                p.error = undefined;
                                params[p.name] = value;
                                p.value = value; // 更新内部状态
                            }
                        }
                    });

                    this.status = allValid ? 'executing' : 'validating';
                    this.render(); // 重新渲染以显示错误或进入执行状态

                    if (allValid) {
                        this.onExecute(params); // 将收集到的参数传递出去
                    }
                    return;
                }
                if (target.closest('.cancel-btn')) {
                    this.element.remove();
                    // 可能需要通知 ChatView 这个 block 被移除了
                    return;
                }
            }

            // --- 文件卡片点击 ---
            const fileCard = target.closest('.file-card');
            if (fileCard) {
                e.stopPropagation(); // Prevent other clicks if needed
                const filePath = (fileCard as HTMLElement).dataset.filePath;
                if (filePath) {
                    console.log('[AgentRunBlock] File card clicked, path:', filePath); // For debugging
                    vscode.postMessage({ command: 'viewFile', payload: { path: filePath } });
                }
                return;
            }

            // --- 步骤折叠/展开 ---
            const stepHeader = target.closest('.step-header, .sub-step-header');
            if (stepHeader) {
                e.stopPropagation();
                const stepElement = stepHeader.closest('.execution-step, .sub-step');

                if (stepElement instanceof HTMLElement) {
                    const stepName = stepElement.dataset.stepName;
                    const taskId = stepElement.dataset.taskId;
                    const key = taskId || stepName;

                    if (key) {
                        const state = this.executionState.get(key);
                        if (state) {
                            state.isCollapsed = !state.isCollapsed;
                            // 只更新这个特定元素的折叠状态，而不是完全重绘
                            const contentWrapper = stepElement.querySelector('.step-content-wrapper, .sub-step-content-wrapper') as HTMLElement;
                            if (contentWrapper) {
                                const isParallel = stepElement.classList.contains('execution-step') && !!stepElement.querySelector('.sub-steps-container');
                                contentWrapper.style.maxHeight = state.isCollapsed ? '0' : (isParallel ? '5000px' : '2000px');
                                contentWrapper.style.padding = state.isCollapsed ? '0 15px' : '10px 15px';
                            }
                        }
                    }
                }
                return;
            }
        });
    }

    private postRender() { /* For future use */ }
}

--------------------------------------------------------------------------------

--- file_path: webview/components/AtCommandMenu.ts ---
// --- file_path: webview/components/AtCommandMenu.ts ---

// 定义命令节点的接口
interface CommandNode {
    id: string;
    name: string;
    children: (CommandNode | CommandLeaf)[];
}

// 定义命令叶子节点（可执行的Agent）的接口
interface CommandLeaf {
    id: string;
    name: string;
    agentId: string; // 对应 AgentService 中的 ID
    description: string;
}

// 类型守卫，用于判断一个节点是否是叶子节点
function isLeaf(node: CommandNode | CommandLeaf): node is CommandLeaf {
    return !('children' in node);
}

// 所有可用命令的树状结构定义
const COMMAND_TREE: (CommandNode | CommandLeaf)[] = [
    {
        id: 'docgen',
        name: 'DocGen',
        children: [
            {
                id: 'docgen-project',
                name: 'DocGen-Project',
                agentId: 'docgen-project',
                description: '为整个项目生成高级设计文档'
            },
            {
                id: 'docgen-module-direct',
                name: 'DocGen-Module-Direct',
                agentId: 'docgen-module-direct',
                description: '对小模块进行直接、全面的分析'
            },
            {
                id: 'docgen-module-mapreduce',
                name: 'DocGen-Module-MapReduce',
                agentId: 'docgen-module-mapreduce',
                description: '对大模块进行分批摘要总结分析'
            }
        ]
    },
    // 未来可以添加更多一级命令, e.g., CodeRefactor, TestGen etc.
];


export class AtCommandMenu {
    private element: HTMLElement;
    private onSelect: (command: CommandLeaf) => void = () => {};
    
    // 状态管理
    private commands: (CommandNode | CommandLeaf)[] = COMMAND_TREE;
    private currentPath: CommandNode[] = []; // 导航路径
    private visibleItems: (CommandNode | CommandLeaf)[] = []; // 当前显示的列表
    private activeIndex: number = -1; // 当前高亮的索引
    private isSearchMode: boolean = false; // 是否为搜索模式
    private filterText: string = ''; // 搜索文本

    constructor(private container: HTMLElement) {
        // 直接使用传入的容器作为菜单的根元素
        this.element = container;
        this.element.className = 'at-command-menu'; // 确保 class 正确
        this.element.style.display = 'none'; // 默认隐藏

        // 事件监听器直接绑定到容器上
        this.element.addEventListener('click', (e) => {
            const li = (e.target as HTMLElement).closest('li');
            if (li) {
                const index = parseInt(li.dataset.index || '-1', 10);
                if (index !== -1) {
                    this.activeIndex = index;
                    this.handleSelection();
                }
            }
        });
    }

    /**
     * 显示并初始化菜单。
     * @param filter 用户输入的 @ 后面的文本
     * @param onSelect 选择命令后的回调
     */
    public show(filter: string, onSelect: (command: CommandLeaf) => void) {
        this.onSelect = onSelect;
        this.filterText = filter.trim().toLowerCase();
        
        // highlight-start
        // 强制禁用搜索模式，总是显示层级菜单
        this.isSearchMode = false;
        // highlight-end

        this.currentPath = [];
        this.activeIndex = 0;
        
        // 逻辑大幅简化：只需显示并渲染
        this.element.style.display = 'block';
        this.render(); 
    }



    public hide() {
        this.element.style.display = 'none';
        this.currentPath = [];
        this.activeIndex = -1;
    }

    public isVisible(): boolean {
        return this.element.style.display !== 'none';
    }

    /**
     * 处理键盘事件，由 ChatView 委托
     */
    public handleKeyDown(e: KeyboardEvent) {
        if (!this.isVisible()) return;

        e.preventDefault();
        e.stopPropagation();

        switch (e.key) {
            case 'ArrowDown':
                this.activeIndex = (this.activeIndex + 1) % this.visibleItems.length;
                this.render();
                break;
            case 'ArrowUp':
                this.activeIndex = (this.activeIndex - 1 + this.visibleItems.length) % this.visibleItems.length;
                this.render();
                break;
            case 'Tab':
            case 'Enter':
                this.handleSelection();
                break;
            case 'Escape':
                if (this.currentPath.length > 0) {
                    this.currentPath.pop();
                    this.activeIndex = 0;
                    this.render();
                } else {
                    this.hide();
                }
                break;
        }
    }

    /**
     * 处理用户通过 Enter/Tab/Click 进行的选择
     */
    private handleSelection() {
        if (this.activeIndex < 0 || this.activeIndex >= this.visibleItems.length) return;

        const selectedItem = this.visibleItems[this.activeIndex];
        if (isLeaf(selectedItem)) {
            this.onSelect(selectedItem);
            this.hide();
        } else {
            // 进入下一级
            this.currentPath.push(selectedItem);
            this.activeIndex = 0;
            this.render();
        }
    }

    /**
     * 渲染菜单的当前视图
     */
    private render() {
        if (this.isSearchMode) {
            this.renderSearchResults();
        } else {
            this.renderHierarchicalView();
        }
    }

    private renderHierarchicalView() {
        let itemsToShow: (CommandNode | CommandLeaf)[];
        let parent: CommandNode | undefined = this.currentPath[this.currentPath.length - 1];
        
        if (parent) {
            itemsToShow = parent.children;
        } else {
            itemsToShow = this.commands;
        }

        this.visibleItems = itemsToShow;
        if (this.activeIndex >= this.visibleItems.length) {
            this.activeIndex = 0;
        }

        const breadcrumbs = ['@', ...this.currentPath.map(p => p.name)].join(' > ');
        
        this.element.innerHTML = `
            <div class="menu-header">${breadcrumbs}</div>
            <ul>
                ${this.visibleItems.map((item, index) => this.renderItem(item, index)).join('')}
            </ul>
        `;
        this.scrollIntoView();
    }

    private renderSearchResults() {
        const allLeaves = this.flattenCommands(this.commands);
        const searchTerms = this.filterText.split(' ').filter(Boolean);

        this.visibleItems = allLeaves.filter(leaf => 
            searchTerms.every(term => 
                leaf.name.toLowerCase().includes(term) ||
                leaf.agentId.toLowerCase().includes(term) ||
                (this.findPath(leaf.id)?.map(p => p.name.toLowerCase()).join(' ') || '').includes(term)
            )
        );

        if (this.activeIndex >= this.visibleItems.length) {
            this.activeIndex = 0;
        }
        
        if (this.visibleItems.length === 0) {
            this.element.innerHTML = `<div class="menu-header">No results for "${this.filterText}"</div>`;
            return;
        }

        this.element.innerHTML = `
            <div class="menu-header">Search results for "${this.filterText}"</div>
            <ul>
                ${this.visibleItems.map((item, index) => this.renderItem(item, index)).join('')}
            </ul>
        `;
        this.scrollIntoView();
    }

    private renderItem(item: CommandNode | CommandLeaf, index: number): string {
        const isActive = index === this.activeIndex ? 'active' : '';
        const hasChildren = !isLeaf(item);

        return `
            <li class="${isActive}" data-index="${index}">
                <div class="menu-item-name" style="display: flex; align-items: center;">
                    <span>${item.name}</span>
                    ${hasChildren ? '<i class="codicon codicon-chevron-right"></i>' : ''}
                </div>
                ${isLeaf(item) ? `<div class="menu-item-description">${item.description}</div>` : ''}
            </li>
        `;
    }

    private scrollIntoView() {
        const activeItem = this.element.querySelector('li.active');
        if (activeItem) {
            activeItem.scrollIntoView({ block: 'nearest' });
        }
    }

    // --- 辅助函数 ---
    private flattenCommands(nodes: (CommandNode | CommandLeaf)[]): CommandLeaf[] {
        let leaves: CommandLeaf[] = [];
        for (const node of nodes) {
            if (isLeaf(node)) {
                leaves.push(node);
            } else {
                leaves = leaves.concat(this.flattenCommands(node.children));
            }
        }
        return leaves;
    }
    
    private findPath(id: string, nodes: (CommandNode | CommandLeaf)[] = this.commands, path: CommandNode[] = []): CommandNode[] | null {
        for (const node of nodes) {
            if (node.id === id) {
                return path;
            }
            if (!isLeaf(node)) {
                const newPath = [...path, node];
                const found = this.findPath(id, node.children, newPath);
                if (found) {
                    return found;
                }
            }
        }
        return null;
    }
}

--------------------------------------------------------------------------------

--- file_path: webview/components/MessageBlock.ts ---
import { ChatMessage } from "../../common/types";

export class MessageBlock {
    constructor(private readonly message: ChatMessage, private readonly messageIndex: number) {}

    public render(): HTMLElement {
        const element = document.createElement('div');
        element.className = `message-block ${this.message.role}`;
        element.dataset.index = this.messageIndex.toString();

        const content = document.createElement('div');
        content.className = 'message-content';
        content.textContent = this.message.content;
        
        element.appendChild(content);
        element.appendChild(this.createToolbar());

        return element;
    }

    private createToolbar(): HTMLElement {
        const toolbar = document.createElement('div');
        toolbar.className = 'message-toolbar';

        toolbar.appendChild(this.createButton('toggle-fold', 'Fold', 'codicon-chevron-up'));

        if (this.message.role === 'assistant') {
            toolbar.appendChild(this.createButton('copy-content', 'Copy', 'codicon-copy'));
            toolbar.appendChild(this.createButton('regenerate-response', 'Regenerate', 'codicon-sync'));
        } else {
            toolbar.appendChild(this.createButton('copy-content', 'Copy', 'codicon-copy'));
            toolbar.appendChild(this.createButton('edit-message', 'Edit', 'codicon-pencil'));
        }

        return toolbar;
    }

    private createButton(action: string, title: string, icon: string): HTMLButtonElement {
        const button = document.createElement('button');
        button.className = `icon-button`;
        button.title = title;
        button.dataset.action = action;
        button.innerHTML = `<i class="codicon ${icon}"></i>`;
        return button;
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/css/main.css ---
/* --- file_path: webview/css/main.css --- */
body,
html {
    height: 100%;
    margin: 0;
    padding: 0;
    background-color: var(--vscode-sideBar-background);
    color: var(--vscode-editor-foreground);
    font-family: var(--vscode-font-family);
    display: flex;
    flex-direction: column;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
}

#root {
    display: flex;
    flex-direction: column;
    height: 100%;
    flex: 1;
}

.top-toolbar {
    display: flex;
    justify-content: flex-start;
    padding: 5px;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    flex-shrink: 0;
}

.nav-icon {
    cursor: pointer;
    padding: 5px;
    margin: 0 5px;
    border-radius: 5px;
}

.nav-icon:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.nav-icon.active {
    background-color: var(--vscode-list-activeSelectionBackground);
}

.main-content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    padding: 0;
}

.view {
    display: none;
    height: 100%;
    width: 100%;
    flex-direction: column;
}

.view.active {
    display: flex;
}


/* Chat View & Focus Editor Common Styles */
.chat-container,
.focus-editor-container {
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    flex: 1;
    position: relative;
}

.messages-list {
    flex-grow: 1;
    overflow-y: auto;
    min-height: 0;
    width: 100%;
    box-sizing: border-box;
}

.chat-sticky-bottom {
    flex-shrink: 0;
    width: 100%;
    box-sizing: border-box;
    padding: 10px;
    border-top: 1px solid var(--vscode-editorGroup-border);
    background-color: var(--vscode-sideBar-background);
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.chat-quick-actions {
    display: flex;
    gap: 10px;
    align-items: center;
}

.chat-quick-actions label {
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
}

#model-selector,
#prompt-selector {
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 5px;
    border-radius: 5px;
    flex-grow: 1;
}

.chat-quick-actions button {
    margin-left: auto;
    margin-top: 0;
}

.chat-input-box-container {
    display: flex;
}

.chat-input-box-container textarea {
    flex-grow: 1;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 8px;
    resize: none;
    border-radius: 5px;
}

.chat-container .chat-input-box-container textarea {
    max-height: 250px;
}

.focus-editor-container {
    padding: 10px;
}

.focus-editor-container .chat-input-box-container {
    flex-grow: 1;
}

.focus-editor-container .chat-input-box-container textarea {
    height: 100%;
    width: 100%;
    max-height: none;
    box-sizing: border-box;
}


/* Message Block Styles */
.message-block {
    padding: 15px;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    word-wrap: break-word;
    white-space: pre-wrap;
    position: relative;
}

.message-content {
    transition: max-height 0.3s ease-in-out;
    overflow: hidden;
    position: relative;
}

.message-block.folded .message-content {
    max-height: 70px;
}

.message-block.folded .message-content::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 30px;
    background: linear-gradient(to bottom, transparent, var(--vscode-editor-background));
    pointer-events: none;
}

.message-block:last-child {
    border-bottom: none;
}

.message-toolbar {
    position: absolute;
    top: 5px;
    right: 5px;
    background-color: var(--vscode-editorWidget-background);
    border-radius: 5px;
    padding: 2px;
    display: flex;
    gap: 2px;
    opacity: 0;
    transition: opacity 0.1s ease-in-out;
    pointer-events: none;
}

.message-block:hover .message-toolbar {
    opacity: 1;
    pointer-events: all;
}

.message-block.user {
    background-color: var(--vscode-list-hoverBackground);
    border-left: 3px solid var(--vscode-focusBorder);
    padding-left: 12px;
}

.message-block.folded.user .message-content::after {
    background: linear-gradient(to bottom, transparent, var(--vscode-list-hoverBackground));
}

.message-block.assistant {
    background-color: var(--vscode-editor-background);
}

.message-block.editing {
    border: 1px solid var(--vscode-focusBorder);
    box-shadow: 0 0 3px var(--vscode-focusBorder);
    border-radius: 5px;
}

.message-block.error {
    color: var(--vscode-errorForeground);
}

button.streaming {
    background-color: var(--vscode-button-secondaryBackground);
}

button.streaming:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

/* Settings View */
.config-form {
    border: 1px solid var(--vscode-editorGroup-border);
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 5px;
    background-color: var(--vscode-sideBar-sectionHeader-background);
}

.form-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.form-title {
    font-size: 1.1em;
}

.default-badge {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 0.8em;
}

.form-group {
    margin-bottom: 10px;
}

.form-group label {
    display: block;
    margin-bottom: 5px;
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
}

.config-form input {
    width: calc(100% - 20px);
    margin-bottom: 5px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 5px;
}

.form-actions {
    margin-top: 15px;
    display: flex;
    gap: 10px;
}

.form-actions button {
    margin-top: 0;
}

button {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: none;
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 5px;
}

button:hover {
    background-color: var(--vscode-button-hoverBackground);
}

/* Generic View Header */
.view-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.view-header h2 {
    margin: 0;
}

.add-btn {
    font-size: 20px;
    font-weight: bold;
    padding: 0px 8px;
}

/* Chat History View */
.history-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.history-item {
    display: flex;
    align-items: center;
    padding: 15px;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    cursor: pointer;
    position: relative;
}

.history-item:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.history-item-content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}

.history-item-timestamp {
    font-size: 0.8em;
    color: var(--vscode-descriptionForeground);
    margin-bottom: 5px;
}

.history-item-title {
    font-size: 1em;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.history-item-actions {
    display: flex;
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    background-color: var(--vscode-list-hoverBackground);
    opacity: 0;
    transition: opacity 0.1s ease-in-out;
    pointer-events: none;
}

.history-item:hover .history-item-actions {
    opacity: 1;
    pointer-events: all;
}

.icon-button {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--vscode-foreground);
    padding: 5px;
    border-radius: 5px;
}

.icon-button:hover {
    background-color: var(--vscode-toolbar-hoverBackground);
}

.history-empty {
    text-align: center;
    padding: 20px;
    color: var(--vscode-descriptionForeground);
}

/*=================================*/
/*========= Prompt Manager ========*/
/*=================================*/

.prompt-manager-view,
.prompt-editor-view {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.prompt-editor-view {
    display: none;
}

.search-bar {
    display: flex;
    align-items: center;
    flex-grow: 1;
    margin-right: 15px;
    background-color: var(--vscode-input-background);
    border: 1px solid var(--vscode-input-border);
    border-radius: 5px;
    padding: 0 8px;
}

.search-bar i {
    margin-right: 8px;
    color: var(--vscode-descriptionForeground);
}

.search-bar input {
    width: 100%;
    border: none;
    background: transparent;
    color: var(--vscode-input-foreground);
    padding: 6px 0;
    outline: none;
}

.codicon-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: none;
    padding: 6px 12px;
    cursor: pointer;
    border-radius: 5px;
}

.codicon-btn:hover {
    background-color: var(--vscode-button-hoverBackground);
}

.codicon-btn.secondary {
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
}

.codicon-btn.secondary:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.icon-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--vscode-foreground);
    padding: 5px;
    border-radius: 5px;
}

.icon-btn:hover {
    background-color: var(--vscode-toolbar-hoverBackground);
}


.prompt-list-container {
    flex-grow: 1;
    overflow-y: auto;
}

.prompt-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.prompt-list-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    cursor: pointer;
    transition: background-color 0.1s ease-in-out;
}

.prompt-list-item:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.prompt-item-main {
    flex-grow: 1;
    margin-right: 15px;
    overflow: hidden;
}

.prompt-item-title {
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: 4px;
}

.prompt-item-summary {
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.prompt-item-meta {
    flex-shrink: 0;
    text-align: right;
}

.prompt-item-time {
    font-size: 0.8em;
    color: var(--vscode-descriptionForeground);
    margin-bottom: 8px;
}

.prompt-item-actions {
    display: flex;
    gap: 5px;
    opacity: 0;
    transition: opacity 0.1s ease-in-out;
}

.prompt-list-item:hover .prompt-item-actions {
    opacity: 1;
}

.empty-state {
    text-align: center;
    padding: 40px 20px;
    color: var(--vscode-descriptionForeground);
}

.empty-state p {
    margin-bottom: 15px;
}

.highlighted-btn {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: 1px solid var(--vscode-button-border, transparent);
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
}

.highlighted-btn:hover {
    background-color: var(--vscode-button-hoverBackground);
}

/*=================================*/
/*========= Prompt Editor =========*/
/*=================================*/

.prompt-editor-form {
    flex-grow: 1;
    overflow-y: auto;
    padding: 10px;
    display: flex;
    flex-direction: column;
}

.prompt-editor-form .form-group {
    display: flex;
    flex-direction: column;
}

.prompt-editor-form .form-group:last-child {
    flex-grow: 1;
}

.prompt-editor-form input,
.prompt-editor-form textarea {
    width: calc(100% - 22px);
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 10px;
    border-radius: 5px;
}

.prompt-editor-form textarea {
    flex-grow: 1;
    resize: none;
    font-family: var(--vscode-editor-font-family);
}

.prompt-editor-form textarea:focus {
    outline: none;
}

/*=================================*/
/*====== Rich Input & Pills =======*/
/*=================================*/

.chat-input-box {
    flex-grow: 1;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 8px;
    border-radius: 5px;
    min-height: 22px;
    max-height: 250px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
    line-height: 1.5;
}

.chat-input-box:focus {
    outline: 1px solid var(--vscode-focusBorder);
}

.content-pill {
    display: inline-block;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border-radius: 12px;
    padding: 2px 10px;
    margin: 0 2px;
    font-size: 0.9em;
    font-weight: 500;
    cursor: default;
}

.chat-input-box p, .chat-input-box div {
    margin: 0;
}

/*=================================*/
/*====== @ Command Menu ===========*/
/*=================================*/
.at-command-menu {
    width: 100%;
    box-sizing: border-box;
    background-color: var(--vscode-editorWidget-background);
    border: 1px solid var(--vscode-editorWidget-border);
    border-radius: 5px;
    z-index: 100;
    max-height: 220px;
    overflow-y: auto;
    margin-bottom: 8px;
    display: none;
}

.at-command-menu ul {
    list-style: none;
    padding: 5px;
    margin: 0;
}

.at-command-menu li {
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 3px;
}

.at-command-menu li:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.at-command-menu li.active {
    background-color: var(--vscode-list-hoverBackground);
    color: var(--vscode-list-activeSelectionForeground);
}

.at-command-menu .menu-header {
    padding: 8px 12px;
    border-bottom: 1px solid var(--vscode-editorWidget-border);
    color: var(--vscode-descriptionForeground);
    font-size: 0.9em;
}

.at-command-menu .menu-item-name {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
}

.at-command-menu .menu-item-name .codicon {
    color: var(--vscode-descriptionForeground);
}

.at-command-menu .menu-item-description {
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
    margin-top: 4px;
}

/*=================================*/
/*====== Agent Run Block (Final & Cleaned) =======*/
/*=================================*/

.agent-run-block {
    background-color: var(--vscode-sideBar-sectionHeader-background);
    border: 1px solid var(--vscode-editorGroup-border);
    border-radius: 8px;
    margin: 10px 0;
    padding: 15px;
    font-size: 0.9em;
}

.agent-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    padding-bottom: 10px;
    margin-bottom: 15px;
}

.agent-header h4 {
    margin: 0;
    font-size: 1.2em;
}

.badge {
    padding: 3px 8px;
    border-radius: 12px;
    font-weight: 500;
}
.badge.planning { background-color: var(--vscode-testing-iconQueued-foreground); color: var(--vscode-button-foreground); }
.badge.executing { background-color: var(--vscode-testing-iconRunning-foreground); color: var(--vscode-button-foreground); }
.badge.completed { background-color: var(--vscode-testing-iconPassed-foreground); color: var(--vscode-button-foreground); }
.badge.failed { background-color: var(--vscode-testing-iconFailed-foreground); color: var(--vscode-button-foreground); }
.badge.cancelled { background-color: var(--vscode-testing-iconSkipped-foreground); color: var(--vscode-button-foreground); }

.agent-plan-steps, .agent-parameters {
    margin-bottom: 20px;
}

.agent-plan-steps h5, .agent-parameters h5 {
    margin: 0 0 10px 0;
    color: var(--vscode-descriptionForeground);
}

.step-card {
    background-color: var(--vscode-input-background);
    border: 1px solid var(--vscode-input-border);
    border-radius: 5px;
    padding: 10px;
    margin-bottom: 8px;
}

.step-card-name {
    font-weight: bold;
    margin-bottom: 4px;
}

.step-card-desc {
    font-size: 0.95em;
    color: var(--vscode-descriptionForeground);
}

.parameter-item {
    margin-bottom: 10px;
}

.parameter-item label {
    display: block;
    margin-bottom: 5px;
}

.parameter-item input {
    width: calc(100% - 16px);
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 8px;
    border-radius: 5px;
}

.parameter-item .error-text {
    color: var(--vscode-errorForeground);
    font-size: 0.9em;
    margin-top: 5px;
}

.parameter-item input.invalid {
    border-color: var(--vscode-errorForeground);
}

.agent-actions {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 15px;
}

.agent-actions button {
    flex: 1;
    padding: 10px;
    font-size: 1.1em;
    font-weight: 500;
}
.agent-actions button.secondary {
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
}
.agent-actions button.secondary:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.execute-btn {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: none;
    padding: 8px 15px;
    cursor: pointer;
    border-radius: 5px;
}
.execute-btn:hover {
    background-color: var(--vscode-button-hoverBackground);
}


/* -- Executing View -- */
.execution-step {
    border-left: 3px solid;
    margin-bottom: 10px;
    transition: all 0.2s ease-in-out;
    border-radius: 0 5px 5px 0;
    overflow: hidden;
}
.execution-step.waiting { border-color: var(--vscode-editorHint-foreground); }
.execution-step.completed { border-color: var(--vscode-testing-iconPassed-foreground); }
.execution-step.failed { border-color: var(--vscode-testing-iconFailed-foreground); }

@keyframes pulse-border {
    0% { border-color: var(--vscode-testing-iconRunning-foreground); }
    50% { border-color: var(--vscode-focusBorder); }
    100% { border-color: var(--vscode-testing-iconRunning-foreground); }
}

.execution-step.running {
    animation: pulse-border 2s infinite;
}

.execution-step .step-header {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    cursor: pointer;
    background-color: var(--vscode-sideBar-sectionHeader-background);
    transition: background-color 0.2s ease;
}
.execution-step .step-header:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.execution-step .status-icon {
    font-size: 1.1em;
}

.execution-step .step-name {
    flex-grow: 1;
}

.execution-step .step-status {
    font-family: monospace;
    font-size: 0.9em;
    padding: 2px 6px;
    border-radius: 3px;
    background-color: var(--vscode-badge-background);
    color: var(--vscode-badge-foreground);
}

.execution-step .step-content {
    overflow: hidden;
    transition: max-height 0.4s ease-in-out, padding 0.4s ease-in-out;
    padding: 0 15px;
    background-color: var(--vscode-input-background);
}
.execution-step .step-content[style*="max-height: 2000px"],
.execution-step .step-content[style*="max-height: 5000px"] {
    padding: 10px 15px;
}


.log-item {
    border: 1px solid var(--vscode-input-border);
    border-left-width: 4px;
    border-radius: 5px;
    margin: 10px 0;
    background: var(--vscode-editor-background);
}
.log-item.log-input { border-left-color: var(--vscode-terminal-ansiBlue); }
.log-item.log-output { border-left-color: var(--vscode-terminal-ansiGreen); }
.log-item.log-llm-request { border-left-color: var(--vscode-terminal-ansiYellow); }
.log-item.log-llm-stream { border-left-color: var(--vscode-terminal-ansiCyan); }

.log-item .log-header {
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(128, 128, 128, 0.1);
    padding: 5px 10px;
    font-weight: bold;
    color: var(--vscode-descriptionForeground);
    border-bottom: 1px solid var(--vscode-input-border);
    cursor: pointer; /* 添加手型光标，提示用户这里可以点击 */
}
.log-item .log-header .codicon {
    font-size: 1.1em;
}

.log-content-wrapper {
    padding: 5px 10px;
    max-height: 400px; /* 设置一个合理的默认最大高度 */
    overflow-y: auto;  /* 当内容超出时，显示内部滚动条 */
    transition: max-height 0.3s ease-out, padding 0.3s ease-out; /* 添加平滑过渡动画 */
    background-color: var(--vscode-editor-background); /* 确保滚动条背景色正确 */
}

.log-item.collapsed .log-content-wrapper {
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
    overflow: hidden; /* 在折叠时隐藏内容，防止文字溢出 */
    border-bottom: none; /* 折叠时不需要底边框 */
}

.log-content-wrapper pre {
    margin: 0;
    padding: 5px;
    white-space: pre-wrap;
    word-break: break-all;
}
.log-content-wrapper code {
    font-family: var(--vscode-editor-font-family);
}

.log-llm-stream .markdown-body {
    padding: 0 10px 10px 10px;
}
.log-llm-stream .markdown-body p:first-child,
.log-llm-stream .markdown-body ul:first-child,
.log-llm-stream .markdown-body ol:first-child {
    margin-top: 10px;
}
.log-llm-stream .markdown-body p,
.log-llm-stream .markdown-body ul,
.log-llm-stream .markdown-body ol {
    margin-top: 0;
    margin-bottom: 0.5em;
}

.step-error {
    background-color: rgba(255, 0, 0, 0.1);
    border: 1px solid var(--vscode-errorForeground);
    color: var(--vscode-errorForeground);
    padding: 10px;
    border-radius: 5px;
    margin: 10px 0;
    white-space: pre-wrap;
}

.agent-final-result {
    margin-top: 20px;
    border: 1px solid var(--vscode-editorGroup-border);
    border-left-width: 4px;
    border-radius: 5px;
    overflow: hidden;
}
.agent-final-result.completed {
    border-left-color: var(--vscode-testing-iconPassed-foreground);
    background-color: rgba(45, 212, 129, 0.1);
}
.agent-final-result.failed,
.agent-final-result.cancelled {
    border-left-color: var(--vscode-testing-iconFailed-foreground);
    background-color: rgba(255, 0, 0, 0.1);
}

.result-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    font-weight: bold;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
}

.result-header .codicon {
    font-size: 1.2em;
}

.result-content {
    padding: 12px;
}
.result-content .error-text {
    color: var(--vscode-errorForeground);
    white-space: pre-wrap;
}

/* --- File & Prompt Card Styles --- */
.prompt-files-container {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
}

.file-card {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background-color: var(--vscode-input-background);
    border: 1px solid var(--vscode-input-border);
    padding: 6px 12px;
    border-radius: 5px;
    font-size: 0.9em;
    cursor: pointer;
    transition: background-color 0.2s ease, border-color 0.2s ease;
    flex-grow: 0;
}
.file-card:hover {
    background-color: var(--vscode-list-hoverBackground);
    border-color: var(--vscode-focusBorder);
}
.file-card .codicon {
    font-size: 1.2em;
    color: var(--vscode-descriptionForeground);
}
.result-content .file-card {
    background: none;
    border: none;
    padding: 0;
    font-size: 1em;
}
.result-content .file-card:hover {
    background: var(--vscode-list-hoverBackground);
}


/* --- Sub-step Styles --- */
.sub-steps-container {
    padding: 10px 5px;
    margin: 10px 0;
    border-radius: 5px;
    background-color: var(--vscode-sideBar-background);
}

.sub-step-placeholder {
    color: var(--vscode-descriptionForeground);
    font-style: italic;
    text-align: center;
    padding: 15px;
}

.sub-step {
    padding: 0;
    border-left: 3px solid;
    margin-bottom: 8px;
    background-color: var(--vscode-editor-background);
    border-radius: 0 3px 3px 0;
    overflow: hidden;
}
.sub-step:last-child {
    margin-bottom: 0;
}

.sub-step.waiting { border-color: var(--vscode-editorHint-foreground); }
.sub-step.running { border-color: var(--vscode-testing-iconRunning-foreground); }
.sub-step.completed { border-color: var(--vscode-testing-iconPassed-foreground); }
.sub-step.failed { border-color: var(--vscode-testing-iconFailed-foreground); }

.sub-step-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 10px;
    cursor: pointer;
    transition: background-color 0.2s ease;
}
.sub-step-header:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.sub-step-content {
    padding: 0 10px 10px 10px;
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}
.sub-step-content .log-item {
    margin: 0;
}

.planning-view.read-only .parameter-item input {
    background-color: var(--vscode-input-background);
    opacity: 0.7;
    cursor: not-allowed;
    border-style: dashed;
}

.planning-view.read-only .prompt-file-card {
    cursor: default;
}
.planning-view.read-only .prompt-file-card:hover {
    background-color: var(--vscode-button-secondaryBackground);
}

@keyframes pulse-waiting {
  0% { opacity: 1; }
  50% { opacity: 0.4; }
  100% { opacity: 1; }
}
.execution-step.waiting .status-icon .codicon-more,
.sub-step.waiting .status-icon .codicon-more {
  animation: pulse-waiting 2s infinite ease-in-out;
}

.llm-waiting-placeholder {
    border-style: dashed !important; /* 覆盖默认边框样式 */
}
.llm-waiting-placeholder .log-header {
    background: transparent !important;
    border-bottom: none !important;
    color: var(--vscode-descriptionForeground) !important;
    font-style: italic;
}
.llm-waiting-placeholder .log-header .codicon-loading {
    color: var(--vscode-testing-iconRunning-foreground);
}

/* Loading dots animation */
@keyframes-loading-dots {
  0%   { content: '.'; }
  33%  { content: '..'; }
  66%  { content: '...'; }
  100% { content: '.'; }
}

.loading-dots::after {
  content: '.';
  animation: keyframes-loading-dots 1.5s infinite;
  display: inline-block;
  width: 20px; /* Give it some space */
  text-align: left;
}

/* 新增淡入动画 */
@keyframes-fade-in {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.fade-in {
  animation: keyframes-fade-in 0.4s ease-out;
}

/* 为步骤状态变化添加平滑过渡 */
.execution-step, .sub-step {
    transition: border-color 0.4s ease-in-out, background-color 0.4s ease-in-out;
}

.executing-view-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 0;
    margin-top: 15px;
    border-top: 1px solid var(--vscode-editorGroup-border);
}
.executing-view-header h4 {
    margin: 0;
}

@keyframes card-fade-in {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* 将动画应用到主步骤卡片上 */
.execution-step {
    border-left: 3px solid;
    margin-bottom: 10px;
    transition: all 0.2s ease-in-out;
    border-radius: 0 5px 5px 0;
    animation: card-fade-in 0.4s ease-out forwards;
}

/* 将动画也应用到最终结果卡片上 */
.agent-final-result {
    margin-top: 20px;
    border: 1px solid var(--vscode-editorGroup-border);
    border-left-width: 4px;
    border-radius: 5px;
    animation: card-fade-in 0.4s ease-out forwards;
}

.execution-step.needs-animation,
.sub-step.needs-animation, /* Added for sub-steps */
.agent-final-result.needs-animation {
    animation: card-fade-in 0.4s ease-out forwards;
}

@keyframes codicon-spin-animation { /* 使用一个不冲突的动画名 */
    100% {
        transform: rotate(360deg);
    }
}

.codicon-spin:before { /* 直接针对 :before 伪元素应用动画 */
    animation: codicon-spin-animation 0.6s linear infinite; /* 时长可以调整 */
    display: inline-block; /* 有时需要确保伪元素是块级或行内块级才能应用 transform */
}

.result-content {
    padding: 12px;
    background-color: var(--vscode-editor-background);
}
.result-content .error-text {
    color: var(--vscode-errorForeground);
    white-space: pre-wrap;
}

/* highlight-start */
.result-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 10px;
    padding: 5px;
}

.stat-item {
    display: flex;
    align-items: center;
    gap: 8px;
    background-color: var(--vscode-sideBar-sectionHeader-background);
    padding: 8px 12px;
    border-radius: 5px;
    border-left: 2px solid var(--vscode-focusBorder);
}

.stat-item .codicon {
    font-size: 1.2em;
    color: var(--vscode-descriptionForeground);
}

.stat-item span {
    flex-grow: 1;
    color: var(--vscode-descriptionForeground);
    font-size: 0.9em;
}

.stat-item strong {
    font-size: 1em;
    font-weight: 600;
    color: var(--vscode-editor-foreground);
}

--------------------------------------------------------------------------------

--- file_path: webview/main.ts ---
import { App } from './views/App';

// Wait for the DOM to be fully loaded before initializing the app
window.addEventListener('load', () => {
    const app = new App(document.body);
    app.initialize();
});


--------------------------------------------------------------------------------

--- file_path: webview/views/App.ts ---
import { vscode } from '../vscode';
import { ChatView } from './ChatView';
import { SettingsView } from './SettingsView';
import { WelcomeView } from './WelcomeView';
import { ChatHistoryView } from './ChatHistoryView';
import { PromptManagerView } from './PromptManagerView';
import { PromptEditorView } from './PromptEditorView';
import { FocusEditorView } from './FocusEditorView';

export class App {
    private chatView: ChatView;
    private focusEditorView?: FocusEditorView;
    private settingsView: SettingsView;
    private welcomeView: WelcomeView;
    private chatHistoryView: ChatHistoryView;
    private promptManagerView: PromptManagerView;
    private promptEditorView: PromptEditorView;

    constructor(private readonly parent: HTMLElement) {
        this.parent.innerHTML = this.render();

        this.welcomeView = new WelcomeView(this.parent.querySelector('#view-welcome') as HTMLElement);
        this.chatView = new ChatView(this.parent.querySelector('#view-chat') as HTMLElement);
        this.chatHistoryView = new ChatHistoryView(
            this.parent.querySelector('#view-history') as HTMLElement,
            this.navigateTo.bind(this)
        );
        this.promptManagerView = new PromptManagerView(this.parent.querySelector('#view-prompts') as HTMLElement);
        this.promptEditorView = new PromptEditorView(this.parent.querySelector('#view-prompt-editor') as HTMLElement);
        this.settingsView = new SettingsView(this.parent.querySelector('#view-settings') as HTMLElement);
    }

    public initialize() {
        this.setupEventListeners();
        // On initial load, determine if this is a focus editor or main view
        if (document.body.classList.contains('focus-editor-body')) {
            vscode.postMessage({ command: 'ready' });
        } else {
            this.navigateTo('chat');
            vscode.postMessage({ command: 'ready' });
        }
    }

    private setupEventListeners() {
        // Top toolbar navigation
        this.parent.querySelector('#nav-new-chat')?.addEventListener('click', () => this.chatView.clearChat());
        this.parent.querySelector('#nav-chat')?.addEventListener('click', () => this.navigateTo('chat'));
        this.parent.querySelector('#nav-history')?.addEventListener('click', () => this.navigateTo('history'));
        this.parent.querySelector('#nav-prompts')?.addEventListener('click', () => this.navigateTo('prompts'));
        this.parent.querySelector('#nav-settings')?.addEventListener('click', () => this.navigateTo('settings'));

        // Listen for messages from the extension host
        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.command) {
                case 'initialize':
                    this.chatView.setConversations(message.payload.conversations);
                    this.chatHistoryView.setConversations(message.payload.conversations);
                    this.promptManagerView.update(message.payload.prompts);
                    this.chatView.setPrompts(message.payload.prompts);
                    this.chatView.setModelConfigs(message.payload.modelConfigs);
                    this.settingsView.setModelConfigs(message.payload.modelConfigs);
                    break;
                case 'showPromptEditor':
                    this.navigateTo('prompt-editor', message.payload);
                    break;
                case 'showPromptManager':
                    this.navigateTo('prompts');
                    break;
                case 'updatePrompts':
                    this.promptManagerView.update(message.payload);
                    this.chatView.setPrompts(message.payload);
                    if (this.focusEditorView) {
                        this.focusEditorView.setPrompts(message.payload);
                    }
                    break;
                case 'setActiveConversation':
                    this.chatView.loadConversation(message.payload);
                    break;
                case 'updateModelConfigs':
                    this.chatView.setModelConfigs(message.payload);
                    this.settingsView.setModelConfigs(message.payload);
                    if (this.focusEditorView) {
                        this.focusEditorView.setModelConfigs(message.payload);
                    }
                    break;
                case 'updateHistory':
                    this.chatHistoryView.setConversations(message.payload);
                    break;
                case 'showFocusEditor':
                    this.navigateTo('focus-editor', message.payload);
                    break;
                case 'updateContent':
                    if (this.focusEditorView) {
                        this.focusEditorView.updateContent(message.payload.content);
                    }
                    const mainTextarea = this.chatView['bottomPanel'].querySelector('textarea');
                    if (mainTextarea && mainTextarea.value !== message.payload.content) {
                        mainTextarea.value = message.payload.content;
                        this.chatView['autoResizeInput'](mainTextarea);
                    }
                    break;
                case 'updateState':
                    if (this.focusEditorView) {
                        this.focusEditorView.updateState(message.payload);
                    }
                    if (message.payload.modelId) {
                        this.chatView['modelSelector'].value = message.payload.modelId;
                    }
                    if (message.payload.promptId) {
                        this.chatView['promptSelector'].value = message.payload.promptId;
                    }
                    break;
                case 'clearInput':
                    const textarea = this.chatView['bottomPanel'].querySelector('textarea');
                    if (textarea) {
                        textarea.value = '';
                        this.chatView['autoResizeInput'](textarea);
                    }
                    if (this.focusEditorView) {
                        this.focusEditorView.clearInput();
                    }
                    break;
                case 'focusEditorClosed':
                    this.navigateTo('chat');
                    const topToolbar = this.parent.querySelector('.top-toolbar') as HTMLElement;
                    if (topToolbar) topToolbar.style.display = 'flex';
                    this.chatView['toggleMaximizeButton'](false);
                    break;
            }
        });
    }

    public navigateTo(view: string, data?: any) {
        this.parent.querySelectorAll('.view').forEach(v => {
            (v as HTMLElement).style.display = 'none';
        });

        let activeNav = view;

        if (view === 'chat' && typeof data === 'string') {
            vscode.postMessage({ command: 'loadConversation', payload: { id: data } });
        } else if (view === 'prompt-editor') {
            activeNav = 'prompts';
            const editorContainer = this.parent.querySelector('#view-prompt-editor') as HTMLElement;
            if (editorContainer) {
                editorContainer.style.display = 'block';
            }
            this.promptEditorView.show(data?.prompt);
        } else if (view === 'focus-editor') {
            const container = this.parent.querySelector('#view-focus-editor') as HTMLElement;
            if (!this.focusEditorView) {
                this.focusEditorView = new FocusEditorView(container, data);
            }

            // 直接从 data payload 中获取数据并设置
            if (data.modelConfigs) {
                this.focusEditorView.setModelConfigs(data.modelConfigs);
            }
            if (data.prompts) {
                this.focusEditorView.setPrompts(data.prompts);
            }

            // 每次导航时都更新内容和状态
            this.focusEditorView.updateContent(data.content);
            this.focusEditorView.updateState(data);
            container.style.display = 'flex';
            const topToolbar = this.parent.querySelector('.top-toolbar') as HTMLElement;
            if (topToolbar) topToolbar.style.display = 'none';
            return; // Skip nav update for focus editor
        }

        if (view !== 'prompt-editor') {
            const targetView = this.parent.querySelector(`#view-${view}`);
            if (targetView) {
                (targetView as HTMLElement).style.display = 'flex';
            }
        }

        this.parent.querySelectorAll('.nav-icon').forEach(icon => icon.classList.remove('active'));
        this.parent.querySelector(`#nav-${activeNav}`)?.classList.add('active');
    }

    private render(): string {
        return `
            <div class="top-toolbar">
                <div id="nav-new-chat" class="nav-icon" title="New Chat"><i class="codicon codicon-add"></i></div>
                <div class="nav-separator"></div>
                <div id="nav-chat" class="nav-icon" title="Chat"><i class="codicon codicon-comment-discussion"></i></div>
                <div id="nav-history" class="nav-icon" title="History"><i class="codicon codicon-history"></i></div>
                <div id="nav-prompts" class="nav-icon" title="Prompts"><i class="codicon codicon-symbol-keyword"></i></div>
                <div id="nav-settings" class="nav-icon" title="Settings"><i class="codicon codicon-settings-gear"></i></div>
            </div>
            <div class="main-content">
                <div id="view-welcome" class="view"></div>
                <div id="view-chat" class="view"></div>
                <div id="view-history" class="view"></div>
                <div id="view-prompts" class="view"></div>
                <div id="view-prompt-editor" class="view"></div>
                <div id="view-settings" class="view"></div>
                <div id="view-focus-editor" class="view"></div>
            </div>
        `;
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/ChatHistoryView.ts ---
import { Conversation } from "../../common/types";
import { vscode } from "../vscode";

export class ChatHistoryView {
    private conversations: Conversation[] = [];
    private historyContainer: HTMLElement;

    constructor(
        private readonly parent: HTMLElement,
        private readonly navigate: (view: string, conversationId?: string) => void
    ) {
        this.parent.innerHTML = `<div class="history-container"><h2>Chat History</h2><ul class="history-list"></ul></div>`;
        this.historyContainer = this.parent.querySelector('.history-list') as HTMLElement;
    }

    public setConversations(conversations: Conversation[]) {
        // Sort conversations by date, newest first
        this.conversations = conversations.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
        this.render();
    }

    private render() {
        this.historyContainer.innerHTML = '';
        if (this.conversations.length === 0) {
            this.historyContainer.innerHTML = `<li class="history-empty">No chat history found.</li>`;
            return;
        }

        this.conversations.forEach(conv => {
            const li = document.createElement('li');
            li.className = 'history-item';
            li.dataset.id = conv.id;
            li.addEventListener('click', () => {
                this.navigate('chat', conv.id);
            });

            const content = document.createElement('div');
            content.className = 'history-item-content';

            const timestamp = document.createElement('div');
            timestamp.className = 'history-item-timestamp';
            timestamp.textContent = this.formatDate(conv.createdAt);

            const title = document.createElement('div');
            title.className = 'history-item-title';
            title.textContent = conv.title;

            content.appendChild(timestamp);
            content.appendChild(title);

            const actions = document.createElement('div');
            actions.className = 'history-item-actions';
            
            const deleteButton = document.createElement('button');
            deleteButton.className = 'icon-button';
            deleteButton.title = 'Delete';
            deleteButton.innerHTML = `<i class="codicon codicon-trash"></i>`;
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                vscode.postMessage({ command: 'deleteConversation', payload: { id: conv.id } });
            });

            const exportButton = document.createElement('button');
            exportButton.className = 'icon-button';
            exportButton.title = 'Export';
            exportButton.innerHTML = `<i class="codicon codicon-export"></i>`;
            exportButton.addEventListener('click', (e) => {
                e.stopPropagation();
                // Placeholder for export functionality
                vscode.postMessage({ command: 'info', payload: 'Export functionality is not yet implemented.' });
            });

            actions.appendChild(deleteButton);
            actions.appendChild(exportButton);

            li.appendChild(content);
            li.appendChild(actions);

            this.historyContainer.appendChild(li);
        });
    }

    private formatDate(dateString: string): string {
        const date = new Date(dateString);
        const options: Intl.DateTimeFormatOptions = {
            month: 'long',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric',
            hour12: true
        };
        return date.toLocaleString('en-US', options).replace(',', '');
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/ChatView.ts ---
// --- file_path: webview/views/ChatView.ts ---

import { vscode } from "../vscode";
import { MessageBlock } from "../components/MessageBlock";
import { AtCommandMenu } from "../components/AtCommandMenu";
// 在文件顶部添加新的 import
import { AgentRunBlock } from "../components/AgentRunBlock";
import { Conversation, ChatMessage, ModelConfig, Prompt, AgentPlan, StepExecution, StepUpdate, StepResult, StreamChunk, AgentResult } from "../../common/types"; // 确保 Agent 相关类型被导入

interface CommandLeaf {
    id: string;
    name: string;
    agentId: string;
    description: string;
}

export class ChatView {
    private messages: ChatMessage[] = [];
    private modelConfigs: ModelConfig[] = [];
    private prompts: Prompt[] = [];
    private messageContainer: HTMLElement;
    private bottomPanel: HTMLElement;
    private modelSelector: HTMLSelectElement;
    private promptSelector: HTMLSelectElement;
    private isStreaming: boolean = false;
    private editingMessageIndex: number | null = null;
    private originalMessageContent: string | null = null;
    private atCommandMenu: AtCommandMenu;
    private inputBox: HTMLElement; // 从 HTMLTextAreaElement 改为 HTMLElement
    private activeAgentRunContainer: HTMLElement | null = null;
    private activeAgentRunBlock: AgentRunBlock | null = null;

    constructor(private readonly parent: HTMLElement) {
        this.parent.innerHTML = this.renderInitialLayout();
        this.messageContainer = this.parent.querySelector('.messages-list') as HTMLElement;
        this.bottomPanel = this.parent.querySelector('.chat-sticky-bottom') as HTMLElement;
        this.modelSelector = this.parent.querySelector('#model-selector') as HTMLSelectElement;
        this.promptSelector = this.parent.querySelector('#prompt-selector') as HTMLSelectElement;

        // 渲染输入框并获取其引用
        this.renderBottomInput(); 
        this.inputBox = this.bottomPanel.querySelector('.chat-input-box') as HTMLElement;
        
        // 将菜单附加到 chat-container, 以便使用相对定位
        const commandMenuContainer = this.parent.querySelector('.at-command-menu-container') as HTMLElement;
        this.atCommandMenu = new AtCommandMenu(commandMenuContainer);

        this.setupEventListeners();
    }

    public setConversations(conversations: Conversation[]) {
        if (conversations.length > 0) {
            this.messages = conversations[conversations.length - 1].messages;
        } else {
            this.messages = [];
        }
        this.renderMessages();
    }

    public clearChat() {
        this.messages = [];
        this.renderMessages();
        vscode.postMessage({ command: 'newChat' });
    }

    public loadConversation(conversation: Conversation) {
        this.messages = conversation.messages;
        this.handleCancelEdit(); // Ensure we exit any edit mode when loading a new conversation
        this.renderMessages();
    }

    public setModelConfigs(configs: ModelConfig[]) {
        this.modelConfigs = configs;
        this.renderModelSelector();
    }

    public setPrompts(prompts: Prompt[]) {
        this.prompts = prompts;
        this.renderPromptSelector();
    }

    private setupEventListeners() {
        // Listener for all clicks in the view
        this.parent.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            const button = target.closest('button');

            // 如果点击了输入框外部，且@菜单是可见的，则隐藏它
            if (!this.inputBox.contains(target) && !this.atCommandMenu['element'].contains(target)) {
                this.atCommandMenu.hide();
            }

            if (this.editingMessageIndex !== null) {
                const editingBlock = this.parent.querySelector('.message-block.editing');
                if (editingBlock && !editingBlock.contains(target) && !this.bottomPanel.contains(target)) {
                    this.handleCancelEdit();
                    return;
                }
            }

            if (!button) return;
            const action = button.dataset.action;
            if (!action) return;

            const messageBlock = target.closest('.message-block');
            const messageIndex = messageBlock ? parseInt((messageBlock as HTMLElement).dataset.index || '-1', 10) : -1;

            switch (action) {
                case 'send-or-save': this.handleSendOrSave(); break;
                case 'copy-content': if (messageIndex !== -1) this.handleCopy(messageIndex); break;
                case 'regenerate-response': if (messageIndex !== -1) this.handleRegenerate(messageIndex); break;
                case 'edit-message': if (messageIndex !== -1) this.handleEnterEditMode(messageIndex); break;
                case 'maximize-editor': this.handleMaximizeEditor(); break;
                case 'toggle-fold':
                    if (messageBlock) {
                        const icon = button.querySelector('i');
                        messageBlock.classList.toggle('folded');
                        if (messageBlock.classList.contains('folded')) {
                            button.title = 'Expand';
                            icon?.classList.remove('codicon-chevron-up');
                            icon?.classList.add('codicon-chevron-down');
                        } else {
                            button.title = 'Fold';
                            icon?.classList.remove('codicon-chevron-down');
                            icon?.classList.add('codicon-chevron-up');
                        }
                    }
                    break;

            }
        });

        window.addEventListener('resize', () => {

        });

        this.modelSelector.addEventListener('change', () => {
            vscode.postMessage({
                command: 'syncStateChange',
                payload: { modelId: this.modelSelector.value }
            });
        });

        this.promptSelector.addEventListener('change', () => {
            const selectedPromptId = this.promptSelector.value;
            vscode.postMessage({
                command: 'syncStateChange',
                payload: { promptId: selectedPromptId }
            });

            if (selectedPromptId) {
                const selectedPrompt = this.prompts.find(p => p.id === selectedPromptId);
                if (selectedPrompt) {
                    // 更新为操作 contenteditable div
                    if (this.inputBox) {
                        this.inputBox.innerText = selectedPrompt.content;
                        this.inputBox.focus();
                        vscode.postMessage({
                            command: 'updateWebviewContent',
                            payload: { content: this.inputBox.innerText }
                        });
                    }
                }
            }
        });

        window.addEventListener('message', event => {
            const message = event.data;
            const { command, payload } = message;
            // 如果存在活动的 AgentRunBlock，则将事件转发给它处理
            if (this.activeAgentRunBlock) {
                switch (command) {
                    case 'agent:stepStart':
                        console.log('[ChatView] Received agent:stepStart:', payload);
                        this.activeAgentRunBlock.updateStep(payload as StepExecution); // Explicit cast
                        return;
                    case 'agent:stepEnd': 
                        console.log('[ChatView] Received agent:stepEnd:', payload);
                        this.activeAgentRunBlock.updateStep(payload as StepResult); // Explicit cast
                        return;
                    case 'agent:stepUpdate':
                        this.activeAgentRunBlock.addStepLog(payload);
                        return;
                    case 'agent:streamChunk':
                        this.activeAgentRunBlock.appendStreamChunk(payload);
                        return;
                    case 'agent:end':
                        this.activeAgentRunBlock.setAgentResult(payload);
                        this.activeAgentRunBlock = null; 
                        this.activeAgentRunContainer = null;
                        return;
                }
            }
            
            // 如果没有活动的 AgentRunBlock，则可能是创建新实例的事件
            if (command === 'agent:planGenerated' && this.activeAgentRunContainer) {
                const plan: AgentPlan = payload;
                const onExecute = (params: Record<string, any>) => {
                    vscode.postMessage({
                        command: 'agent:execute',
                        payload: {
                            agentId: plan.agentId,
                            parameters: params
                        }
                    });
                };
                this.activeAgentRunBlock = new AgentRunBlock(
                    this.activeAgentRunContainer,
                    plan,
                    onExecute
                );
                return; 
            }

            switch (message.command) {
                case 'startStreaming': this.beginStream(); break;
                case 'streamData': this.appendStreamData(message.payload); break;
                case 'streamEnd': this.finalizeStream(); break;
                case 'requestFailed': this.handleRequestFailed(message.payload.error); break;
                case 'setActiveConversation': this.loadConversation(message.payload); break;
                case 'updatePrompts': this.setPrompts(message.payload); break;
                case 'updateContent': {
                    if (this.inputBox && this.inputBox.innerText !== message.payload.content) {
                        this.inputBox.innerText = message.payload.content;
                    }
                    break;
                }
                case 'clearInput': {
                    if (this.inputBox) {
                       this.inputBox.innerHTML = '';
                    }
                    break;
                }
                case 'focusEditorClosed': this.toggleMaximizeButton(false); break;
                case 'updateState':
                    if (message.payload.modelId) {
                        this.modelSelector.value = message.payload.modelId;
                    }
                    if (message.payload.promptId) {
                        this.promptSelector.value = message.payload.promptId;
                    }
                    break;
            }
        });
    }

    private handleSendOrSave() {
        if (this.editingMessageIndex !== null) {
            this.handleSaveEdit(this.editingMessageIndex);
        } else {
            this.handleSendMessage();
        }
    }

    private handleSendMessage() {
        if (this.isStreaming) {
            vscode.postMessage({ command: 'stopMessage' });
            return;
        }
        
        const prompt = this.inputBox.innerText.trim();
        if (!prompt) return;

        const selectedModelId = this.modelSelector.value;
        const selectedConfig = this.modelConfigs.find(c => c.id === selectedModelId);

        if (!selectedConfig) {
            vscode.postMessage({ command: 'error', payload: 'Please select a valid model from settings.' });
            return;
        }

        const message: ChatMessage = { role: 'user', content: prompt };
        this.messages.push(message);
        this.renderMessages();

        this.inputBox.innerHTML = '';
        vscode.postMessage({ command: 'sendMessage', payload: { prompt, config: selectedConfig } });
    }

    private handleCopy(index: number) {
        navigator.clipboard.writeText(this.messages[index].content);
        vscode.postMessage({ command: 'info', payload: 'Copied to clipboard!' });
    }

    private handleRegenerate(index: number) {
        vscode.postMessage({ command: 'regenerate', payload: { messageIndex: index } });
    }

    private handleEnterEditMode(index: number) {
        if (this.editingMessageIndex === index) return;

        if (this.editingMessageIndex !== null) {
            this.handleCancelEdit();
        }

        this.editingMessageIndex = index;
        this.originalMessageContent = this.messages[index].content;

        if (this.inputBox) {
            this.inputBox.innerText = this.originalMessageContent;
            this.inputBox.focus();
        }

        this.renderMessages();
        this.updateSendButtonState();
    }

    private handleCancelEdit() {
        if (this.editingMessageIndex === null) return;

        if (this.originalMessageContent !== null) {
            this.messages[this.editingMessageIndex].content = this.originalMessageContent;
        }

        this.editingMessageIndex = null;
        this.originalMessageContent = null;

        if (this.inputBox) {
            this.inputBox.innerHTML = '';
        }

        this.renderMessages();
        this.updateSendButtonState();
    }

    private handleSaveEdit(index: number) {
        if (!this.inputBox) return;
        const newContent = this.inputBox.innerText.trim();
        if (newContent) {
            this.messages[index].content = newContent;
            vscode.postMessage({ command: 'editMessage', payload: { messageIndex: index, content: newContent } });
        }

        this.editingMessageIndex = null;
        this.originalMessageContent = null;

        this.inputBox.innerHTML = '';

        this.renderMessages();
        this.updateSendButtonState();
    }

    private beginStream() {
        this.isStreaming = true;
        const assistantMessage: ChatMessage = { role: 'assistant', content: '' };
        this.messages.push(assistantMessage);
        this.renderMessages();
        this.updateSendButtonState();
    }

    private appendStreamData(chunk: string) {
        const lastMessage = this.messages[this.messages.length - 1];
        if (lastMessage?.role === 'assistant') {
            lastMessage.content += chunk;
            this.renderMessages();
        }
    }

    private finalizeStream(stopped = false) {
        this.isStreaming = false;
        const lastMessage = this.messages[this.messages.length - 1];
        if (stopped && lastMessage?.role === 'assistant') {
            lastMessage.content += ' (Stopped)';
        }
        this.renderMessages();
        this.updateSendButtonState();
    }

    private handleRequestFailed(error: string) {
        this.finalizeStream();
        this.messages.pop();
        const lastUserMessage = this.messages.pop();

        this.renderMessages();

        if (lastUserMessage) {
            if (this.inputBox) this.inputBox.innerText = lastUserMessage.content;
        }

        const errorElement = document.createElement('div');
        errorElement.className = 'message-block assistant error';
        errorElement.textContent = `Error: ${error}`;
        this.messageContainer.appendChild(errorElement);
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
    }

    private handleMaximizeEditor() {
        if (this.inputBox) {
            vscode.postMessage({
                command: 'openFocusEditor',
                payload: {
                    content: this.inputBox.innerText,
                    modelId: this.modelSelector.value,
                    promptId: this.promptSelector.value
                }
            });
            this.toggleMaximizeButton(true);
        }
    }

    private toggleMaximizeButton(isMaximized: boolean) {
        const button = this.bottomPanel.querySelector('button[data-action="maximize-editor"]') as HTMLButtonElement;
        if (button) {
            if (isMaximized) {
                button.innerHTML = `<i class="codicon codicon-screen-normal"></i>`;
                button.title = '恢复至侧边栏';
            } else {
                button.innerHTML = `<i class="codicon codicon-screen-full"></i>`;
                button.title = '最大化编辑';
            }
        }
    }

    private renderMessages() {
        this.messageContainer.innerHTML = '';
        this.messages.forEach((msg, index) => {
            const element = new MessageBlock(msg, index).render();
            if (this.editingMessageIndex === index) {
                element.classList.add('editing');
            }
            this.messageContainer.appendChild(element);
        });
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
    }

    private renderBottomInput() {
        const container = this.bottomPanel.querySelector('.chat-input-box-container');
        if (!container) return;

        // 关键改动：使用 contenteditable div 替换 textarea
        container.innerHTML = `<div class="chat-input-box" contenteditable="true" placeholder="输入消息，或用'@'触发命令..."></div>`;
        const inputBox = container.querySelector('.chat-input-box') as HTMLElement;

        inputBox.addEventListener('keydown', (e) => {
            if (this.atCommandMenu.isVisible()) {
                this.atCommandMenu.handleKeyDown(e);
                return; // 阻止后续的 Enter 发送等行为
            }

            // 优化 Backspace 处理逻辑，使其更健壮
            if (e.key === 'Backspace') {
                const sel = window.getSelection();
                if (sel && sel.isCollapsed) {
                    const range = sel.getRangeAt(0);
                    // 此条件适用于光标位于输入框容器内，且其前方有节点（例如，在Pill之后）
                    if (range.startContainer === inputBox && range.startOffset > 0) {
                        const nodeToDelete = inputBox.childNodes[range.startOffset - 1];
                        // 检查待删除的节点是否是Pill
                        if (nodeToDelete && nodeToDelete.nodeName === 'SPAN' && (nodeToDelete as HTMLElement).classList.contains('content-pill')) {
                            e.preventDefault();
                            nodeToDelete.remove();
                            return; // 阻止默认的Backspace行为
                        }
                    }
                }
            }

            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.handleSendOrSave();
            }
        });

        inputBox.addEventListener('input', () => {
            this.handleInputForAtCommand(inputBox);
            vscode.postMessage({
                command: 'updateWebviewContent',
                payload: { content: inputBox.innerText }
            });
        });

        // 如果输入框为空，显示 placeholder
        inputBox.addEventListener('focus', () => {
             if (inputBox.getAttribute('placeholder')) {
                inputBox.removeAttribute('placeholder');
             }
        });
        inputBox.addEventListener('blur', () => {
            if (!inputBox.textContent) {
                 inputBox.setAttribute('placeholder', "输入消息，或用'@'触发命令...");
            }
        });

        this.updateSendButtonState();
    }

    /**
     * 处理输入事件，用于触发 @ 命令菜单
     */
    private handleInputForAtCommand(inputBox: HTMLElement) {
        // 1. 如果输入框中已经存在一个Pill，则不应触发@命令菜单。
        if (inputBox.querySelector('.content-pill')) {
            this.atCommandMenu.hide();
            return;
        }

        // 2. 获取整个输入框的纯文本内容。
        const text = inputBox.innerText;

        // 3. 仅当文本以 '@' 字符开头时才显示菜单。
        //    这避免了在文本中间输入'@'时触发菜单。
        if (text.startsWith('@')) {
            // 传递@后面的部分，供菜单内部使用（即使当前过滤已禁用）
            const filter = text.substring(1);
            this.atCommandMenu.show(
                filter,
                (command) => { 
                    this.handleAgentCommandSelected(command); 
                }
            );
        } else {
            this.atCommandMenu.hide();
        }
    }

    /**
     * 新增方法：处理从 @ 菜单中选择 Agent 命令的逻辑
     * @param command 选中的 CommandLeaf 对象
     */
    private handleAgentCommandSelected(command: CommandLeaf) {
        // 1. 清空输入框
        this.inputBox.innerHTML = '';
        this.atCommandMenu.hide();

        // 2. 在消息列表中创建一个新的 div 容器，作为 AgentRunBlock 的占位符
        this.activeAgentRunContainer = document.createElement('div');
        this.messageContainer.appendChild(this.activeAgentRunContainer);
        
        // 确保视图滚动到底部，以便用户能看到新创建的容器（即使它现在是空的）
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;

        // 3. 向后端发送消息，请求这个 Agent 的执行计划
        vscode.postMessage({
            command: 'agent:getPlan',
            payload: {
                agentId: command.agentId
            }
        });
    }

    /**
     * 将选中的 Agent 命令作为 "Pill" 插入到输入框中
     */
    // 更新方法签名以接收完整的 CommandLeaf 对象
    private insertAgentPill(command: { agentId: string, name: string }) {
        // 使用更具描述性的 Pill 内容
        const pillHtml = `<span class="content-pill" contenteditable="false" data-agent-id="${command.agentId}">@${command.name}</span> `;
        
        // 清空输入框并插入 Pill
        this.inputBox.innerHTML = pillHtml;
        this.inputBox.focus();

        // 移动光标到最后
        const selection = window.getSelection();
        if (selection) {
            const range = document.createRange();
            range.selectNodeContents(this.inputBox);
            range.collapse(false); // false 表示折叠到末尾
            selection.removeAllRanges();
            selection.addRange(range);
        }

        this.atCommandMenu.hide();
    }

    private updateSendButtonState() {
        const sendButton = this.bottomPanel.querySelector('button[data-action="send-or-save"]');
        if (sendButton) {
            if (this.isStreaming) {
                sendButton.textContent = 'Stop';
                sendButton.classList.add('streaming');
            } else if (this.editingMessageIndex !== null) {
                sendButton.textContent = 'Save';
                sendButton.classList.remove('streaming');
            } else {
                sendButton.textContent = 'Send';
                sendButton.classList.remove('streaming');
            }
        }
    }

    private renderInitialLayout(): string {
        return `
            <div class="chat-container">
                <div class="messages-list"></div>
                <div class="chat-sticky-bottom">
                    <div class="at-command-menu-container"></div>
                    <div class="chat-quick-actions">
                        <label for="model-selector">Model:</label>
                        <select id="model-selector"></select>
                        <label for="prompt-selector">Prompt:</label>
                        <select id="prompt-selector"></select>
                        <button data-action="maximize-editor" title="最大化编辑">
                            <i class="codicon codicon-screen-full"></i>
                        </button>
                        <button data-action="send-or-save">Send</button>
                    </div>
                    <div class="chat-input-box-container"></div>
                </div>
            </div>
        `;
    }

    private renderModelSelector() {
        this.modelSelector.innerHTML = '';
        const defaultModel = this.modelConfigs.find(c => c.isDefault);
        this.modelConfigs.forEach(config => {
            const option = document.createElement('option');
            option.value = config.id;
            option.textContent = config.name;
            if (defaultModel && config.id === defaultModel.id) {
                option.selected = true;
            }
            this.modelSelector.appendChild(option);
        });
    }

    private renderPromptSelector() {
        this.promptSelector.innerHTML = '<option value="">Select a prompt...</option>';
        this.prompts.forEach(prompt => {
            const option = document.createElement('option');
            option.value = prompt.id;
            option.textContent = prompt.title;
            this.promptSelector.appendChild(option);
        });
    }

    private autoResizeInput(textarea: HTMLTextAreaElement) {
        textarea.style.height = 'auto';
        const scrollHeight = textarea.scrollHeight;
        const maxHeight = 250; // Synced with main.css

        if (scrollHeight > maxHeight) {
            textarea.style.height = `${maxHeight}px`;
            textarea.style.overflowY = 'auto';
        } else {
            textarea.style.height = `${scrollHeight}px`;
            textarea.style.overflowY = 'hidden';
        }
    }
    
    // --- 新增：模拟后端处理器 ---
    private mockBackendHandler(agentId: string, agentName: string) {
        // 1. 创建 AgentRunBlock 的容器并添加到聊天列表中
        const agentRunContainer = document.createElement('div');
        this.messageContainer.appendChild(agentRunContainer);
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;

        // 2. 定义模拟的 AgentPlan 数据
        const mockPlan: AgentPlan = {
            agentId: 'docgen-project',
            agentName: '项目级文档生成',
            steps: [
                { name: "规划: 分析项目结构", description: "分析文件树，规划需要分析的核心模块。", promptFiles: ['project_planner.yml'] },
                { name: "执行: 并行分析所有模块", description: "为每个已规划的模块生成详细的文档。", promptFiles: ['module_analysis_direct.yml', 'module_analysis_mapreduce.yml']},
                { name: "综合: 生成最终文档", description: "将所有模块分析结果汇编成最终的项目设计文档。", promptFiles: ['project_synthesis.yml'] }
            ],
            parameters: [] // 项目级文档生成不需要参数
        };


        // 3. 定义执行回调，当用户点击“开始执行”时触发
        const onExecute = (params: Record<string, any>) => {
            console.log("Mock backend received execute command with params:", params);
            this.runMockExecution(agentBlock, mockPlan);
        };

        // 4. 创建 AgentRunBlock 实例，传入容器、计划和回调
        const agentBlock = new AgentRunBlock(agentRunContainer, mockPlan, onExecute);
    }
    
    // --- 新增：模拟执行流程 ---
    private runMockExecution(agentBlock: AgentRunBlock, plan: AgentPlan) {
        const runId = `run_${Date.now()}`;
        let eventIndex = 0;
        
        // 模拟从 plan.json 读取到的模块列表
        const plannedModules = [
            { name: "核心业务模块", path: "agile-boot/agile-spring-boot-starter" },
            { name: "前端控制台工具", path: "agile-boot/agile-console" },
            { name: "后台管理服务", path: "agile-boot/agile-serve-admin" },
            { name: "文件上传服务", path: "agile-boot/agile-spring-upload" },
            { name: "RESTful接口服务", path: "agile-boot/agile-serve-restful" },
            { name: "验证码服务", path: "agile-boot/agile-spring-captcha" }
        ];

        // 高保真模拟事件流
        const mockEventStream: (StepExecution | StepUpdate | StreamChunk | AgentResult)[] = [
            // === 阶段 1: 规划 ===
            { runId, taskId: 'task_plan', stepName: "规划: 分析项目结构", status: 'running' } as StepExecution,
            { runId, taskId: 'task_plan', type: 'llm-request', data: { name: '规划请求' }, metadata: { type: 'file', path: '.codewiki/runs/.../01_planning_request.txt' } } as StepUpdate,
            { runId, taskId: 'task_plan', type: 'output', data: { name: '规划响应' }, metadata: { type: 'file', path: '.codewiki/runs/.../01_planning_response.txt' } } as StepUpdate,
            { runId, taskId: 'task_plan', stepName: "规划: 分析项目结构", status: 'completed' } as StepExecution,

            // === 阶段 2: 并行分析 (父任务启动) ===
            { runId, taskId: 'task_parallel_parent', stepName: "执行: 并行分析所有模块", status: 'running' } as StepExecution,
            
            // --- 模拟所有子任务的创建 ---
            { runId, taskId: 'task_mod_1', stepName: "分析模块: '核心业务模块'", status: 'running' } as StepExecution,
            { runId, taskId: 'task_mod_2', stepName: "分析模块: '前端控制台工具'", status: 'running' } as StepExecution,
            { runId, taskId: 'task_mod_3', stepName: "分析模块: '后台管理服务'", status: 'running' } as StepExecution,
            // ... 其他模块也在这里启动

            // --- 模块 1 的完整生命周期 ---
            { runId, taskId: 'task_mod_1', type: 'llm-request', data: { name: '核心业务模块分析请求' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_agile-spring-boot-starter/llm_request.txt' } } as StepUpdate,
            // (此时UI应显示等待动画)
            { runId, taskId: 'task_mod_1', content: '### 核心业务模块\n\n该模块是系统的核心...' } as StreamChunk,
            { runId, taskId: 'task_mod_1', content: '它包含了主要的业务逻辑和实体定义。' } as StreamChunk,
            { runId, taskId: 'task_mod_1', type: 'output', data: { name: '模块文档' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_核心业务模块.md' } } as StepUpdate,
            { runId, taskId: 'task_mod_1', stepName: "分析模块: '核心业务模块'", status: 'completed' } as StepExecution,

            // --- 模块 2 的完整生命周期 ---
            { runId, taskId: 'task_mod_2', type: 'llm-request', data: { name: '前端控制台工具分析请求' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_agile-console/llm_request.txt' } } as StepUpdate,
            // (UI显示等待)
            { runId, taskId: 'task_mod_2', content: '### 前端控制台工具\n\n提供了命令行工具...' } as StreamChunk,
            { runId, taskId: 'task_mod_2', type: 'output', data: { name: '模块文档' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_前端控制台工具.md' } } as StepUpdate,
            { runId, taskId: 'task_mod_2', stepName: "分析模块: '前端控制台工具'", status: 'completed' } as StepExecution,

            // ... (模块3 及以后同理)
            { runId, taskId: 'task_mod_3', type: 'llm-request', data: { name: '后台管理服务分析请求' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_agile-serve-admin/llm_request.txt' } } as StepUpdate,
            { runId, taskId: 'task_mod_3', type: 'output', data: { name: '模块文档' }, metadata: { type: 'file', path: '.codewiki/runs/.../module_后台管理服务.md' } } as StepUpdate,
            { runId, taskId: 'task_mod_3', stepName: "分析模块: '后台管理服务'", status: 'completed' } as StepExecution,


            // === 阶段 2: 并行分析 (父任务完成) ===
            { runId, taskId: 'task_parallel_parent', stepName: "执行: 并行分析所有模块", status: 'completed' } as StepExecution,
            
            // === 阶段 3: 综合 (也遵循完整周期) ===
            { runId, taskId: 'task_synthesis', stepName: "综合: 生成最终文档", status: 'running' } as StepExecution,
            { runId, taskId: 'task_synthesis', type: 'llm-request', data: { name: '综合请求' }, metadata: { type: 'file', path: '.codewiki/runs/.../03_synthesis_request.txt' } } as StepUpdate,
            // (UI显示等待)
            { runId, taskId: 'task_synthesis', content: '# Agile-Boot 项目总体设计文档\n\n' } as StreamChunk,
            { runId, taskId: 'task_synthesis', content: '本文档旨在提供Agile-Boot项目的整体架构...' } as StreamChunk,
            { runId, taskId: 'task_synthesis', stepName: "综合: 生成最终文档", status: 'completed' } as StepExecution,

            // === 最终结果 ===
            { runId, status: 'completed', finalOutput: "项目总体设计文档.md 已生成。" } as AgentResult
        ];


        const intervalId = setInterval(() => {
            if (eventIndex >= mockEventStream.length) {
                clearInterval(intervalId);
                return;
            }

            const event = mockEventStream[eventIndex++];
            
            // highlight-start
            // 更稳健的类型检查和派发，修复了原有逻辑错误
            if ('stepName' in event && 'status' in event && 'runId' in event) {
                // 这是 StepExecution 事件
                agentBlock.updateStep(event as StepExecution);
            } else if ('status' in event && 'runId' in event && !('stepName' in event)) {
                // 这是 AgentResult 事件
                 agentBlock.setAgentResult(event as AgentResult);
            } else if ('type' in event && 'data' in event) {
                // 这是 StepUpdate 事件
                agentBlock.addStepLog(event as StepUpdate);
            } else if ('content' in event && !('role' in event)) {
                // 这是 StreamChunk 事件
                 agentBlock.appendStreamChunk(event as StreamChunk);
            }
            // highlight-end

        }, 3000); // 每 800 毫秒发送一个事件
    }
}

--------------------------------------------------------------------------------

--- file_path: webview/views/FocusEditorView.ts ---
import { vscode } from "../vscode";
import { ModelConfig, Prompt } from "../../common/types";

export class FocusEditorView {
    private parent: HTMLElement;
    private modelConfigs: ModelConfig[] = [];
    private prompts: Prompt[] = [];
    private modelSelector: HTMLSelectElement;
    private promptSelector: HTMLSelectElement;
    private textarea: HTMLTextAreaElement;

    constructor(container: HTMLElement, initialData: { content: string, modelId?: string, promptId?: string }) {
        this.parent = container;
        this.parent.innerHTML = this.render();
        
        this.modelSelector = this.parent.querySelector('#model-selector') as HTMLSelectElement;
        this.promptSelector = this.parent.querySelector('#prompt-selector') as HTMLSelectElement;
        this.textarea = this.parent.querySelector('textarea') as HTMLTextAreaElement;

        this.textarea.value = initialData.content;
        if (initialData.modelId) {
            this.modelSelector.value = initialData.modelId;
        }
        if (initialData.promptId) {
            this.promptSelector.value = initialData.promptId;
        }

        this.setupEventListeners();
    }

    public render(): string {
        return `
            <div class="focus-editor-container">
                <div class="chat-quick-actions">
                    <label for="model-selector">Model:</label>
                    <select id="model-selector"></select>
                    <label for="prompt-selector">Prompt:</label>
                    <select id="prompt-selector"></select>
                    <button data-action="minimize-editor" title="恢复至侧边栏">
                        <i class="codicon codicon-screen-normal"></i>
                    </button>
                    <button data-action="send-message">Send</button>
                </div>
                <div class="chat-input-box-container">
                     <textarea placeholder="输入消息，或从下拉菜单选择提示词..."></textarea>
                </div>
            </div>
        `;
    }

    private setupEventListeners() {
        this.parent.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            const button = target.closest('button');
            if (!button) return;

            const action = button.dataset.action;
            switch (action) {
                case 'send-message':
                    this.handleSendMessage();
                    break;
                case 'minimize-editor':
                    vscode.postMessage({ command: 'closeFocusEditor' });
                    break;
            }
        });

        this.modelSelector.addEventListener('change', () => {
            vscode.postMessage({
                command: 'syncStateChange',
                payload: { modelId: this.modelSelector.value }
            });
        });

        this.promptSelector.addEventListener('change', () => {
            const selectedPromptId = this.promptSelector.value;
            vscode.postMessage({
                command: 'syncStateChange',
                payload: { promptId: selectedPromptId }
            });
        });

        this.textarea.addEventListener('input', () => {
            vscode.postMessage({
                command: 'updateWebviewContent',
                payload: { content: this.textarea.value }
            });
        });

        this.textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.handleSendMessage();
            }
        });

        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.command) {
                case 'updateState':
                    this.updateState(message.payload);
                    break;
                case 'updatePrompts':
                    this.setPrompts(message.payload);
                    break;
                case 'updateContent':
                    this.updateContent(message.payload.content);
                    break;
            }
        });
    }

    public setModelConfigs(configs: ModelConfig[]) {
        this.modelConfigs = configs;
        const currentVal = this.modelSelector.value;
        this.renderModelSelector();
        this.modelSelector.value = currentVal;
    }

    public setPrompts(prompts: Prompt[]) {
        this.prompts = prompts;
        const currentVal = this.promptSelector.value;
        this.renderPromptSelector();
        this.promptSelector.value = currentVal;
    }

    public updateContent(content: string) {
        if (this.textarea.value !== content) {
            this.textarea.value = content;
        }
    }

    public updateState(state: { modelId?: string, promptId?: string }) {
        if (state.modelId) {
            this.modelSelector.value = state.modelId;
        }
        if (state.promptId) {
            this.promptSelector.value = state.promptId;
        }
    }

    public clearInput() {
        this.textarea.value = '';
    }

    private handleSendMessage() {
        const prompt = this.textarea.value.trim();
        if (prompt) {
            const selectedModelId = this.modelSelector.value;
            const selectedConfig = this.modelConfigs.find(c => c.id === selectedModelId);

            if (!selectedConfig) {
                vscode.postMessage({ command: 'error', payload: 'Please select a valid model from settings.' });
                return;
            }
            
            vscode.postMessage({ command: 'sendMessage', payload: { prompt, config: selectedConfig } });
            this.clearInput();
        }
    }

    private renderModelSelector() {
        this.modelSelector.innerHTML = '';
        const defaultModel = this.modelConfigs.find(c => c.isDefault);
        this.modelConfigs.forEach(config => {
            const option = document.createElement('option');
            option.value = config.id;
            option.textContent = config.name;
            if (defaultModel && config.id === defaultModel.id) {
                option.selected = true;
            }
            this.modelSelector.appendChild(option);
        });
    }

    private renderPromptSelector() {
        this.promptSelector.innerHTML = '<option value="">Select a prompt...</option>';
        this.prompts.forEach(prompt => {
            const option = document.createElement('option');
            option.value = prompt.id;
            option.textContent = prompt.title;
            this.promptSelector.appendChild(option);
        });
    }

}


--------------------------------------------------------------------------------

--- file_path: webview/views/PromptEditorView.ts ---
import { Prompt } from '../../common/types';
import { vscode } from '../vscode';

export class PromptEditorView {
    private element: HTMLElement;
    private prompt: Prompt | null = null;
    private isDirty = false;

    constructor(private readonly parent: HTMLElement) {
        this.element = document.createElement('div');
        this.element.className = 'prompt-editor-view';
        this.parent.appendChild(this.element);
    }

    public show(prompt?: Prompt) {
        this.prompt = prompt ? { ...prompt } : null;
        this.isDirty = false;
        this.render();
        this.addEventListeners();
        this.element.style.display = 'flex';
    }

    public hide() {
        if (this.isDirty) {
            const confirmation = window.confirm('您有未保存的更改，确定要放弃吗？');
            if (!confirmation) {
                return;
            }
        }
        this.element.style.display = 'none';
        this.element.innerHTML = '';
        // Let the extension handle the navigation
        vscode.postMessage({ command: 'cancelPromptEdit' });
    }

    private render() {
        const title = this.prompt?.title ?? '';
        const content = this.prompt?.content ?? '';
        const headerTitle = this.prompt ? `编辑: ${title}` : '新建提示词';

        this.element.innerHTML = `
            <div class="view-header">
                <h3>${headerTitle}</h3>
                <div class="actions">
                    <button id="save-prompt-btn" class="codicon-btn">
                        <i class="codicon codicon-save"></i>
                        <span>保存</span>
                    </button>
                    <button id="cancel-prompt-edit-btn" class="codicon-btn secondary">
                        <i class="codicon codicon-close"></i>
                        <span>取消</span>
                    </button>
                </div>
            </div>
            <div class="prompt-editor-form">
                <div class="form-group">
                    <label for="prompt-title">标题</label>
                    <input type="text" id="prompt-title" value="${title}" required>
                </div>
                <div class="form-group">
                    <label for="prompt-content">内容</label>
                    <textarea id="prompt-content" rows="15">${content}</textarea>
                </div>
            </div>
        `;
    }

    private addEventListeners() {
        const saveBtn = this.element.querySelector('#save-prompt-btn');
        const cancelBtn = this.element.querySelector('#cancel-prompt-edit-btn');
        const titleInput = this.element.querySelector('#prompt-title') as HTMLInputElement;
        const contentTextArea = this.element.querySelector('#prompt-content') as HTMLTextAreaElement;

        const markDirty = () => { this.isDirty = true; };
        titleInput.addEventListener('input', markDirty);
        contentTextArea.addEventListener('input', markDirty);

        if (saveBtn) {
            saveBtn.addEventListener('click', () => {
                if (!titleInput.value.trim()) {
                    vscode.postMessage({ command: 'showError', payload: '标题不能为空。' });
                    return;
                }

                const now = new Date().toISOString();
                const promptToSave: Prompt = {
                    id: this.prompt?.id || `prompt_${Date.now()}`,
                    title: titleInput.value.trim(),
                    content: contentTextArea.value,
                    createdAt: this.prompt?.createdAt || now,
                    updatedAt: now,
                };

                vscode.postMessage({ command: 'savePrompt', payload: promptToSave });
                this.isDirty = false;
            });
        }

        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                this.hide();
            });
        }
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/PromptManagerView.ts ---
import { Prompt } from '../../common/types';
import { vscode } from '../vscode';

export class PromptManagerView {
    private prompts: Prompt[] = [];
    private filteredPrompts: Prompt[] = [];
    private element: HTMLElement;

    constructor(private readonly parent: HTMLElement) {
        this.element = document.createElement('div');
        this.element.className = 'prompt-manager-view';
        this.parent.appendChild(this.element);
        this.render();
        this.addEventListeners();
    }

    public update(prompts: Prompt[]) {
        this.prompts = prompts.sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
        this.filteredPrompts = [...this.prompts];
        this.render();
        this.addEventListeners();
    }

    public getPrompts(): Prompt[] {
        return this.prompts;
    }

    private render() {
        this.element.innerHTML = `
            <div class="view-header">
                <div class="search-bar">
                    <i class="codicon codicon-search"></i>
                    <input type="text" id="prompt-search-input" placeholder="搜索提示词...">
                </div>
                <button id="new-prompt-btn" class="codicon-btn">
                    <i class="codicon codicon-add"></i>
                    <span>新建提示词</span>
                </button>
            </div>
            <div class="prompt-list-container">
                ${this.filteredPrompts.length > 0 ? this.renderList() : this.renderEmptyState()}
            </div>
        `;
    }

    private renderList(): string {
        return `
            <ul class="prompt-list">
                ${this.filteredPrompts.map(prompt => this.renderListItem(prompt)).join('')}
            </ul>
        `;
    }

    private renderListItem(prompt: Prompt): string {
        const summary = prompt.content.substring(0, 100) + (prompt.content.length > 100 ? '...' : '');
        const lastUpdated = new Date(prompt.updatedAt).toLocaleString();

        return `
            <li class="prompt-list-item" data-id="${prompt.id}">
                <div class="prompt-item-main">
                    <div class="prompt-item-title">${prompt.title}</div>
                    <div class="prompt-item-summary">${summary}</div>
                </div>
                <div class="prompt-item-meta">
                    <div class="prompt-item-time">${lastUpdated}</div>
                    <div class="prompt-item-actions">
                        <button class="icon-btn edit-prompt-btn" data-id="${prompt.id}" title="编辑">
                            <i class="codicon codicon-edit"></i>
                        </button>
                        <button class="icon-btn delete-prompt-btn" data-id="${prompt.id}" title="删除">
                            <i class="codicon codicon-trash"></i>
                        </button>
                    </div>
                </div>
            </li>
        `;
    }

    private renderEmptyState(): string {
        return `
            <div class="empty-state">
                <p>您还没有任何提示词模板，点击“新建提示词”来创建第一个吧！</p>
                <button id="new-prompt-btn-empty" class="highlighted-btn">新建提示词</button>
            </div>
        `;
    }

    private addEventListeners() {
        // New prompt button
        const newPromptBtn = this.element.querySelector('#new-prompt-btn');
        if (newPromptBtn) {
            newPromptBtn.addEventListener('click', () => {
                vscode.postMessage({ command: 'newPrompt' });
            });
        }
        const newPromptBtnEmpty = this.element.querySelector('#new-prompt-btn-empty');
        if (newPromptBtnEmpty) {
            newPromptBtnEmpty.addEventListener('click', () => {
                vscode.postMessage({ command: 'newPrompt' });
            });
        }

        // Search input
        const searchInput = this.element.querySelector('#prompt-search-input') as HTMLInputElement;
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                const searchTerm = (e.target as HTMLInputElement).value.toLowerCase();
                this.filteredPrompts = this.prompts.filter(p => 
                    p.title.toLowerCase().includes(searchTerm) || 
                    p.content.toLowerCase().includes(searchTerm)
                );
                this.render();
                this.addEventListeners();
            });
        }

        // List item clicks
        this.element.querySelectorAll('.prompt-list-item').forEach(item => {
            item.addEventListener('click', (e) => {
                const target = e.target as HTMLElement;
                // Don't trigger edit if clicking on a button
                if (!target.closest('button')) {
                    const promptId = item.getAttribute('data-id');
                    if (promptId) {
                        vscode.postMessage({ command: 'editPrompt', payload: { id: promptId } });
                    }
                }
            });
        });

        // Edit buttons
        this.element.querySelectorAll('.edit-prompt-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const promptId = (btn as HTMLElement).dataset.id;
                if (promptId) {
                    vscode.postMessage({ command: 'editPrompt', payload: { id: promptId } });
                }
            });
        });

        // Delete buttons
        this.element.querySelectorAll('.delete-prompt-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const promptId = (btn as HTMLElement).dataset.id;
                if (promptId) {
                    vscode.postMessage({ command: 'deletePrompt', payload: { id: promptId } });
                }
            });
        });
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/SettingsView.ts ---
import { ModelConfig } from "../../common/types";
import { vscode } from "../vscode";

export class SettingsView {
    private configs: ModelConfig[] = [];

    constructor(private readonly parent: HTMLElement) {
        this.render();
        this.setupEventListeners();
    }

    public setModelConfigs(configs: ModelConfig[]) {
        this.configs = configs;
        this.render();
    }

    public getModelConfigs(): ModelConfig[] {
        return this.configs;
    }

    private setupEventListeners() {
        this.parent.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            const button = target.closest('button');
            if (!button) return;

            const id = button.dataset.id;
            if (button.matches('.btn-add-model')) {
                this.addEmptyConfigForm();
            } else if (button.matches('.btn-save-model')) {
                this.saveConfig(id);
            } else if (button.matches('.btn-delete-model')) {
                this.deleteConfig(id);
            } else if (button.matches('.btn-set-default')) {
                this.setDefault(id);
            }
        });
    }

    private addEmptyConfigForm() {
        const newConfig: ModelConfig = { 
            id: `new-${Date.now()}`, 
            name: '', 
            baseUrl: '', 
            apiKey: '', 
            modelId: '',
            isDefault: this.configs.length === 0 
        };
        this.configs.push(newConfig);
        this.render();
    }

    private saveAllConfigs() {
        vscode.postMessage({ command: 'saveModelConfigs', payload: this.configs });
    }

    private setDefault(id?: string) {
        if (!id) return;
        this.configs.forEach(c => c.isDefault = c.id === id);
        this.saveAllConfigs();
        this.render();
    }

    private saveConfig(id?: string) {
        if (!id) return;
        const form = this.parent.querySelector(`#config-form-${id}`) as HTMLFormElement;
        if (!form) return;

        const name = (form.querySelector('input[name="name"]') as HTMLInputElement).value;
        const baseUrl = (form.querySelector('input[name="baseUrl"]') as HTMLInputElement).value;
        const apiKey = (form.querySelector('input[name="apiKey"]') as HTMLInputElement).value;
        const modelId = (form.querySelector('input[name="modelId"]') as HTMLInputElement).value;

        const index = this.configs.findIndex(c => c.id === id);
        if (index === -1) return;

        const isNew = id.startsWith('new-');
        const newId = isNew ? `model-${Date.now()}` : id;
        
        this.configs[index] = { ...this.configs[index], id: newId, name, baseUrl, apiKey, modelId };
        
        this.saveAllConfigs();
    }

    private deleteConfig(id?: string) {
        if (!id) return;
        this.configs = this.configs.filter(c => c.id !== id);
        // If the deleted model was the default, make the first one default
        if (this.configs.length > 0 && !this.configs.some(c => c.isDefault)) {
            this.configs[0].isDefault = true;
        }
        this.saveAllConfigs();
    }

    private render() {
        this.parent.innerHTML = `
            <div class="settings-container">
                <div class="view-header">
                    <h2>Model Settings</h2>
                    <button class="btn-add-model add-btn" title="Add new model configuration">
                        <i class="codicon codicon-add"></i>
                    </button>
                </div>
                <div id="model-configs-list">
                    ${this.configs.map(config => this.renderConfigForm(config)).join('')}
                </div>
            </div>
        `;
    }

    private renderConfigForm(config: ModelConfig): string {
        return `
            <form class="config-form" id="config-form-${config.id}" data-id="${config.id}">
                <div class="form-header">
                    <strong class="form-title">${config.name || 'New Model'}</strong>
                    ${config.isDefault ? '<span class="default-badge">Default</span>' : ''}
                </div>
                <div class="form-group">
                    <label for="name-${config.id}">Model Name</label>
                    <input type="text" id="name-${config.id}" name="name" placeholder="e.g., GPT-4o" value="${config.name}">
                </div>
                <div class="form-group">
                    <label for="baseUrl-${config.id}">Base URL</label>
                    <input type="text" id="baseUrl-${config.id}" name="baseUrl" placeholder="https://api.openai.com/v1" value="${config.baseUrl}">
                </div>
                <div class="form-group">
                    <label for="apiKey-${config.id}">API Key</label>
                    <input type="password" id="apiKey-${config.id}" name="apiKey" placeholder="sk-..." value="${config.apiKey}">
                </div>
                <div class="form-group">
                    <label for="modelId-${config.id}">Model ID</label>
                    <input type="text" id="modelId-${config.id}" name="modelId" placeholder="gpt-4o" value="${config.modelId}">
                </div>
                <div class="form-actions">
                    <button type="button" class="btn-save-model" data-id="${config.id}">Save</button>
                    <button type="button" class="btn-delete-model" data-id="${config.id}">Delete</button>
                    ${!config.isDefault ? `<button type="button" class="btn-set-default" data-id="${config.id}">Set as Default</button>` : ''}
                </div>
            </form>
        `;
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/WelcomeView.ts ---
export class WelcomeView {
    constructor(private readonly parent: HTMLElement) {
        this.parent.innerHTML = this.render();
    }

    private render(): string {
        return `
            <div class="welcome-container">
                <h2>Welcome to CodeWiki</h2>
                <p>Your intelligent assistant for software design.</p>
                <button id="btn-new-chat">New Chat</button>
            </div>
        `;
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/vscode.ts ---
import type { PostMessage } from '../common/types';

/**
 * A typed wrapper around the VS Code API that is exposed to the webview.
 */
interface VsCodeApi {
    postMessage(message: PostMessage): void;
    getState(): any;
    setState(newState: any): void;
}

declare const acquireVsCodeApi: () => VsCodeApi;

export const vscode = acquireVsCodeApi();


--------------------------------------------------------------------------------
