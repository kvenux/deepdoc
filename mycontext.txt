================================================================================
项目结构 (基于过滤规则):
src
├── common
│   └── types.ts
├── extension
│   ├── agents
│   │   ├── CustomAgentExecutor.ts
│   │   └── ProjectDocumentationAgent.ts
│   ├── config
│   │   └── fileFilters.ts
│   ├── tools
│   │   ├── fileSystemTools.ts
│   │   └── llmTools.ts
│   ├── CodeWikiViewProvider.ts
│   ├── LLMService.ts
│   ├── StateManager.ts
│   ├── agentOrchestrator.ts
│   ├── agentRunner.ts
│   └── extension.ts
├── test
│   └── suite
│       └── index.ts
└── webview
    ├── components
    │   └── MessageBlock.ts
    ├── css
    │   └── main.css
    ├── views
    │   ├── App.ts
    │   ├── ChatHistoryView.ts
    │   ├── ChatView.ts
    │   ├── FocusEditorView.ts
    │   ├── PromptEditorView.ts
    │   ├── PromptManagerView.ts
    │   ├── SettingsView.ts
    │   └── WelcomeView.ts
    ├── main.ts
    └── vscode.ts
================================================================================

--- file_path: common/types.ts ---
/**
 * Defines the structure for messages posted between the Webview and the Extension Host.
 */
export interface PostMessage {
    command: string;
    payload?: any;
}

/**
 * Represents the configuration for a single language model.
 */
export interface ModelConfig {
    id: string;
    name: string;
    baseUrl: string;
    apiKey: string;
    modelId: string;
    isDefault?: boolean;
}

/**
 * Represents a single message in a conversation, from either the user or the model (assistant).
 */
export interface ChatMessage {
    role: 'user' | 'assistant';
    content: string;
    // Additional metadata can be added here, e.g., timestamps, message ID, etc.
}

/**
 * Represents a full conversation, including its ID, title, and all messages.
 */
export interface Conversation {
    id: string;
    title: string;
    messages: ChatMessage[];
    createdAt: string; // ISO 8601 date string
}

/**
 * Represents a reusable prompt template.
 */
export interface Prompt {
    id: string;
    title: string;
    content: string;
    createdAt: string; // ISO 8601 date string
    updatedAt: string; // ISO 8601 date string
}


--------------------------------------------------------------------------------

--- file_path: extension/CodeWikiViewProvider.ts ---
// src/extension/CodeWikiViewProvider.ts (完整文件)

import * as vscode from 'vscode';
import { PostMessage, Conversation, ChatMessage, Prompt } from '../common/types';
import { StateManager } from './StateManager';
import { LLMService } from './LLMService';
import { v4 as uuidv4 } from 'uuid';


// 导入 YAML 解析器
import * as yaml from 'js-yaml';
// 导入新的工具
import { GetFileSummariesTool, GetFilesContentByListTool, GetAllFilesContentTool, GetDirectoryTreeTool } from './tools/fileSystemTools';
import { createFileSelectorLLMTool } from './tools/llmTools';
// 导入我们的执行器和相关类型
import { CustomAgentExecutor, ToolChainStep, LlmPromptTemplate, AgentExecutorCallbacks } from './agents/CustomAgentExecutor';
// 导入新的 Agent Runner
import { runActionPrompt } from './agentRunner';
// 导入 LangChain 相关类
import { StructuredTool } from '@langchain/core/tools';

export class CodeWikiViewProvider implements vscode.WebviewViewProvider {

    public static readonly viewType = 'codewiki.mainView';

    private _view?: vscode.WebviewView;
    private _focusEditorView?: vscode.WebviewPanel;
    private _stateManager: StateManager;
    private _llmService: LLMService;
    private _activeConversation: Conversation | null = null;
    private _tools: StructuredTool[];

    constructor(
        private readonly _extensionUri: vscode.Uri,
        private readonly _context: vscode.ExtensionContext
    ) {
        this._stateManager = new StateManager(this._context.globalState);
        this._llmService = new LLMService();
        this._tools = []; // 初始化为空数组
        this.initializeTools();
    }

    private async initializeTools() {
        const modelConfigs = await this._stateManager.getModelConfigs();
        const defaultModelConfig = modelConfigs.find(c => c.isDefault) || modelConfigs[0];

        if (defaultModelConfig) {
            // 使用 LLMService 创建工具所需的 LLM 实例
            const toolLlm = await this._llmService.createModel({
                modelConfig: defaultModelConfig,
                temperature: 0.1,
                streaming: false,
            });

            this._tools = [
                new GetFileSummariesTool(),
                new GetFilesContentByListTool(),
                new GetAllFilesContentTool(),
                new GetDirectoryTreeTool(),
                createFileSelectorLLMTool(toolLlm, this._llmService), // 传入 llmService
            ];

        } else {
            this._tools = [
                new GetFileSummariesTool(),
                new GetFilesContentByListTool(),
                new GetAllFilesContentTool(),
                new GetDirectoryTreeTool(),
            ];
            console.warn("No default model config found. LLM-based tools will not be available.");
        }
    }

    public resolveWebviewView(
        webviewView: vscode.WebviewView,
        context: vscode.WebviewViewResolveContext,
        _token: vscode.CancellationToken,
    ) {
        this._view = webviewView;

        webviewView.webview.options = {
            // Allow scripts in the webview
            enableScripts: true,

            localResourceRoots: [
                this._extensionUri
            ]
        };

        webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

        webviewView.webview.onDidReceiveMessage((data: PostMessage) => {
            this.handleMessage(data, 'sidebar');
        });
    }

    private async handleMessage(data: PostMessage, source: 'sidebar' | 'focus-editor' = 'sidebar') {
        switch (data.command) {
            // ... 其他 case 保持不变 ...
            case 'ready':
                {
                    const sourceWebview = (source === 'focus-editor') ? this._focusEditorView?.webview : this._view?.webview;
                    if (!sourceWebview) break;

                    const conversations = await this._stateManager.getConversations();
                    const modelConfigs = await this._stateManager.getModelConfigs();
                    const prompts = await this._stateManager.getPrompts();

                    // If there are conversations, set the most recent one as active.
                    if (source === 'sidebar' && conversations.length > 0) {
                        if (!this._activeConversation) { // 避免覆盖已激活的对话
                            this._activeConversation = conversations[conversations.length - 1];
                        }
                    }

                    sourceWebview.postMessage({
                        command: 'initialize',
                        payload: {
                            conversations,
                            modelConfigs,
                            prompts
                        }
                    });
                    break;
                }
            case 'openFocusEditor':
                {
                    const { content, modelId, promptId } = data.payload;
                    if (this._focusEditorView) {
                        this._focusEditorView.reveal(vscode.ViewColumn.One);
                    } else {
                        this._focusEditorView = vscode.window.createWebviewPanel(
                            'codewiki.focusEditor',
                            'Focus Editor',
                            vscode.ViewColumn.One,
                            {
                                enableScripts: true,
                                localResourceRoots: [this._extensionUri]
                            }
                        );

                        this._focusEditorView.webview.html = this._getHtmlForWebview(this._focusEditorView.webview);

                        this._focusEditorView.onDidDispose(() => {
                            this._focusEditorView = undefined;
                            this._view?.webview.postMessage({ command: 'focusEditorClosed' });
                        }, null, this._context.subscriptions);

                        this._focusEditorView.webview.onDidReceiveMessage((msg) => this.handleMessage(msg, 'focus-editor'));
                    }

                    const modelConfigs = await this._stateManager.getModelConfigs();
                    const prompts = await this._stateManager.getPrompts();

                    // 将所有需要的数据一次性发送过去
                    this._focusEditorView.webview.postMessage({
                        command: 'showFocusEditor',
                        payload: {
                            content,
                            modelId,
                            promptId,
                            modelConfigs, // 捆绑模型数据
                            prompts       // 捆绑提示词数据
                        }
                    });
                    break;
                }
            case 'closeFocusEditor':
                {
                    this._focusEditorView?.dispose();
                    break;
                }
            case 'updateWebviewContent':
                {
                    const { content } = data.payload;
                    if (source === 'sidebar') {
                        this._focusEditorView?.webview.postMessage({ command: 'updateContent', payload: { content } });
                    } else { // source === 'focus-editor'
                        this._view?.webview.postMessage({ command: 'updateContent', payload: { content } });
                    }
                    break;
                }
            case 'syncStateChange':
                {
                    if (source === 'sidebar') {
                        this._focusEditorView?.webview.postMessage({ command: 'updateState', payload: data.payload });
                    } else { // source === 'focus-editor'
                        this._view?.webview.postMessage({ command: 'updateState', payload: data.payload });
                    }
                    break;
                }
            case 'newChat':
                {
                    this._activeConversation = null;
                    // Potentially clear the webview chat here if needed
                    break;
                }
            case 'info':
                {
                    vscode.window.showInformationMessage(data.payload);
                    break;
                }
            case 'error':
                {
                    vscode.window.showErrorMessage(data.payload);
                    break;
                }
            case 'sendMessage':
                {
                    // When a message is sent from either view, clear the input in the other.
                    if (source === 'sidebar') {
                        this._focusEditorView?.webview.postMessage({ command: 'clearInput' });
                    } else {
                        this._view?.webview.postMessage({ command: 'clearInput' });
                    }

                    const { prompt, config } = data.payload;
                    const userMessage: ChatMessage = { role: 'user', content: prompt };
                    let modelMessage: ChatMessage = { role: 'assistant', content: '' };

                    // Ensure there is an active conversation
                    if (!this._activeConversation) {
                        this._activeConversation = {
                            id: uuidv4(),
                            title: prompt.substring(0, 50), // Add title
                            messages: [],
                            createdAt: new Date().toISOString(),
                        };
                    }

                    this._activeConversation.messages.push(userMessage);

                    // Tell the webviews to enter streaming state
                    this._view?.webview.postMessage({ command: 'startStreaming' });
                    this._focusEditorView?.webview.postMessage({ command: 'startStreaming' });


                    let fullReply = '';
                    this._llmService.getCompletion(
                        this._activeConversation.messages,
                        config,
                        (chunk) => {
                            fullReply += chunk;
                            this._view?.webview.postMessage({ command: 'streamData', payload: chunk });
                            this._focusEditorView?.webview.postMessage({ command: 'streamData', payload: chunk });
                        },
                        async () => {
                            modelMessage.content = fullReply;
                            if (this._activeConversation) {
                                this._activeConversation.messages.push(modelMessage);
                                await this._stateManager.saveConversation(this._activeConversation);
                                // After saving, just update the history, don't reload the whole conversation
                                const conversations = await this._stateManager.getConversations();
                                this._view?.webview.postMessage({ command: 'updateHistory', payload: conversations });
                                this._focusEditorView?.webview.postMessage({ command: 'updateHistory', payload: conversations });
                            }
                            this._view?.webview.postMessage({ command: 'streamEnd' });
                            this._focusEditorView?.webview.postMessage({ command: 'streamEnd' });
                        },
                        (error) => {
                            const errorPayload = { error: error.message };
                            this._view?.webview.postMessage({ command: 'requestFailed', payload: errorPayload });
                            this._focusEditorView?.webview.postMessage({ command: 'requestFailed', payload: errorPayload });
                        }
                    );
                    break;
                }
            case 'stopMessage':
                {
                    this._llmService.abortRequest();
                    break;
                }
            case 'executeActionPrompt':
                {
                    const webview = this._view?.webview;
                    if (!webview) return;
                    
                    const { yamlContent, userInputs, modelConfig } = data.payload;

                    const callbacks: AgentExecutorCallbacks = {
                        onToolStart: (toolName, input) => {
                            webview.postMessage({ command: 'agentStatusUpdate', payload: { status: 'tool_start', toolName, input: JSON.stringify(input, null, 2) } });
                        },
                        onToolEnd: (toolName, output) => {
                            webview.postMessage({ command: 'agentStatusUpdate', payload: { status: 'tool_end', toolName, output } });
                        },
                        onLlmStart: () => {
                            webview.postMessage({ command: 'startStreaming' });
                        },
                        onLlmStream: (chunk) => {
                            webview.postMessage({ command: 'streamData', payload: chunk });
                        },
                        onLlmEnd: () => {
                            webview.postMessage({ command: 'streamEnd' });
                        },
                        onError: (error) => {
                            webview.postMessage({ command: 'requestFailed', payload: { error: error.message } });
                        }
                    };

                    // 调用核心函数，并传入 LLMService
                    await runActionPrompt({
                        yamlContent,
                        userInputs,
                        modelConfig,
                        tools: this._tools,
                        callbacks,
                        llmService: this._llmService
                    });
                    
                    break;
                }
            case 'regenerate':
            case 'editMessage':
                {
                    if (!this._activeConversation) break;

                    const { messageIndex, content } = data.payload;

                    // Truncate the history to the point of regeneration/edit
                    this._activeConversation.messages.splice(messageIndex);

                    if (data.command === 'editMessage') {
                        const userMessage: ChatMessage = { role: 'user', content: content };
                        this._activeConversation.messages.push(userMessage);
                    }

                    // Find the last valid model config from the conversation
                    const lastUserMessage = this._activeConversation.messages[this._activeConversation.messages.length - 1];
                    const modelConfigs = await this._stateManager.getModelConfigs();
                    const defaultConfig = modelConfigs.find(c => c.isDefault) || modelConfigs[0];

                    if (!defaultConfig) {
                        vscode.window.showErrorMessage('No model configured.');
                        break;
                    }

                    let modelMessage: ChatMessage = { role: 'assistant', content: '' };
                    let fullReply = '';

                    // Post a message to clear the old response and show a loading state
                    this._view?.webview.postMessage({ command: 'setActiveConversation', payload: this._activeConversation });
                    // Tell the webview to enter streaming state
                    this._view?.webview.postMessage({ command: 'startStreaming' });

                    this._llmService.getCompletion(
                        this._activeConversation.messages,
                        defaultConfig,
                        (chunk) => {
                            fullReply += chunk;
                            this._view?.webview.postMessage({ command: 'streamData', payload: chunk });
                        },
                        async () => {
                            modelMessage.content = fullReply;
                            if (this._activeConversation) {
                                this._activeConversation.messages.push(modelMessage);
                                await this._stateManager.saveConversation(this._activeConversation);
                                const conversations = await this._stateManager.getConversations();
                                this._view?.webview.postMessage({ command: 'updateHistory', payload: conversations });
                            }
                            this._view?.webview.postMessage({ command: 'streamEnd' });
                        },
                        (error) => {
                            this._view?.webview.postMessage({ command: 'requestFailed', payload: { error: error.message } });
                        }
                    );
                    break;
                }
            case 'loadConversation':
                {
                    const { id } = data.payload;
                    const conversations = await this._stateManager.getConversations();
                    const conversation = conversations.find(c => c.id === id);
                    if (conversation) {
                        this._activeConversation = conversation;
                        this._view?.webview.postMessage({ command: 'setActiveConversation', payload: conversation });
                    }
                    break;
                }
            case 'deleteConversation':
                {
                    const { id } = data.payload;
                    await this._stateManager.deleteConversation(id);
                    const conversations = await this._stateManager.getConversations();
                    this._view?.webview.postMessage({ command: 'updateHistory', payload: conversations });
                    break;
                }
            case 'saveModelConfigs':
                {
                    await this._stateManager.saveModelConfigs(data.payload);
                    vscode.window.showInformationMessage('Model configurations saved.');
                    this._view?.webview.postMessage({
                        command: 'updateModelConfigs',
                        payload: data.payload
                    });
                    // Re-initialize tools in case the default model changed
                    await this.initializeTools();
                    break;
                }
            //== Prompt Management ==//
            case 'newPrompt':
                {
                    this._view?.webview.postMessage({ command: 'showPromptEditor' });
                    break;
                }
            case 'editPrompt':
                {
                    const { id } = data.payload;
                    const prompts = await this._stateManager.getPrompts();
                    const prompt = prompts.find(p => p.id === id);
                    if (prompt) {
                        this._view?.webview.postMessage({ command: 'showPromptEditor', payload: { prompt } });
                    }
                    break;
                }
            case 'savePrompt':
                {
                    const prompt: Prompt = data.payload;
                    await this._stateManager.savePrompt(prompt);
                    vscode.window.showInformationMessage(`Prompt "${prompt.title}" saved.`);
                    // First, update the prompts list in the webview
                    await this._updatePrompts();
                    // Then, tell the webview to navigate back to the manager
                    this._view?.webview.postMessage({ command: 'showPromptManager' });
                    break;
                }
            case 'cancelPromptEdit':
                {
                    this._view?.webview.postMessage({ command: 'showPromptManager' });
                    break;
                }
            case 'deletePrompt':
                {
                    const { id } = data.payload;
                    // Optional: Add a confirmation dialog
                    const confirmation = await vscode.window.showWarningMessage(
                        'Are you sure you want to delete this prompt?',
                        { modal: true },
                        'Delete'
                    );
                    if (confirmation === 'Delete') {
                        await this._stateManager.deletePrompt(id);
                        await this._updatePrompts();
                        vscode.window.showInformationMessage('Prompt deleted.');
                    }
                    break;
                }
        }
    }

    private async _updatePrompts() {
        const prompts = await this._stateManager.getPrompts();
        this._view?.webview.postMessage({ command: 'updatePrompts', payload: prompts });
    }

    private _getHtmlForWebview(webview: vscode.Webview): string {
        const scriptUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'dist', 'webview.js'));
        const styleUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'src', 'webview', 'css', 'main.css'));
        const codiconsUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'node_modules', '@vscode/codicons', 'dist', 'codicon.css'));

        // Use a nonce to only allow specific scripts to be run
        const nonce = getNonce();

        return `<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta http-equiv="Content-Security-Policy" content="default-src 'none'; font-src ${webview.cspSource}; style-src ${webview.cspSource}; script-src 'nonce-${nonce}';">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                
                <link href="${codiconsUri}" rel="stylesheet" />
                <link href="${styleUri}" rel="stylesheet" />
                
                <title>CodeWiki</title>
            </head>
            <body>
                <div id="root"></div>
                <script nonce="${nonce}" type="module" src="${scriptUri}"></script>
            </body>
            </html>`;
    }
}

function getNonce() {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}

--------------------------------------------------------------------------------

--- file_path: extension/LLMService.ts ---
// src/extension/LLMService.ts

import vscode from 'vscode';
import { ChatMessage, ModelConfig } from '../common/types';
import { ChatOpenAI } from '@langchain/openai';
import { HumanMessage, AIMessage, BaseMessage } from '@langchain/core/messages';
import { BaseChatModel } from '@langchain/core/language_models/chat_models';
import { ChatGoogleGenerativeAI } from '@langchain/google-genai';

/**
 * 标志位：设置为 true 以使用 Gemini，设置为 false 则使用 settings.json 中的模型配置。
 * 使用 Gemini 前，请确保已安装 `@langchain/google-genai` 并在 `.codewiki/.env` 文件中配置了 GOOGLE_API_KEY。
 */
const USE_GEMINI = true;

/**
 * 创建模型实例时使用的选项。
 */
export interface CreateModelOptions {
    // 当不使用 Gemini 时，需要此配置来创建 OpenAI 或兼容模型
    modelConfig: ModelConfig; 
    temperature?: number;
    streaming?: boolean;
}

/**
 * 定义一个可以放入队列的LLM任务。
 * 它包含一个返回Promise的函数，以及用于解决该Promise的resolver和rejecter。
 */
type LlmTask<T> = {
    task: () => Promise<T>;
    resolve: (value: T) => void;
    reject: (reason?: any) => void;
};

/**
 * 从工作区的 .codewiki/.env 文件中安全地读取 Google API 密钥。
 * @returns {Promise<string | undefined>} 返回 API 密钥或 undefined。
 */
async function getGoogleApiKey(): Promise<string | undefined> {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) {
        return undefined;
    }
    const workspaceRoot = workspaceFolders[0].uri;
    const envPath = vscode.Uri.joinPath(workspaceRoot, '.codewiki', '.env');

    try {
        const contentBytes = await vscode.workspace.fs.readFile(envPath);
        const content = Buffer.from(contentBytes).toString('utf-8');
        const lines = content.split('\n');
        for (const line of lines) {
            const trimmedLine = line.trim();
            if (trimmedLine.startsWith('GOOGLE_API_KEY=')) {
                return trimmedLine.substring('GOOGLE_API_KEY='.length).trim();
            }
        }
    } catch (error) {
        if (!(error instanceof vscode.FileSystemError && error.code === 'FileNotFound')) {
            console.error("Error reading .codewiki/.env file:", error);
        }
    }
    return undefined;
}


/**
 * 服务类，用于与大语言模型交互。
 * 此类现在是创建模型实例的唯一入口点，整合了 OpenAI 和 Gemini 的逻辑。
 */
export class LLMService {
    private _abortController: AbortController | null = null;
    private requestQueue: LlmTask<any>[] = [];
    private isProcessingQueue = false;
    private readonly RATE_LIMIT_DELAY_MS = 1500; // 为1 QPS设置1.5秒延迟，提供安全缓冲

    constructor() {}

    /**
     * 统一的模型创建工厂方法。
     * 根据 USE_GEMINI 标志和传入的选项，创建并返回一个 LLM 实例。
     * @param options - 创建模型所需的配置，包括温度、是否流式等。
     * @returns {Promise<BaseChatModel>} 一个配置好的 LangChain 模型实例。
     */
    public async createModel(options: CreateModelOptions): Promise<BaseChatModel> {
        const { modelConfig, temperature = 0.7, streaming = false } = options;

        if (USE_GEMINI) {
            console.log("[LLMService] Creating model using Google Gemini.");
            const apiKey = await getGoogleApiKey();
            if (!apiKey) {
                throw new Error("Gemini execution failed: 'GOOGLE_API_KEY' not found in your .codewiki/.env file.");
            }
            // Gemini 对温度的支持可能与 OpenAI 不同，这里直接传入
            return new ChatGoogleGenerativeAI({
                model: "gemini-2.5-flash", 
                apiKey: apiKey,
                temperature,
                // Gemini 的 streaming 是通过 .stream() 方法控制的，这里设置 streaming 属性可能无效，但为了接口统一保留
            });
        }
        
        // 默认使用 OpenAI 或兼容的代理
        const url = new URL(modelConfig.baseUrl);
        if (!url.pathname.includes('/v1')) {
            url.pathname = ('/v1' + url.pathname).replace(/\/+/g, '/');
        }
        const finalBaseUrl = url.toString().replace(/\/$/, '');

        return new ChatOpenAI({
            modelName: modelConfig.modelId,
            apiKey: modelConfig.apiKey,
            streaming,
            temperature,
            configuration: {
                baseURL: finalBaseUrl,
            }
        });
    }

    /**
     * 将一个非流式的LLM调用任务加入队列，并由调度器按速率限制执行。
     * 这是所有Agent和Tool进行非流式调用的新入口点。
     * @param task 一个返回LLM调用Promise的函数，例如 `() => llm.invoke(messages)`
     * @returns 一个在任务完成时解析的Promise
     */
    public scheduleLlmCall<T>(task: () => Promise<T>): Promise<T> {
        console.log(`[LLMService] A new call was scheduled. Queue size: ${this.requestQueue.length + 1}`);
        return new Promise<T>((resolve, reject) => {
            this.requestQueue.push({ task, resolve, reject });
            this.processQueue();
        });
    }

    private async processQueue() {
        if (this.isProcessingQueue || this.requestQueue.length === 0) {
            return;
        }

        this.isProcessingQueue = true;
        const { task, resolve, reject } = this.requestQueue.shift()!;
        
        console.log(`[LLMService] Executing call from queue. Remaining: ${this.requestQueue.length}`);

        try {
            const result = await task();
            resolve(result);
        } catch (error) {
            console.error("[LLMService] Error executing task from queue:", error);
            reject(error);
        } finally {
            // 在完成（无论成功或失败）后，等待指定的延迟
            await new Promise(res => setTimeout(res, this.RATE_LIMIT_DELAY_MS));
            
            this.isProcessingQueue = false;
            // 尝试处理队列中的下一个项目
            this.processQueue();
        }
    }
    // highlight-end

    /**
     * 获取模型的流式补全。
     * @param messages 聊天消息历史
     * @param config 选定的模型配置
     * @param onData 接收到数据块时的回调
     * @param onEnd 完成时的回调
     * @param onError 出错时的回调
     */
    public async getCompletion(
        messages: ChatMessage[],
        config: ModelConfig,
        onData: (chunk: string) => void,
        onEnd: () => void,
        onError: (error: any) => void
    ): Promise<void> {
        this._abortController = new AbortController();
        const signal = this._abortController.signal;
        let llm: BaseChatModel;

        try {
            // 使用新的工厂方法创建模型实例
            llm = await this.createModel({
                modelConfig: config,
                streaming: true,
                temperature: 0.7 // Standard temperature for chat
            });

            const langchainMessages: BaseMessage[] = messages.map(msg => {
                return msg.role === 'user' ? new HumanMessage(msg.content) : new AIMessage(msg.content);
            });

            const stream = await llm.stream(langchainMessages, {
                signal: signal,
            });

            for await (const chunk of stream) {
                if (chunk.content) {
                    onData(chunk.content as string);
                }
            }

        } catch (error: any) {
            if (signal.aborted) {
                console.log('Request aborted by user.');
            } else {
                console.error("--- LANGCHAIN REQUEST FAILED ---");
                // 构造错误信息，因为我们不知道是哪个URL
                 if (error instanceof Error) {
                     console.error("Full Error Object:", error);
                     onError(error);
                 } else {
                     console.error("Unknown Error:", error);
                     onError(new Error(String(error)));
                 }
                console.error("--- END OF ERROR ---");
            }
        } finally {
            onEnd();
            this._abortController = null;
        }
    }

    public abortRequest() {
        if (this._abortController) {
            this._abortController.abort();
        }
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/StateManager.ts ---
import * as vscode from 'vscode';
import { Conversation, ModelConfig, Prompt } from '../common/types';

const CONVERSATIONS_KEY = 'codewiki_conversations';
const PROMPTS_KEY = 'codewiki_prompts';
const MODEL_CONFIGS_KEY = 'codewiki_model_configs';

/**
 * Manages the state of the extension, persisting data in VS Code's global state.
 * This class acts as the single source of truth for all persistent data.
 */
export class StateManager {
    constructor(private readonly globalState: vscode.Memento) {}

    //== Conversation Management ==//

    public async getConversations(): Promise<Conversation[]> {
        return this.globalState.get<Conversation[]>(CONVERSATIONS_KEY, []);
    }

    public async saveConversation(conversation: Conversation): Promise<void> {
        const conversations = await this.getConversations();
        const index = conversations.findIndex(c => c.id === conversation.id);
        if (index !== -1) {
            conversations[index] = conversation;
        } else {
            conversations.push(conversation);
        }
        await this.globalState.update(CONVERSATIONS_KEY, conversations);
    }

    public async deleteConversation(id: string): Promise<void> {
        const conversations = await this.getConversations();
        const filteredConversations = conversations.filter(c => c.id !== id);
        await this.globalState.update(CONVERSATIONS_KEY, filteredConversations);
    }

    //== Prompt Management ==//

    public async getPrompts(): Promise<Prompt[]> {
        return this.globalState.get<Prompt[]>(PROMPTS_KEY, []);
    }

    public async savePrompt(prompt: Prompt): Promise<void> {
        const prompts = await this.getPrompts();
        const index = prompts.findIndex(p => p.id === prompt.id);
        if (index !== -1) {
            prompts[index] = prompt;
        } else {
            prompts.push(prompt);
        }
        await this.globalState.update(PROMPTS_KEY, prompts);
    }

    public async deletePrompt(id: string): Promise<void> {
        const prompts = await this.getPrompts();
        const filteredPrompts = prompts.filter(p => p.id !== id);
        await this.globalState.update(PROMPTS_KEY, filteredPrompts);
    }

    //== Model Config Management ==//

   public async getModelConfigs(): Promise<ModelConfig[]> {
        // 直接从 globalState 获取配置，如果不存在，则返回一个空数组。
        return this.globalState.get<ModelConfig[]>(MODEL_CONFIGS_KEY, []);
    }

    public async saveModelConfigs(configs: ModelConfig[]): Promise<void> {
        // Ensure only one model is default
        let defaultFound = false;
        configs.forEach(config => {
            if (config.isDefault) {
                if (defaultFound) {
                    config.isDefault = false; // Unset other defaults
                } else {
                    defaultFound = true;
                }
            }
        });

        // If no default is set, make the first one default
        if (!defaultFound && configs.length > 0) {
            configs[0].isDefault = true;
        }

        await this.globalState.update(MODEL_CONFIGS_KEY, configs);
    }
}


--------------------------------------------------------------------------------

--- file_path: extension/agentOrchestrator.ts ---
// src/extension/agentOrchestrator.ts

import * as vscode from 'vscode';
import * as path from 'path';
import * as yaml from 'js-yaml';
import { get_encoding, Tiktoken } from 'tiktoken';
import { HumanMessage, SystemMessage } from '@langchain/core/messages';
import { ModelConfig } from '../common/types';
import { LLMService } from './LLMService'; // 导入 LLMService
import { BaseChatModel } from '@langchain/core/language_models/chat_models';

// 定义我们新的YAML格式
interface MapReducePrompt {
    title?: string;
    description?: string;
    input_variables: { name: string; description: string; type: string; default?: string }[];
    map_prompt_template: { system: string; human: string };
    reduce_prompt_template: { system: string; human: string };
    max_tokens_per_batch?: number;
}

// 定义一个临时数据结构来处理文件
interface FileData {
    path: string;
    content: string;
    tokenCount: number;
}

// 递归获取所有文件路径的辅助函数
async function getAllFilePaths(dirUri: vscode.Uri): Promise<vscode.Uri[]> {
    let files: vscode.Uri[] = [];
    const entries = await vscode.workspace.fs.readDirectory(dirUri);

    for (const [name, type] of entries) {
        const entryUri = vscode.Uri.joinPath(dirUri, name);
        if (type === vscode.FileType.File) {
            if (!name.startsWith('.') && !['node_modules', 'dist', 'out'].some(part => entryUri.path.includes(`/${part}/`))) {
                files.push(entryUri);
            }
        } else if (type === vscode.FileType.Directory) {
            if (!name.startsWith('.') && !['node_modules', 'dist', 'out'].includes(name)) {
                files = files.concat(await getAllFilePaths(entryUri));
            }
        }
    }
    return files;
}

// 核心执行函数
export async function runMapReduceAgent(
    yamlContent: string,
    userInputs: Record<string, string>,
    modelConfig: ModelConfig,
    outputChannel: vscode.OutputChannel,
    llmService: LLMService // 接收 LLMService 实例
): Promise<string> {
    return new Promise(async (resolve, reject) => {
        let tokenizer: Tiktoken | null = null;
        try {
            // 1. 解析和验证 YAML
            outputChannel.appendLine("[STEP 1/6] Parsing Action Prompt YAML...");
            const actionPrompt = yaml.load(yamlContent) as MapReducePrompt;
            if (!actionPrompt.map_prompt_template || !actionPrompt.reduce_prompt_template) {
                throw new Error("Invalid Map-Reduce YAML. Missing 'map_prompt_template' or 'reduce_prompt_template'.");
            }

            // 2. 收集和处理文件
            outputChannel.appendLine("\n[STEP 2/6] Gathering and tokenizing files...");
            const modulePath = userInputs['module_path'];
            if (!modulePath) {
                throw new Error("Missing required input 'module_path'.");
            }

            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders) throw new Error("No workspace folder open.");
            const workspaceRoot = workspaceFolders[0].uri;
            const absoluteModulePath = vscode.Uri.joinPath(workspaceRoot, modulePath);

            const fileUris = await getAllFilePaths(absoluteModulePath);
            tokenizer = get_encoding("cl100k_base"); // gpt-4, gpt-3.5

            const fileDataPromises = fileUris.map(async (uri): Promise<FileData> => {
                if (!tokenizer) {
                    throw new Error("Tokenizer was not initialized correctly.");
                }
                const contentBytes = await vscode.workspace.fs.readFile(uri);
                const content = Buffer.from(contentBytes).toString('utf-8');
                return {
                    path: path.relative(workspaceRoot.fsPath, uri.fsPath).replace(/\\/g, '/'),
                    content,
                    tokenCount: tokenizer.encode(content).length,
                };
            });

            const allFiles = await Promise.all(fileDataPromises);
            outputChannel.appendLine(` -> Found ${allFiles.length} files in '${modulePath}'.`);

            // 3. 文件批处理
            outputChannel.appendLine("\n[STEP 3/6] Creating file batches based on token limit...");
            const MAX_TOKENS_PER_BATCH = actionPrompt.max_tokens_per_batch || 12000;
            const batches: FileData[][] = [];
            let currentBatch: FileData[] = [];
            let currentBatchTokens = 0;

            for (const file of allFiles) {
                if (file.tokenCount > MAX_TOKENS_PER_BATCH) {
                    outputChannel.appendLine(`[WARN] Skipping file '${file.path}' as its token count (${file.tokenCount}) exceeds the batch limit.`);
                    continue;
                }
                if (currentBatchTokens + file.tokenCount > MAX_TOKENS_PER_BATCH) {
                    batches.push(currentBatch);
                    currentBatch = [];
                    currentBatchTokens = 0;
                }
                currentBatch.push(file);
                currentBatchTokens += file.tokenCount;
            }
            if (currentBatch.length > 0) {
                batches.push(currentBatch);
            }
            outputChannel.appendLine(` -> Created ${batches.length} batches.`);

            // 4. MAP 阶段：循环处理每个批次
            outputChannel.appendLine("\n[STEP 4/6] Starting MAP phase: Scheduling all batches for analysis...");

            // 使用 LLMService 创建模型实例
            outputChannel.appendLine(`[INFO] Creating LLM instances...`);
            const llm: BaseChatModel = await llmService.createModel({
                modelConfig,
                temperature: 0.1,
                streaming: false,
            });
            const reduceLlm: BaseChatModel = await llmService.createModel({
                modelConfig,
                temperature: 0.5,
                streaming: false,
            });


            const mapAnalysisPromises: Promise<string>[] = [];
            for (let i = 0; i < batches.length; i++) {
                const batch = batches[i];
                
                // 为每个批次创建一个异步处理函数
                const processBatch = async (): Promise<string> => {
                    outputChannel.appendLine(` -> [MAP] Starting analysis for Batch ${i + 1} of ${batches.length} (${batch.length} files)...`);

                    const batchContent = batch
                        .map(file => `--- START OF FILE: ${file.path} ---\n${file.content}\n--- END OF FILE ---`)
                        .join('\n\n');

                    const humanPrompt = actionPrompt.map_prompt_template.human.replace('{code_files_collection}', batchContent);
                    const mapMessages = [
                        new SystemMessage(actionPrompt.map_prompt_template.system),
                        new HumanMessage(humanPrompt),
                    ];

                    const response = await llmService.scheduleLlmCall(() => llm.invoke(mapMessages));
                    outputChannel.appendLine(` -> [MAP] Finished analysis for Batch ${i + 1}.`);
                    return response.content as string;
                };

                // 启动任务并将其Promise添加到数组中
                mapAnalysisPromises.push(processBatch());
                
            }

            outputChannel.appendLine(" -> [MAP] All batch analysis requests sent. Waiting for all to complete...");
            const mapResults = await Promise.all(mapAnalysisPromises);
            const combinedMarkdownSummaries = mapResults.join("\n\n");
            outputChannel.appendLine(" -> [MAP] All batches analyzed successfully.");


            // 5. REDUCE 阶段：合成最终文档
            outputChannel.appendLine("\n[STEP 5/6] Starting REDUCE phase: Synthesizing final document...");

            // 注入变量到 Template
            let humanReducePrompt = actionPrompt.reduce_prompt_template.human;
            for (const key in userInputs) {
                humanReducePrompt = humanReducePrompt.replace(new RegExp(`\\{${key}\\}`, 'g'), userInputs[key]);
            }
            humanReducePrompt = humanReducePrompt.replace('{combined_markdown_summaries}', combinedMarkdownSummaries);

            const reduceMessages = [
                new SystemMessage(actionPrompt.reduce_prompt_template.system),
                new HumanMessage(humanReducePrompt),
            ];

            outputChannel.appendLine("\n--- [FINAL DOCUMENT] ---");
            outputChannel.appendLine("\n--- NOT Steamming ---");

            const finalResponse = await llmService.scheduleLlmCall(() => reduceLlm.invoke(reduceMessages));
            const fullResponse = finalResponse.content as string;

            outputChannel.appendLine("\n--- [END OF DOCUMENT] ---");

            // 6. 保存结果
            outputChannel.appendLine("\n[STEP 6/6] Saving result to output file...");
            const outputDir = vscode.Uri.joinPath(workspaceRoot, '.codewiki', 'output');
            await vscode.workspace.fs.createDirectory(outputDir);

            const promptTitle = actionPrompt.title?.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'map_reduce_agent';
            const outputFileName = `${promptTitle}-result-${Date.now()}.md`;
            const outputFilePath = vscode.Uri.joinPath(outputDir, outputFileName);

            let res = combinedMarkdownSummaries;
            res += "=================================="
            res += fullResponse
            await vscode.workspace.fs.writeFile(outputFilePath, Buffer.from(res, 'utf8'));
            outputChannel.appendLine(`\n[SUCCESS] Agent run finished. Result saved to: ${outputFilePath.fsPath}`);
            vscode.window.showInformationMessage(`Agent run successful. Output saved to .codewiki/output/`);
            resolve(fullResponse);

        } catch (error: any) {
            const finalError = `[FATAL] Agent execution failed: ${error.message}\n${error.stack}`;
            outputChannel.appendLine(`\n--- [ERROR] ---\n${finalError}`);
            vscode.window.showErrorMessage(error.message);
        } finally {
            tokenizer?.free(); // 释放 wasm 内存
        }
    });
}

--------------------------------------------------------------------------------

--- file_path: extension/agentRunner.ts ---
// src/extension/agentRunner.ts

import * as yaml from 'js-yaml';
import { StructuredTool } from '@langchain/core/tools';
import { CustomAgentExecutor, ToolChainStep, LlmPromptTemplate, AgentExecutorCallbacks } from './agents/CustomAgentExecutor';
import { ModelConfig } from '../common/types';
import { LLMService } from './LLMService';

interface RunActionPromptOptions {
    yamlContent: string;
    userInputs: Record<string, string>;
    modelConfig: ModelConfig;
    tools: StructuredTool[];
    callbacks: AgentExecutorCallbacks;
    llmService: LLMService; // 新增：传入 LLMService 实例
}

/**
 * 负责执行一个 Action Prompt 的核心逻辑。
 * 此函数被设计为可重用的，可以被 VS Code 命令或 Webview 消息处理器调用。
 * @param options - 包含执行所需所有参数的对象。
 */
export async function runActionPrompt(options: RunActionPromptOptions): Promise<string> {
    return new Promise(async (resolve, reject) => {
        const { yamlContent, userInputs, modelConfig, tools, callbacks, llmService } = options;
        
        try {
            const actionPrompt = yaml.load(yamlContent) as {
                tool_chain: ToolChainStep[];
                llm_prompt_template: LlmPromptTemplate;
            };

            if (!actionPrompt.tool_chain || !actionPrompt.llm_prompt_template) {
                throw new Error("Invalid Action Prompt YAML format. Missing 'tool_chain' or 'llm_prompt_template'.");
            }

            // 使用 LLMService 创建最终的 LLM 实例
            const finalLlm = await llmService.createModel({
                modelConfig,
                streaming: true,
                temperature: 0.7,
            });

            // 增强 callbacks 以支持 Promise 解析
            const enhancedCallbacks: AgentExecutorCallbacks = {
                ...callbacks,
                onLlmEnd: (result) => {
                    callbacks.onLlmEnd?.(result);
                    resolve(result); // 当LLM结束时，用最终结果解析Promise
                },
                onError: (err) => {
                    callbacks.onError?.(err);
                    reject(err); // 当出错时，拒绝Promise
                }
            };

            const agentExecutor = new CustomAgentExecutor(tools, finalLlm);

            // 启动 Agent Executor，但不再需要 await 它，因为 Promise 会处理完成状态
            agentExecutor.run(
                actionPrompt.tool_chain,
                userInputs,
                actionPrompt.llm_prompt_template,
                enhancedCallbacks
            );

        } catch (error: any) {
            const err = error instanceof Error ? error : new Error(String(error));
            callbacks.onError?.(err);
            reject(err); // 捕获同步错误
        }
    });
}

--------------------------------------------------------------------------------

--- file_path: extension/agents/CustomAgentExecutor.ts ---
// src/extension/agents/CustomAgentExecutor.ts (完整文件)

import { BaseLanguageModel } from '@langchain/core/language_models/base';
import { StructuredTool } from '@langchain/core/tools';
import { ChatPromptTemplate } from '@langchain/core/prompts';
import { AIMessage, BaseMessage, HumanMessage, SystemMessage } from '@langchain/core/messages';
import { StringOutputParser } from '@langchain/core/output_parsers';

// ... (接口定义保持不变) ...
export interface ToolChainStep {
    tool: string;
    input: string | Record<string, any>;
    output_variable: string;
}
export interface LlmPromptTemplate {
    system: string;
    human: string;
}
export interface AgentExecutorCallbacks {
    onToolStart?: (toolName: string, input: any) => void;
    onToolEnd?: (toolName:string, output: string) => void;
    onLlmStart?: (finalSystemPrompt: string, finalHumanPrompt: string) => void; // 我们可以给 onLlmStart 添加参数
    onLlmStream?: (chunk: string) => void;
    onLlmEnd?: (finalResult: string) => void; // 增加 finalResult 参数
    onError?: (error: Error) => void;
}


export class CustomAgentExecutor {
    private tools: Map<string, StructuredTool>;
    private finalLlm: BaseLanguageModel;

    constructor(tools: StructuredTool[], finalLlm: BaseLanguageModel) {
        this.tools = new Map(tools.map(tool => [tool.name, tool]));
        this.finalLlm = finalLlm;
    }

    public async run(
        tool_chain: ToolChainStep[],
        initialInputs: Record<string, string>,
        llm_prompt_template: LlmPromptTemplate,
        callbacks: AgentExecutorCallbacks
    ): Promise<void> {
        const context: Record<string, any> = { ...initialInputs };
        
        // --- 日志: 打印初始上下文 ---
        console.log("--- [Agent Start] ---");
        console.log("Initial Context:", JSON.stringify(context, null, 2));
        console.log("----------------------");

        try {
            for (const step of tool_chain) {
                const tool = this.tools.get(step.tool);
                if (!tool) {
                    throw new Error(`Tool "${step.tool}" not found.`);
                }
                
                // --- 日志: 打印将要执行的工具和它的输入模板 ---
                console.log(`\n--- [Tool Start] Executing: ${step.tool} ---`);
                console.log("Input Template:", JSON.stringify(step.input, null, 2));

                const toolInput = this.resolveInput(step.input, context);

                // --- 日志: 打印解析后的、实际传递给工具的输入 ---
                console.log("Resolved Input:", JSON.stringify(toolInput, null, 2));
                
                callbacks.onToolStart?.(tool.name, toolInput);

                const toolOutputString = await tool.call(toolInput);
                
                const toolOutputParsed = this.parseToolOutput(toolOutputString);
                context[step.output_variable] = toolOutputParsed;

                // --- 日志: 打印工具的原始输出和解析后的输出 ---
                const outputSummary = toolOutputString.length > 500 ? `${toolOutputString.substring(0, 500)}...` : toolOutputString;
                console.log("Tool Raw Output (truncated):", outputSummary);
                if (typeof toolOutputParsed !== 'string') {
                    console.log(`Parsed Output (variable "${step.output_variable}"):`, toolOutputParsed);
                }
                console.log(`--- [Tool End] Finished: ${step.tool} ---\n`);

                callbacks.onToolEnd?.(tool.name, outputSummary);
            }
            
            // --- 日志: 打印工具链执行完毕后的最终上下文 ---
            console.log("--- [Final LLM Start] ---");
            // 注意：不直接打印整个 context，因为 selected_files_content 可能非常大
            const contextKeys = Object.keys(context);
            console.log("Final Context Keys:", contextKeys);
            if(context.selected_files_list) {
                console.log("Final Context 'selected_files_list':", context.selected_files_list);
            }
            console.log("LLM Prompt Template:", llm_prompt_template);
            
            // highlight-start
            // ======== 准备并打印最终的 Prompt ========
            const systemMessageContent = this.resolveInput(llm_prompt_template.system, context) as string;
            const humanMessageContent = this.resolveInput(llm_prompt_template.human, context) as string;
            
            // 打印到调试控制台
            const finalHumanPromptSummary = humanMessageContent.length > 1000 ? `${humanMessageContent.substring(0, 1000)}... (truncated)` : humanMessageContent;
            console.log("--- Final Prompt to LLM ---");
            console.log("[SYSTEM]\n", systemMessageContent);
            console.log("\n[HUMAN] (truncated)\n", finalHumanPromptSummary);
            console.log("----------------------------");

            // 通过回调函数将最终 Prompt 发送到 OutputChannel
            // (这里的 onLlmStart 现在接收两个参数)
            callbacks.onLlmStart?.(systemMessageContent, humanMessageContent);
            // ======== 结束打印 ========
            // highlight-end

            const finalPrompt = ChatPromptTemplate.fromMessages([
                new SystemMessage(systemMessageContent),
                new HumanMessage(humanMessageContent)
            ]);

            const finalChain = finalPrompt.pipe(this.finalLlm).pipe(new StringOutputParser());

            const stream = await finalChain.stream({});
            let fullReply = '';
            for await (const chunk of stream) {
                fullReply += chunk;
                callbacks.onLlmStream?.(chunk);
            }
            callbacks.onLlmEnd?.(fullReply); // 传递完整结果


        } catch (error: any) {
            console.error("Error in CustomAgentExecutor:", error);
            callbacks.onError?.(error instanceof Error ? error : new Error(String(error)));
        }
    }

    /**
     * 解析工具的输入，用上下文中的值替换 {placeholder}。
     * @param inputTemplate - 来自 tool_chain 的输入定义。
     * @param context - 当前的执行上下文。
     * @returns 解析后的输入，准备传递给工具。
     */
    private resolveInput(inputTemplate: string | Record<string, any>, context: Record<string, any>): any {
        if (typeof inputTemplate === 'string') {
            const match = inputTemplate.match(/^\{(\w+)\}$/);
            // 关键修正: 检查占位符是否是模板字符串的唯一内容
            // 如果是，并且上下文中的值不是字符串，则直接返回该值（如数组）
            if (match && context[match[1]] !== undefined) {
                return context[match[1]];
            }
            
            // 否则，执行常规的字符串替换 (所有值都会被转为字符串)
            return inputTemplate.replace(/\{(\w+)\}/g, (m, key) => {
                return context[key] !== undefined ? String(context[key]) : m;
            });
        }
        
        // 递归处理对象
        const resolvedObject: Record<string, any> = {};
        for (const key in inputTemplate) {
            const value = inputTemplate[key];
            resolvedObject[key] = this.resolveInput(value, context);
        }
        return resolvedObject;
    }

    private parseToolOutput(outputString: string): any {
        try {
            if ((outputString.startsWith('[') && outputString.endsWith(']')) || (outputString.startsWith('{') && outputString.endsWith('}'))) {
                return JSON.parse(outputString);
            }
        } catch (e) {
            // 解析失败，不是有效的JSON，返回原始字符串
        }
        return outputString;
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/agents/ProjectDocumentationAgent.ts ---
// src/extension/agents/ProjectDocumentationAgent.ts

import * as vscode from 'vscode';
import * as path from 'path';
import * as yaml from 'js-yaml';
import { ModelConfig } from '../../common/types';
import { BaseMessage, HumanMessage } from '@langchain/core/messages';
import { get_encoding, Tiktoken } from 'tiktoken';
import { GetDirectoryTreeTool, GetAllFilesContentTool } from '../tools/fileSystemTools';
import { runMapReduceAgent } from '../agentOrchestrator';
import { runActionPrompt } from '../agentRunner';
import { createFileSelectorLLMTool } from '../tools/llmTools';
import { StructuredTool } from '@langchain/core/tools';
import { AgentExecutorCallbacks } from './CustomAgentExecutor';
import { LLMService } from '../LLMService'; // 导入 LLMService
import { BaseChatModel } from '@langchain/core/language_models/chat_models';

// 定义规划阶段的输出结构
interface PlannerOutput {
    projectName: string;
    language: string; // e.g., 'typescript'
    modules: { name: string; path: string; description: string; }[];
}

// 用于加载和解析外部YAML文件的辅助函数
async function loadPromptFile(workspaceRoot: vscode.Uri, fileName: string): Promise<string> {
    const promptUri = vscode.Uri.joinPath(workspaceRoot, '.codewiki', fileName);
    try {
        const fileContent = await vscode.workspace.fs.readFile(promptUri);
        return Buffer.from(fileContent).toString('utf-8');
    } catch (e) {
        throw new Error(`无法加载提示词文件: ${fileName}。请确保它存在于 '.codewiki' 目录中。`);
    }
}


export class ProjectDocumentationAgent {
    private outputChannel: vscode.OutputChannel;
    private modelConfig: ModelConfig;
    private llmService: LLMService; // 使用 LLMService
    private tokenizer: Tiktoken;
    private readonly MAX_TOKENS_FOR_DIRECT_ANALYSIS = 32000;
    private tools: StructuredTool[] = [];

    constructor(outputChannel: vscode.OutputChannel, modelConfig: ModelConfig, llmService: LLMService) {
        this.outputChannel = outputChannel;
        this.modelConfig = modelConfig;
        this.llmService = llmService; // 存储 LLMService 实例
        this.tokenizer = get_encoding("cl100k_base");
    }

    private async initialize() {
        // 如果工具已初始化，则跳过
        if (this.tools.length > 0) return;

        // 异步创建用于工具的 LLM
        const toolLlm = await this.llmService.createModel({
            modelConfig: this.modelConfig,
            temperature: 0.1,
            streaming: false
        });
        
        this.tools = [
            new GetDirectoryTreeTool(),
            new GetAllFilesContentTool(),
            createFileSelectorLLMTool(toolLlm, this.llmService)
        ];
    }

    private log(message: string) {
        this.outputChannel.appendLine(message);
    }
    
    private async invokeLlmAndLog(
        messages: BaseMessage[], 
        logFileBaseName: string, 
        runDirUri: vscode.Uri,
        temperature: number = 0.1 // 允许指定温度
    ): Promise<string> {
        const requestContent = messages.map(m => `[${m._getType()}]\n${m.content}`).join('\n\n---\n\n');
        const requestPath = vscode.Uri.joinPath(runDirUri, `${logFileBaseName}_request.txt`);
        await vscode.workspace.fs.writeFile(requestPath, Buffer.from(requestContent, 'utf8'));

        // 使用 LLMService 创建一个具有特定配置的、非流式的 LLM
        const nonStreamingLlm = await this.llmService.createModel({
            modelConfig: this.modelConfig,
            streaming: false,
            temperature,
        });

        const response = await this.llmService.scheduleLlmCall(() => nonStreamingLlm.invoke(messages));
        const responseContent = response.content.toString();

        const responsePath = vscode.Uri.joinPath(runDirUri, `${logFileBaseName}_response.txt`);
        await vscode.workspace.fs.writeFile(responsePath, Buffer.from(responseContent, 'utf8'));
        
        return responseContent;
    }
    
    public async run() {
        this.log("--- [启动] 项目文档生成智能体 ---");
        const workspaceRoot = vscode.workspace.workspaceFolders?.[0].uri;
        if (!workspaceRoot) {
            throw new Error("请先打开一个工作区文件夹。");
        }
        
        // 在运行开始时进行异步初始化
        await this.initialize();

        const runId = `doc-gen_${this.modelConfig.modelId.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().replace(/[:.]/g, '-')}`;
        const runDir = vscode.Uri.joinPath(workspaceRoot, '.codewiki', 'runs', runId);
        await vscode.workspace.fs.createDirectory(runDir);
        this.log(`[信息] 本次运行的结果将保存在: ${runDir.fsPath}`);

        try {
            this.log("\n--- [阶段 0/4] 加载外部提示词... ---");
            const plannerPromptContent = await loadPromptFile(workspaceRoot, 'project_planner.yml');
            const plannerPromptTemplate = (yaml.load(plannerPromptContent) as any).llm_prompt_template.human;
            this.log("[成功] 已加载规划器提示词。");

            this.log("\n--- [阶段 1/4] 规划: 分析项目结构... ---");
            const plan = await this.runPlanningPhase(workspaceRoot, runDir, plannerPromptTemplate);
            const planPath = vscode.Uri.joinPath(runDir, 'plan.json');
            await vscode.workspace.fs.writeFile(planPath, Buffer.from(JSON.stringify(plan, null, 2), 'utf8'));
            this.log(`[成功] 规划完成。规划文件已保存至 plan.json。`);

            this.log("\n--- [阶段 2/4] 执行: 并行分析独立模块 (带延迟)... ---");
            const moduleAnalysisPromises: Promise<{ name: string; path: string; content: string; }>[] = [];

            for (const [index, module] of plan.modules.entries()) {
                const analyzeSingleModule = async (): Promise<{ name: string; path: string; content: string; }> => {
                    this.log(`\n[模块 ${index + 1}/${plan.modules.length}] 开始分析 '${module.name}' (路径: '${module.path}')...`);
                    const moduleDocContent = await this.analyzeModule(workspaceRoot, module, plan.language, runDir);
                    
                    const moduleDocPath = vscode.Uri.joinPath(runDir, `module_${module.name.replace(/[\s\/]/g, '_')}.md`);
                    await vscode.workspace.fs.writeFile(moduleDocPath, Buffer.from(moduleDocContent, 'utf8'));

                    this.log(`[成功] 模块 '${module.name}' 分析完成，文档已保存。`);
                    return { ...module, content: moduleDocContent };
                };
                moduleAnalysisPromises.push(analyzeSingleModule());
            }

            this.log(`\n[信息] 所有 ${plan.modules.length} 个模块的分析任务已提交到队列，正在等待全部完成...`);
            const moduleDocs = await Promise.all(moduleAnalysisPromises);
            this.log(`\n[成功] 所有模块均已分析完毕。`);

            this.log("\n--- [阶段 3/4] 综合: 生成最终文档... ---");
            const synthesisPromptContent = await loadPromptFile(workspaceRoot, 'project_synthesis.yml');
            const synthesisPromptTemplate = (yaml.load(synthesisPromptContent) as any).llm_prompt_template.human;
            
            const finalDoc = await this.runSynthesisPhase(plan, moduleDocs, runDir, synthesisPromptTemplate);
            const finalDocPath = vscode.Uri.joinPath(runDir, '项目总体设计文档.md');
            await vscode.workspace.fs.writeFile(finalDocPath, Buffer.from(finalDoc, 'utf8'));
            
            this.log(`\n--- [完成] ---`);
            this.log(`项目文档已成功生成！`);
            vscode.window.showInformationMessage(`文档已保存至: ${finalDocPath.fsPath}`, '打开文件').then(selection => {
                if (selection === '打开文件') {
                    vscode.window.showTextDocument(finalDocPath);
                }
            });

        } catch (error: any) {
            const errorMessage = `[致命错误] 智能体执行失败: ${error.message}\n${error.stack}`;
            this.log(errorMessage);
            vscode.window.showErrorMessage(error.message);
        } finally {
             this.tokenizer.free();
        }
    }

    private async runPlanningPhase(workspaceRoot: vscode.Uri, runDir: vscode.Uri, promptTemplate: string): Promise<PlannerOutput> {
        const treeTool = new GetDirectoryTreeTool();
        this.log("[规划] 正在生成文件树...");
        const fileTree = await treeTool.call({ path: '.', language: 'unknown' });
        
        this.log("[规划] 正在调用大模型进行规划...");
        const prompt = promptTemplate.replace('{file_tree}', fileTree);
        const messages: BaseMessage[] = [new HumanMessage(prompt)];
        
        // 使用默认温度 (0.1)
        const responseContent = await this.invokeLlmAndLog(messages, "01_planning", runDir);
        
        try {
            const jsonString = responseContent.match(/\{[\s\S]*\}/)?.[0];
            if (!jsonString) throw new Error("大模型未能返回有效的JSON规划。");
            return JSON.parse(jsonString) as PlannerOutput;
        } catch (e: any) {
            throw new Error(`解析规划输出失败: ${e.message}。原始输出: ${responseContent}`);
        }
    }

    private async analyzeModule(
        workspaceRoot: vscode.Uri,
        module: { name: string; path: string },
        language: string,
        runDir: vscode.Uri
    ): Promise<string> {
        const moduleRunDir = vscode.Uri.joinPath(runDir, `module_analysis_${module.path.replace(/[\/\\]/g, '_')}`);
        await vscode.workspace.fs.createDirectory(moduleRunDir);

        const contentTool = new GetAllFilesContentTool();
        const allContent = await contentTool.call({ path: module.path, language });
        const tokenCount = this.tokenizer.encode(allContent).length;
        this.log(` -> 模块 '${module.name}' Token总数: ${tokenCount}`);
        
        let finalResult = '';
        const callbacks: AgentExecutorCallbacks = {
            onToolStart: (toolName, input) => this.log(`   [TOOL START] ${toolName}: ${JSON.stringify(input)}`),
            onToolEnd: (toolName, output) => {
                const summary = output.length > 300 ? `${output.substring(0, 300)}...` : output;
            },
            onLlmStart: (system, human) => {
                this.log(`   [LLM START]`);
                const requestContent = `[SYSTEM]\n${system}\n\n---\n\n[HUMAN]\n${human}`;
                const requestPath = vscode.Uri.joinPath(moduleRunDir, `llm_request.txt`);
                vscode.workspace.fs.writeFile(requestPath, Buffer.from(requestContent, 'utf8'));
            },
            onLlmStream: (chunk) => { /* 不在主channel刷屏 */ },
            onLlmEnd: (result) => {
                this.log(`   [LLM END]`);
                const responsePath = vscode.Uri.joinPath(moduleRunDir, `llm_response.md`);
                vscode.workspace.fs.writeFile(responsePath, Buffer.from(result, 'utf8'));
            },
            onError: (error) => {
                this.log(`   [错误] 子流程执行失败: ${error.message}`);
                finalResult = `模块分析失败: ${error.message}`;
            }
        };

        if (tokenCount <= this.MAX_TOKENS_FOR_DIRECT_ANALYSIS) {
            this.log(` -> Token数在限制内，使用直接分析流程 (runActionPrompt)...`);
            const yamlContent = await loadPromptFile(workspaceRoot, 'module_analysis_direct.yml');
            finalResult = await runActionPrompt({
                yamlContent,
                userInputs: { module_path: module.path, language },
                modelConfig: this.modelConfig,
                tools: this.tools,
                callbacks,
                llmService: this.llmService // 传入 LLMService
            });
        } else {
            this.log(` -> Token数超出限制，使用Map-Reduce流程 (runMapReduceAgent)...`);
            const yamlContent = await loadPromptFile(workspaceRoot, 'module_analysis_mapreduce.yml');
            const mapReduceChannel: vscode.OutputChannel = {
                ...this.outputChannel,
                append: (value: string) => this.log(`   [MR] ${value}`),
                appendLine: (value: string) => this.log(`   [MR] ${value}`),
                clear: () => {},
                replace: (value: string) => this.log(`   [MR] ${value}`),
                name: "MapReduce-Proxy"
            };
            
            finalResult = await runMapReduceAgent(
                yamlContent, 
                { module_path: module.path, language }, 
                this.modelConfig, 
                mapReduceChannel,
                this.llmService // 传入 LLMService
            );
        }

        return finalResult;
    }

    private async runSynthesisPhase(plan: PlannerOutput, moduleDocs: { name: string; content: string; }[], runDir: vscode.Uri, promptTemplate: string): Promise<string> {
        const moduleOverviews = plan.modules.map(m => `- **${m.name} (${m.path})**: ${m.description}`).join('\n');
        const detailedModuleDocs = moduleDocs.map((doc, index) => `
### 3.3.${index + 1} ${doc.name} 模块详细设计
${doc.content}
`).join('\n---\n');

        const prompt = promptTemplate
            .replace('{projectName}', plan.projectName)
            .replace('{language}', plan.language)
            .replace('{module_overviews}', moduleOverviews)
            .replace('{detailed_module_docs}', detailedModuleDocs);

        this.log("[综合] 正在调用大模型生成最终文档...");
        const messages: BaseMessage[] = [new HumanMessage(prompt)];

        // 使用稍高的温度进行综合
        return await this.invokeLlmAndLog(messages, "03_synthesis", runDir, 0.4);
    }
}

--------------------------------------------------------------------------------

--- file_path: extension/config/fileFilters.ts ---
// src/extension/config/fileFilters.ts

/**
 * Defines a language's file filtering rules.
 */
export interface LanguageFilter {
    // Included file extensions
    include: string[];
    // Specific files or patterns to explicitly exclude
    exclude: string[];
}

/**
 * Generic exclusion list, applicable to all languages and projects.
 */
export const GENERIC_EXCLUDE = [
    'node_modules',
    'dist',
    'out',
    'build',
    'target', // Common for Java (Maven/Gradle)
    'bin',
    'vendor',
    '.git',
    '.svn',
    '.hg',
    '__pycache__',
    '.vscode',
    '.idea',
    'package-lock.json',
    'yarn.lock',
    'pnpm-lock.yaml',
    'go.sum',
    '.DS_Store'
];

/**
 * Language-specific filtering rules.
 */
export const languageFilters: Record<string, LanguageFilter> = {
    typescript: {
        include: ['.ts', '.tsx'],
        exclude: ['.d.ts', '.spec.ts', '.test.ts'],
    },
    javascript: {
        include: ['.js', '.jsx'],
        exclude: ['.spec.js', '.test.js'],
    },
    python: {
        include: ['.py'],
        exclude: [],
    },
    go: {
        include: ['.go'],
        exclude: ['_test.go'],
    },
    // highlight-start
    java: {
        include: ['.java'],
        // Java testing is typically directory-based (src/test/java),
        // which is handled by module selection rather than file-level filtering.
        exclude: [], 
    },
    c: {
        // Headers (.h) are crucial for understanding interfaces and must be included.
        include: ['.c', '.h'],
        exclude: [],
    },
    cpp: { // Using 'cpp' as the key for C++
        // C++ has various extensions for source and header files.
        // Including the most common ones. Headers are critical.
        include: ['.cpp', '.hpp', '.cc', '.cxx', '.h'],
        exclude: [],
    },
    // highlight-end
    unknown: { // Default rule when language isn't identified
        include: [
            '.ts', '.tsx', '.js', '.jsx', '.py', '.go', 
            // highlight-start
            '.java', '.c', '.h', '.cpp', '.hpp', '.cc', '.cxx', 
            // highlight-end
            '.cs', '.rb', '.php', '.rs'
        ],
        exclude: ['.spec.ts', '.test.ts', '.spec.js', '.test.js', '_test.go'],
    }
};

--------------------------------------------------------------------------------

--- file_path: extension/extension.ts ---
// src/extension/extension.ts (完整文件)

import * as vscode from 'vscode';
import * as path from 'path';
import * as yaml from 'js-yaml';
import { CodeWikiViewProvider } from './CodeWikiViewProvider';
import { StateManager } from './StateManager';
import { runMapReduceAgent } from './agentOrchestrator';
import { ProjectDocumentationAgent } from './agents/ProjectDocumentationAgent';
import { LLMService } from './LLMService';


export function activate(context: vscode.ExtensionContext) {
    const provider = new CodeWikiViewProvider(context.extensionUri, context);

    context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(CodeWikiViewProvider.viewType, provider)
    );

    // =========================================================================
    // == 注册一个灵活的、可交互的 Agent 运行命令
    // =========================================================================
    const runAgentDisposable = vscode.commands.registerCommand('codewiki.runAgent', async () => {
        const outputChannel = vscode.window.createOutputChannel("CodeWiki Agent Run");
        outputChannel.show(true);
        outputChannel.clear();
        outputChannel.appendLine("--- [START] CodeWiki Agent Runner ---\n");

        try {
            // 1. 获取工作区和 .codewiki 目录
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders || workspaceFolders.length === 0) {
                throw new Error("No workspace folder is open. Please open a project to run an agent.");
            }
            const workspaceRoot = workspaceFolders[0].uri;
            const codewikiDir = vscode.Uri.joinPath(workspaceRoot, '.codewiki');

            // 2. 扫描 .codewiki 目录下的所有 .yml 或 .yaml 文件
            let promptFiles: [string, vscode.FileType][] = [];
            try {
                promptFiles = await vscode.workspace.fs.readDirectory(codewikiDir);
            } catch (e) {
                throw new Error("The '.codewiki' directory was not found in your workspace root. Please create it and add your Action Prompt YAML files there.");
            }

            const ymlFiles = promptFiles
                .filter(([name, type]) => type === vscode.FileType.File && (name.endsWith('.yml') || name.endsWith('.yaml')))
                .map(([name, type]) => name);

            if (ymlFiles.length === 0) {
                throw new Error("No YAML (.yml, .yaml) prompt files found in the '.codewiki' directory.");
            }

            // 3. 使用 Quick Pick 让用户选择一个 Prompt
            const selectedFileName = await vscode.window.showQuickPick(ymlFiles, {
                placeHolder: 'Select an Action Prompt to run',
                title: 'CodeWiki Agent Runner'
            });

            if (!selectedFileName) {
                outputChannel.appendLine("[INFO] User cancelled the operation. Exiting.");
                return; // 用户取消选择
            }
            outputChannel.appendLine(`[INFO] User selected prompt: ${selectedFileName}`);

            // 4. 读取并解析选中的 YAML 文件
            const promptUri = vscode.Uri.joinPath(codewikiDir, selectedFileName);
            const fileContent = await vscode.workspace.fs.readFile(promptUri);
            const yamlContent = Buffer.from(fileContent).toString('utf-8');
            // 初步解析以获取元数据和判断类型
            const actionPrompt = yaml.load(yamlContent) as any;
            outputChannel.appendLine(`[INFO] Successfully loaded and parsed: ${actionPrompt.title || selectedFileName}`);
            
            // 5. 动态获取用户输入
            const userInputs: Record<string, string> = {};
            if (actionPrompt.input_variables && Array.isArray(actionPrompt.input_variables)) {
                outputChannel.appendLine(`[INFO] Requesting user inputs...`);
                for (const variable of actionPrompt.input_variables) {
                    const value = await vscode.window.showInputBox({
                        prompt: `Enter value for '${variable.name}'`,
                        placeHolder: variable.description,
                        value: variable.default || '',
                        title: `Input for: ${actionPrompt.title || selectedFileName}`
                    });

                    if (value === undefined) {
                        outputChannel.appendLine("[INFO] User cancelled input. Exiting.");
                        return; // 用户取消输入
                    }
                    userInputs[variable.name] = value;
                    outputChannel.appendLine(`  - Input '${variable.name}': ${value}`);
                }
            } else {
                outputChannel.appendLine(`[INFO] No 'input_variables' defined in the prompt. Proceeding without user input.`);
            }

            outputChannel.appendLine(`\n--- Starting Agent Execution ---`);
            
            // 6. 获取模型配置并创建 LLMService 实例
            const stateManager = new StateManager(context.globalState);
            const modelConfigs = await stateManager.getModelConfigs();
            const defaultConfig = modelConfigs.find(c => c.isDefault) || modelConfigs[0];
            if (!defaultConfig) { throw new Error("No default model config found."); }
            
            const llmService = new LLMService(); // 创建服务实例

            // =========================================================================
            // == 核心修改：根据YAML内容选择不同的执行器
            // =========================================================================
            if (actionPrompt.map_prompt_template && actionPrompt.reduce_prompt_template) {
                // 这是新的 Map-Reduce Agent
                outputChannel.appendLine("[INFO] Detected Map-Reduce Agent type. Starting orchestrator...");
                await runMapReduceAgent(yamlContent, userInputs, defaultConfig, outputChannel, llmService);

            } else if (actionPrompt.tool_chain && actionPrompt.llm_prompt_template) {
                // 这是旧的 Tool-Chain Agent
                outputChannel.appendLine("[ERROR] Detected Tool-Chain Agent type.");
                // 旧的 runActionPrompt 逻辑应该在这里被调用，但我们在此示例中将其标记为未实现
                // 以便专注于新的 Map-Reduce 流程。
                // await runActionPrompt({ yamlContent, userInputs, modelConfig: defaultConfig, tools, callbacks, llmService });
                throw new Error("Standard Tool-Chain agent runner is not connected in this version. Please use a Map-Reduce prompt YAML file or trigger it from the webview.");
            } else {
                throw new Error("Unknown or invalid Action Prompt YAML format. It must contain either ('map_prompt_template' and 'reduce_prompt_template') or ('tool_chain' and 'llm_prompt_template').");
            }

        } catch (error: any) {
            const finalError = `[FATAL] An unexpected error occurred: ${error.message}`;
            outputChannel.appendLine(finalError);
            vscode.window.showErrorMessage(finalError);
        }
    });

    context.subscriptions.push(runAgentDisposable);

    // =========================================================================
    // == 新增：运行项目级文档生成器的命令
    // =========================================================================
    const generateProjectDocDisposable = vscode.commands.registerCommand('codewiki.generateProjectDocumentation', async () => {
        const outputChannel = vscode.window.createOutputChannel("CodeWiki Project Documentation");
        outputChannel.show(true);
        outputChannel.clear();

        try {
            // 1. 获取模型配置
            outputChannel.appendLine("[INFO] 开始生成项目文档...");
            const stateManager = new StateManager(context.globalState);
            const modelConfigs = await stateManager.getModelConfigs();
            const defaultConfig = modelConfigs.find(c => c.isDefault) || modelConfigs[0];
            
            if (!defaultConfig) {
                throw new Error("No default model configuration found. Please configure a model in the CodeWiki settings.");
            }
             outputChannel.appendLine(`[INFO] Using model: ${defaultConfig.name}`);

            // 2. 创建 LLMService 和文档生成智能体
            const llmService = new LLMService();
            const docAgent = new ProjectDocumentationAgent(outputChannel, defaultConfig, llmService);
            await docAgent.run();

        } catch (error: any) {
            const finalError = `[FATAL] An unexpected error occurred: ${error.message}`;
            outputChannel.appendLine(finalError);
            vscode.window.showErrorMessage(finalError);
        }
    });
    context.subscriptions.push(generateProjectDocDisposable);
}

export function deactivate() {}

--------------------------------------------------------------------------------

--- file_path: extension/tools/fileSystemTools.ts ---
// src/extension/tools/fileSystemTools.ts (完整文件)

import * as vscode from 'vscode';
import * as path from 'path';
import { z } from 'zod';
import { StructuredTool } from '@langchain/core/tools';
import { languageFilters, GENERIC_EXCLUDE, LanguageFilter } from '../config/fileFilters';

/**
 * 获取当前工作区的根路径。
 * @returns {string} 工作区根目录的绝对路径。
 * @throws {Error} 如果没有打开的工作区。
 */
function getWorkspaceRoot(): string {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders || workspaceFolders.length === 0) {
        throw new Error("没有打开的工作区。请先打开一个项目文件夹。");
    }
    return workspaceFolders[0].uri.fsPath;
}

/**
 * 新增的辅助函数，用于递归获取过滤后的文件路径。
 * @param dirUri 起始目录的URI
 * @param language 用于选择过滤规则的语言
 * @returns {Promise<vscode.Uri[]>} 过滤后的文件URI列表
 */
async function getFilteredFilePathsRecursive(dirUri: vscode.Uri, language: string = 'unknown'): Promise<vscode.Uri[]> {
    let files: vscode.Uri[] = [];
    const filter: LanguageFilter = languageFilters[language.toLowerCase()] || languageFilters.unknown;

    try {
        const entries = await vscode.workspace.fs.readDirectory(dirUri);

        for (const [name, type] of entries) {
            // 检查是否在通用排除列表中
            if (GENERIC_EXCLUDE.includes(name)) {
                continue;
            }

            const entryUri = vscode.Uri.joinPath(dirUri, name);
            if (type === vscode.FileType.File) {
                const extension = path.extname(name);
                const shouldInclude = filter.include.includes(extension);
                const shouldExclude = filter.exclude.some(pattern => name.endsWith(pattern));

                if (shouldInclude && !shouldExclude) {
                    files.push(entryUri);
                }
            } else if (type === vscode.FileType.Directory) {
                files = files.concat(await getFilteredFilePathsRecursive(entryUri, language));
            }
        }
    } catch (error) {
        console.warn(`Could not read directory ${dirUri.fsPath}:`, error);
    }
    return files;
}

/**
 * 一个LangChain工具，用于获取指定目录下所有文件的路径和内容摘要。
 * 摘要是文件的前20行。
 */
export class GetFileSummariesTool extends StructuredTool {
    static lc_name() {
        return "GetFileSummariesTool";
    }

    name = "get_file_summaries";
    description = "获取指定目录中所有文件的路径和内容摘要（文件的前20行）。用于在阅读完整文件之前，快速了解一个模块的结构。";

    schema = z.object({
        path: z.string().describe("从工作区根目录出发的相对路径。"),
        language: z.string().optional().describe("项目的编程语言 (例如 'typescript', 'python')，用于智能过滤文件。如果未提供，则使用通用规则。"),
    });

    protected async _call({ path: relativePath }: z.infer<typeof this.schema>): Promise<string> {
        try {
            const workspaceRoot = getWorkspaceRoot();
            const absolutePath = path.join(workspaceRoot, relativePath);

            const entries = await vscode.workspace.fs.readDirectory(vscode.Uri.file(absolutePath));
            const fileSummaries: string[] = [];

            for (const [name, type] of entries) {
                if (type === vscode.FileType.File) {
                    const filePath = path.join(absolutePath, name);
                    const fileUri = vscode.Uri.file(filePath);
                    
                    const contentBytes = await vscode.workspace.fs.readFile(fileUri);
                    const content = Buffer.from(contentBytes).toString('utf-8');
                    const summary = content.split('\n').slice(0, 20).join('\n');
                    
                    const fileRelativePath = path.relative(workspaceRoot, filePath);

                    fileSummaries.push(
                        `--- FILE: ${fileRelativePath.replace(/\\/g, '/')} ---\n${summary}\n--- END OF SUMMARY ---\n`
                    );
                }
            }

            if (fileSummaries.length === 0) {
                return `在目录 "${relativePath}" 中没有找到任何文件。`;
            }

            return fileSummaries.join('\n');
        } catch (error: any) {
            return `获取路径 "${relativePath}" 的文件摘要时出错: ${error.message}`;
        }
    }
}


/**
 * 一个LangChain工具，根据提供的文件路径列表，获取这些文件的完整内容。
 */
export class GetFilesContentByListTool extends StructuredTool {
    static lc_name() {
        return "GetFilesContentByListTool";
    }

    name = "get_files_content_by_list";
    description = "根据一个包含相对路径的列表，读取这些文件的完整内容。这个列表通常是文件选择工具的输出。";

    schema = z.object({
        file_paths: z.array(z.string()).describe("一个包含文件相对路径的数组，路径从工作区根目录开始计算。"),
    });

    protected async _call({ file_paths }: z.infer<typeof this.schema>): Promise<string> {
        if (!file_paths || file_paths.length === 0) {
            return "输入的文件列表为空，没有内容可以读取。";
        }

        try {
            const workspaceRoot = getWorkspaceRoot();
            const contentPromises = file_paths.map(async (relativePath) => {
                const absolutePath = path.join(workspaceRoot, relativePath);
                const fileUri = vscode.Uri.file(absolutePath);
                
                try {
                    const contentBytes = await vscode.workspace.fs.readFile(fileUri);
                    const content = Buffer.from(contentBytes).toString('utf-8');
                    return `--- FILE: ${relativePath.replace(/\\/g, '/')} ---\n${content}\n--- END OF FILE ---\n`;
                } catch (fileError: any) {
                    // 如果单个文件读取失败，返回错误信息而不是让整个工具失败
                    return `--- FILE: ${relativePath.replace(/\\/g, '/')} ---\n错误: 无法读取文件。 ${fileError.message}\n--- END OF FILE ---\n`;
                }
            });

            const allContents = await Promise.all(contentPromises);
            return allContents.join('\n');

        } catch (error: any) {
            // 捕获 getWorkspaceRoot 的错误
            return `获取文件内容时出错: ${error.message}`;
        }
    }
}

// highlight-start
/**
 * 一个LangChain工具，用于递归获取指定目录下所有文件的完整内容。
 */
export class GetAllFilesContentTool extends StructuredTool {
    static lc_name() {
        return "GetAllFilesContentTool";
    }

    name = "get_all_files_content";
    description = "递归地获取指定目录及其所有子目录中所有文件的完整内容。当需要对一个模块的所有代码进行全面分析时使用。";

    schema = z.object({
        path: z.string().describe("从工作区根目录出发的相对路径。"),
        language: z.string().optional().describe("项目的编程语言 (例如 'typescript', 'python')，用于智能过滤文件。如果未提供，则使用通用规则。"),
    });

    /**
     * 递归遍历目录并收集文件内容。
     * @param dirUri 要遍历的目录的 URI。
     * @param workspaceRoot 工作区的根路径，用于计算相对路径。
     * @returns 一个包含文件内容和标记的字符串数组。
     */
    private async _traverseDirectory(dirUri: vscode.Uri, workspaceRoot: string): Promise<string[]> {
        let allContents: string[] = [];
        const entries = await vscode.workspace.fs.readDirectory(dirUri);

        for (const [name, type] of entries) {
            const entryUri = vscode.Uri.joinPath(dirUri, name);
            if (type === vscode.FileType.File) {
                const fileRelativePath = path.relative(workspaceRoot, entryUri.fsPath).replace(/\\/g, '/');
                try {
                    const contentBytes = await vscode.workspace.fs.readFile(entryUri);
                    const content = Buffer.from(contentBytes).toString('utf-8');
                    allContents.push(`--- FILE: ${fileRelativePath} ---\n${content}\n--- END OF FILE ---\n`);
                } catch (fileError: any) {
                    allContents.push(`--- FILE: ${fileRelativePath} ---\n错误: 无法读取文件。 ${fileError.message}\n--- END OF FILE ---\n`);
                }
            } else if (type === vscode.FileType.Directory) {
                // 如果是目录，则递归调用
                const subDirContents = await this._traverseDirectory(entryUri, workspaceRoot);
                allContents = allContents.concat(subDirContents);
            }
        }
        return allContents;
    }

    protected async _call({ path: relativePath, language }: z.infer<typeof this.schema>): Promise<string> {
        try {
            const workspaceRoot = getWorkspaceRoot();
            const absolutePath = path.join(workspaceRoot, relativePath);
            const dirUri = vscode.Uri.file(absolutePath);

            // highlight-start
            // 使用新的过滤辅助函数
            const fileUris = await getFilteredFilePathsRecursive(dirUri, language);
            // highlight-end

            if (fileUris.length === 0) {
                return `在目录 "${relativePath}" 及其子目录中没有找到与语言 '${language}' 相关的任何文件。`;
            }
            
            const contentPromises = fileUris.map(async (uri) => {
                 const fileRelativePath = path.relative(workspaceRoot, uri.fsPath).replace(/\\/g, '/');
                 try {
                    const contentBytes = await vscode.workspace.fs.readFile(uri);
                    const content = Buffer.from(contentBytes).toString('utf-8');
                    return `--- FILE: ${fileRelativePath} ---\n${content}\n--- END OF FILE ---\n`;
                 } catch (fileError: any) {
                    return `--- FILE: ${fileRelativePath} ---\n错误: 无法读取文件。 ${fileError.message}\n--- END OF FILE ---\n`;
                 }
            });
            
            const allContents = await Promise.all(contentPromises);
            return allContents.join('\n');

        } catch (error: any) {
            return `递归获取路径 "${relativePath}" 的所有文件内容时出错: ${error.message}`;
        }
    }
}

/**
 * 一个LangChain工具，用于生成指定路径的目录树结构。
 */
export class GetDirectoryTreeTool extends StructuredTool {
    static lc_name() {
        return "GetDirectoryTreeTool";
    }

    name = "get_directory_tree";
    description = "生成给定路径的目录和文件树状结构图。用于快速了解项目的整体文件布局。";

    schema = z.object({
        path: z.string().describe("从工作区根目录出发的相对路径。"),
    });

    /**
     * 递归生成目录树。
     * @param dirUri 要生成树的目录的 URI。
     * @param displayRootPath 用于显示路径的根，例如 "." 或 "project"。
     * @returns 一个包含所有路径的字符串数组。
     */
    private async _generateTree(dirUri: vscode.Uri, displayRootPath: string): Promise<string[]> {
        let treeLines: string[] = [];
        const entries = await vscode.workspace.fs.readDirectory(dirUri);

        for (const [name, type] of entries) {
            const entryUri = vscode.Uri.joinPath(dirUri, name);
            const entryDisplayPath = path.join(displayRootPath, name).replace(/\\/g, '/');

            treeLines.push(entryDisplayPath);

            if (type === vscode.FileType.Directory) {
                const subTreeLines = await this._generateTree(entryUri, entryDisplayPath);
                treeLines = treeLines.concat(subTreeLines);
            }
        }
        return treeLines;
    }

    protected async _call({ path: relativePath }: z.infer<typeof this.schema>): Promise<string> {
        try {
            const workspaceRoot = getWorkspaceRoot();
            const absolutePath = path.join(workspaceRoot, relativePath);
            const dirUri = vscode.Uri.file(absolutePath);

            // 确定显示的根路径
            const displayRoot = relativePath === '.' || relativePath === '' ? '.' : `./${relativePath}`;
            
            let treeLines = [displayRoot];
            const subTree = await this._generateTree(dirUri, displayRoot);
            treeLines = treeLines.concat(subTree);

            return treeLines.join('\n');
        } catch (error: any) {
            return `生成路径 "${relativePath}" 的目录树时出错: ${error.message}`;
        }
    }
}
// highlight-end

--------------------------------------------------------------------------------

--- file_path: extension/tools/llmTools.ts ---
// src/extension/tools/llmTools.ts (完整文件)

import { z } from 'zod';
import { StructuredTool } from '@langchain/core/tools';
import { BaseLanguageModel } from '@langchain/core/language_models/base';
import { ChatPromptTemplate } from '@langchain/core/prompts';
import { StringOutputParser } from '@langchain/core/output_parsers';
import { LLMService } from '../LLMService'; // 导入 LLMService

// 这是 FileSelectorLLMTool 内部使用的 Prompt 模板
const SELECTION_PROMPT = `You are an expert software engineer assistant. Your task is to analyze a list of file summaries and select the most relevant files based on a user's task description.

Analyze the following file summaries:
---
{file_summaries}
---

The user's task is: "{task_description}"

Based on this, which files are the most critical for understanding and completing the task?

Please provide your answer as a clean, comma-separated list of file paths. Do NOT include any other text, explanations, or formatting.

Example response:
src/common/types.ts,src/extension/LLMService.ts,src/webview/views/ChatView.ts
`;

/**
 * 一个内部类，代表了 LLM-as-a-Tool 的具体实现。
 * 我们不直接导出它，而是通过工厂函数创建。
 */
class FileSelectorLLMTool extends StructuredTool {
    static lc_name() {
        return "FileSelectorLLMTool";
    }

    name = "file_selector_llm_tool";
    // highlight-start
    description = "分析文件摘要列表和任务描述，以智能地选择最相关的文件。输出是一个包含文件路径的数组。";
    // highlight-end
    
    // 该工具的输入 schema
    schema = z.object({
        file_summaries: z.string().describe("一个包含所有文件摘要的单一字符串，每个摘要由标记分隔。"),
        task_description: z.string().describe("用于指导文件选择的目标或任务的描述。"),
    });

    // 持有传入的 LLM 实例
    private llm: BaseLanguageModel;
    private llmService: LLMService; // 新增

    constructor(llm: BaseLanguageModel, llmService: LLMService) { // 修改构造函数
        super(); // 调用父类构造函数
        this.llm = llm;
        this.llmService = llmService; // 存储 LLMService 实例
    }

    protected async _call({ file_summaries, task_description }: z.infer<typeof this.schema>): Promise<string> {
        try {
            // 1. 构建专门用于文件筛选的 Prompt
            const selectionPrompt = ChatPromptTemplate.fromTemplate(SELECTION_PROMPT);

            // 2. 构建一个临时的、用于该工具内部的 LangChain "子链"
            //    它接收格式化的 prompt，调用 LLM，然后解析出字符串结果。
            const selectionChain = selectionPrompt
                .pipe(this.llm)
                .pipe(new StringOutputParser());

            // 3. 调用子链来执行 LLM 推理
            console.log("Scheduling file_selector_llm_tool with task:", task_description);
            const llmResult = await this.llmService.scheduleLlmCall(() => 
                selectionChain.invoke({
                    file_summaries,
                    task_description
                })
            );

            // 4. 解析 LLM 返回的结果
            //    LLM 可能返回一些额外的空格或换行符，我们进行清理。
            //    我们期望的结果是 "path/a.ts, path/b.ts, ..."
            const cleanedResult = llmResult.replace(/```/g, '').trim(); // 移除代码块标记和多余空格
            const filePaths = cleanedResult.split(',')
                .map(p => p.trim())
                .filter(p => p.length > 0 && p.includes('/')); // 过滤掉空字符串和无效条目

            if (filePaths.length === 0) {
                console.warn("File selector LLM did not return any valid file paths.");
                return "[]"; // 返回一个表示空数组的JSON字符串
            }
            
            // 5. 将结果（一个字符串数组）序列化为 JSON 字符串返回。
            //    这是因为 LangChain 工具的标准输出是 string。
            //    我们的自定义 Agent Executor (将在下一阶段实现) 将负责解析这个JSON。
            return JSON.stringify(filePaths);

        } catch (error: any) {
            console.error("Error in FileSelectorLLMTool:", error);
            return `在文件选择LLM调用期间出错: ${error.message}`;
        }
    }
}

/**
 * 工厂函数，用于创建和配置 FileSelectorLLMTool。
 * @param llm - 一个配置好的、可用于调用的 BaseLanguageModel 实例。
 * @param llmService - 用于调度LLM调用的服务实例。
 * @returns {StructuredTool} 一个配置好的、可直接使用的工具实例。
 */
export function createFileSelectorLLMTool(llm: BaseLanguageModel, llmService: LLMService): StructuredTool {
    return new FileSelectorLLMTool(llm, llmService);
}

--------------------------------------------------------------------------------

--- file_path: test/suite/index.ts ---


--------------------------------------------------------------------------------

--- file_path: webview/components/MessageBlock.ts ---
import { ChatMessage } from "../../common/types";

export class MessageBlock {
    constructor(private readonly message: ChatMessage, private readonly messageIndex: number) {}

    public render(): HTMLElement {
        const element = document.createElement('div');
        element.className = `message-block ${this.message.role}`;
        element.dataset.index = this.messageIndex.toString();

        const content = document.createElement('div');
        content.className = 'message-content';
        content.textContent = this.message.content;
        
        element.appendChild(content);
        element.appendChild(this.createToolbar());

        return element;
    }

    private createToolbar(): HTMLElement {
        const toolbar = document.createElement('div');
        toolbar.className = 'message-toolbar';

        toolbar.appendChild(this.createButton('toggle-fold', 'Fold', 'codicon-chevron-up'));

        if (this.message.role === 'assistant') {
            toolbar.appendChild(this.createButton('copy-content', 'Copy', 'codicon-copy'));
            toolbar.appendChild(this.createButton('regenerate-response', 'Regenerate', 'codicon-sync'));
        } else {
            toolbar.appendChild(this.createButton('copy-content', 'Copy', 'codicon-copy'));
            toolbar.appendChild(this.createButton('edit-message', 'Edit', 'codicon-pencil'));
        }

        return toolbar;
    }

    private createButton(action: string, title: string, icon: string): HTMLButtonElement {
        const button = document.createElement('button');
        button.className = `icon-button`;
        button.title = title;
        button.dataset.action = action;
        button.innerHTML = `<i class="codicon ${icon}"></i>`;
        return button;
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/css/main.css ---
body,
html {
    height: 100%;
    margin: 0;
    padding: 0;
    background-color: var(--vscode-sideBar-background);
    color: var(--vscode-editor-foreground);
    font-family: var(--vscode-font-family);
    display: flex;
    /* Make body/html a flex container */
    flex-direction: column;
    /* Stack children vertically */
    position: absolute;
    /* Position absolutely to fill the entire webview */
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
}

#root {
    display: flex;
    flex-direction: column;
    height: 100%;
    /* Use 100% relative to absolute positioned parent */
    flex: 1;
    /* Allow #root to grow and take available space */
}

.top-toolbar {
    display: flex;
    justify-content: flex-start;
    padding: 5px;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    flex-shrink: 0;
}

.nav-icon {
    cursor: pointer;
    padding: 5px;
    margin: 0 5px;
    border-radius: 5px;
}

.nav-icon:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.nav-icon.active {
    background-color: var(--vscode-list-activeSelectionBackground);
}

.main-content {
    flex-grow: 1;
    /* Removed overflow-y: hidden to allow internal scrolling */
    display: flex;
    flex-direction: column;
    padding: 0;
}

.view {
    display: none;
    height: 100%;
    width: 100%;
    flex-direction: column;
}

.view.active {
    display: flex;
}


/* Chat View & Focus Editor Common Styles */
.chat-container,
.focus-editor-container {
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    flex: 1;
    /* Ensure it takes full available space within its flex parent */
}

.messages-list {
    flex-grow: 1;
    /* Allow it to grow and take available space */
    overflow-y: auto;
    /* Make this the scrolling container */
    min-height: 0;
    /* Allow the flex item to shrink below its content size */
    width: 100%;
    /* Ensure it takes full width of its flex container */
    box-sizing: border-box;
    /* Include padding and border in the element's total width and height */
}

.chat-sticky-bottom {
    /* No position: sticky needed, flexbox handles it */
    flex-shrink: 0;
    /* Prevent shrinking */
    width: 100%;
    /* Ensure it takes full width of its flex container */
    box-sizing: border-box;
    /* Include padding and border in the element's total width and height */

    padding: 10px;
    border-top: 1px solid var(--vscode-editorGroup-border);
    background-color: var(--vscode-sideBar-background);
    /* Give it a solid background */

    display: flex;
    flex-direction: column;
    gap: 10px;
}

.chat-quick-actions {
    display: flex;
    gap: 10px;
    align-items: center;
}

.chat-quick-actions label {
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
}

#model-selector,
#prompt-selector {
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 5px;
    border-radius: 5px;
    flex-grow: 1;
}

.chat-quick-actions button {
    margin-left: auto;
    margin-top: 0;
}

.chat-input-box-container {
    display: flex;
}

.chat-input-box-container textarea {
    flex-grow: 1;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 8px;
    resize: none;
    border-radius: 5px;
}

/* Chat View Specific */
.chat-container .chat-input-box-container textarea {
    max-height: 250px;
    /* Increased height */
}

/* Focus Editor View Specific */
.focus-editor-container {
    padding: 10px;
}

.focus-editor-container .chat-input-box-container {
    flex-grow: 1;
}

.focus-editor-container .chat-input-box-container textarea {
    height: 100%;
    width: 100%;
    max-height: none;
    box-sizing: border-box;
}


/* Message Block Styles */
.message-block {
    padding: 15px;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    word-wrap: break-word;
    white-space: pre-wrap;
    position: relative;
}

.message-content {
    transition: max-height 0.3s ease-in-out;
    overflow: hidden;
    /* Hide content that exceeds max-height */
    position: relative;
}

.message-block.folded .message-content {
    max-height: 70px;
    /* Adjust as needed, approx 3-4 lines */
}

/* Add a "read more" fade effect when folded */
.message-block.folded .message-content::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 30px;
    background: linear-gradient(to bottom, transparent, var(--vscode-editor-background));
    pointer-events: none;
    /* Allows clicks to pass through */
}

.message-block:last-child {
    border-bottom: none;
}

.message-toolbar {
    position: absolute;
    top: 5px;
    right: 5px;
    background-color: var(--vscode-editorWidget-background);
    border-radius: 5px;
    padding: 2px;
    display: flex;
    gap: 2px;
    opacity: 0;
    transition: opacity 0.1s ease-in-out;
    pointer-events: none;
}

.message-block:hover .message-toolbar {
    opacity: 1;
    pointer-events: all;
}

.message-block.user {
    background-color: var(--vscode-list-hoverBackground);
    border-left: 3px solid var(--vscode-focusBorder);
    padding-left: 12px;
}

.message-block.folded.user .message-content::after {
    background: linear-gradient(to bottom, transparent, var(--vscode-list-hoverBackground));
}

.message-block.assistant {
    background-color: var(--vscode-editor-background);
}

.message-block.editing {
    border: 1px solid var(--vscode-focusBorder);
    box-shadow: 0 0 3px var(--vscode-focusBorder);
    border-radius: 5px;
}

.message-block.error {
    color: var(--vscode-errorForeground);
}

button.streaming {
    background-color: var(--vscode-button-secondaryBackground);
}

button.streaming:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

/* Settings View */
.config-form {
    border: 1px solid var(--vscode-editorGroup-border);
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 5px;
    background-color: var(--vscode-sideBar-sectionHeader-background);
}

.form-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.form-title {
    font-size: 1.1em;
}

.default-badge {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 0.8em;
}

.form-group {
    margin-bottom: 10px;
}

.form-group label {
    display: block;
    margin-bottom: 5px;
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
}

.config-form input {
    width: calc(100% - 20px);
    margin-bottom: 5px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 5px;
}

.form-actions {
    margin-top: 15px;
    display: flex;
    gap: 10px;
}

.form-actions button {
    margin-top: 0;
}

button {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: none;
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 5px;
}

button:hover {
    background-color: var(--vscode-button-hoverBackground);
}

/* Generic View Header */
.view-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.view-header h2 {
    margin: 0;
}

.add-btn {
    font-size: 20px;
    font-weight: bold;
    padding: 0px 8px;
}

/* Chat History View */
.history-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.history-item {
    display: flex;
    align-items: center;
    padding: 15px;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    cursor: pointer;
    position: relative;
}

.history-item:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.history-item-content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}

.history-item-timestamp {
    font-size: 0.8em;
    color: var(--vscode-descriptionForeground);
    margin-bottom: 5px;
}

.history-item-title {
    font-size: 1em;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.history-item-actions {
    display: flex;
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    background-color: var(--vscode-list-hoverBackground);
    opacity: 0;
    transition: opacity 0.1s ease-in-out;
    pointer-events: none;
}

.history-item:hover .history-item-actions {
    opacity: 1;
    pointer-events: all;
}

.icon-button {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--vscode-foreground);
    padding: 5px;
    border-radius: 5px;
}

.icon-button:hover {
    background-color: var(--vscode-toolbar-hoverBackground);
}

.history-empty {
    text-align: center;
    padding: 20px;
    color: var(--vscode-descriptionForeground);
}

/*=================================*/
/*========= Prompt Manager ========*/
/*=================================*/

.prompt-manager-view,
.prompt-editor-view {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.prompt-editor-view {
    display: none;
    /* Hidden by default */
}

/* Search Bar in Header */
.search-bar {
    display: flex;
    align-items: center;
    flex-grow: 1;
    margin-right: 15px;
    background-color: var(--vscode-input-background);
    border: 1px solid var(--vscode-input-border);
    border-radius: 5px;
    padding: 0 8px;
}

.search-bar i {
    margin-right: 8px;
    color: var(--vscode-descriptionForeground);
}

.search-bar input {
    width: 100%;
    border: none;
    background: transparent;
    color: var(--vscode-input-foreground);
    padding: 6px 0;
    outline: none;
}

.codicon-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: none;
    padding: 6px 12px;
    cursor: pointer;
    border-radius: 5px;
}

.codicon-btn:hover {
    background-color: var(--vscode-button-hoverBackground);
}

.codicon-btn.secondary {
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-button-secondaryForeground);
}

.codicon-btn.secondary:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.icon-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--vscode-foreground);
    padding: 5px;
    border-radius: 5px;
}

.icon-btn:hover {
    background-color: var(--vscode-toolbar-hoverBackground);
}


/* Prompt List */
.prompt-list-container {
    flex-grow: 1;
    overflow-y: auto;
}

.prompt-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.prompt-list-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--vscode-editorGroup-border);
    cursor: pointer;
    transition: background-color 0.1s ease-in-out;
}

.prompt-list-item:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.prompt-item-main {
    flex-grow: 1;
    margin-right: 15px;
    overflow: hidden;
}

.prompt-item-title {
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: 4px;
}

.prompt-item-summary {
    font-size: 0.9em;
    color: var(--vscode-descriptionForeground);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.prompt-item-meta {
    flex-shrink: 0;
    text-align: right;
}

.prompt-item-time {
    font-size: 0.8em;
    color: var(--vscode-descriptionForeground);
    margin-bottom: 8px;
}

.prompt-item-actions {
    display: flex;
    gap: 5px;
    opacity: 0;
    transition: opacity 0.1s ease-in-out;
}

.prompt-list-item:hover .prompt-item-actions {
    opacity: 1;
}

/* Empty State */
.empty-state {
    text-align: center;
    padding: 40px 20px;
    color: var(--vscode-descriptionForeground);
}

.empty-state p {
    margin-bottom: 15px;
}

.highlighted-btn {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: 1px solid var(--vscode-button-border, transparent);
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
}

.highlighted-btn:hover {
    background-color: var(--vscode-button-hoverBackground);
}

/*=================================*/
/*========= Prompt Editor =========*/
/*=================================*/

.prompt-editor-form {
    flex-grow: 1;
    overflow-y: auto;
    padding: 10px;
    display: flex;
    flex-direction: column;
}

.prompt-editor-form .form-group {
    display: flex;
    flex-direction: column;
}

.prompt-editor-form .form-group:last-child {
    flex-grow: 1;
}

.prompt-editor-form input,
.prompt-editor-form textarea {
    width: calc(100% - 22px);
    /* 100% - padding - border */
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 10px;
    border-radius: 5px;
}

.prompt-editor-form textarea {
    flex-grow: 1;
    resize: none;
    font-family: var(--vscode-editor-font-family);
}

/*=================================*/
/*====== Rich Input & Pills =======*/
/*=================================*/

/* 将原来的输入框容器升级为富文本样式 */
.chat-input-box {
    flex-grow: 1;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 8px;
    resize: none;
    /* 虽然不是 textarea，但保留这个概念 */
    border-radius: 5px;
    min-height: 22px;
    /* 约等于单行 textarea 的高度 */
    max-height: 250px;
    overflow-y: auto;
    white-space: pre-wrap;
    /* 保证空格和换行被保留 */
    word-wrap: break-word;
}

.chat-input-box:focus {
    outline: 1px solid var(--vscode-focusBorder);
}

/* 胶囊 (Pill) 的样式 */
.content-pill {
    display: inline-block;
    background-color: var(--vscode-toolbar-hoverBackground);
    border-radius: 12px;
    padding: 2px 10px;
    margin: 0 2px;
    cursor: pointer;
    font-size: 0.9em;
    transition: background-color 0.2s ease;
}

.content-pill:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.content-pill .pill-tag {
    font-weight: bold;
    color: var(--vscode-button-background);
    /* 使用主题色突出标签名 */
}

/* 展开后的编辑器容器 */
.pill-editor {
    display: block;
    border: 1px solid var(--vscode-focusBorder);
    border-radius: 5px;
    margin: 8px 0;
    padding: 8px;
    background-color: var(--vscode-input-background);
}

.pill-editor textarea {
    width: 100%;
    height: 150px;
    /* 初始高度 */
    background: transparent;
    border: none;
    color: var(--vscode-input-foreground);
    resize: vertical;
    /* 允许用户调整高度 */
    font-family: var(--vscode-editor-font-family);
}

.pill-editor textarea:focus {
    outline: none;
}

.pill-editor-actions {
    text-align: right;
    margin-top: 5px;
}

/* 确保 contenteditable div 中的 p 标签没有多余的 margin */
.chat-input-box p {
    margin: 0;
}

--------------------------------------------------------------------------------

--- file_path: webview/main.ts ---
import { App } from './views/App';

// Wait for the DOM to be fully loaded before initializing the app
window.addEventListener('load', () => {
    const app = new App(document.body);
    app.initialize();
});


--------------------------------------------------------------------------------

--- file_path: webview/views/App.ts ---
import { vscode } from '../vscode';
import { ChatView } from './ChatView';
import { SettingsView } from './SettingsView';
import { WelcomeView } from './WelcomeView';
import { ChatHistoryView } from './ChatHistoryView';
import { PromptManagerView } from './PromptManagerView';
import { PromptEditorView } from './PromptEditorView';
import { FocusEditorView } from './FocusEditorView';

export class App {
    private chatView: ChatView;
    private focusEditorView?: FocusEditorView;
    private settingsView: SettingsView;
    private welcomeView: WelcomeView;
    private chatHistoryView: ChatHistoryView;
    private promptManagerView: PromptManagerView;
    private promptEditorView: PromptEditorView;

    constructor(private readonly parent: HTMLElement) {
        this.parent.innerHTML = this.render();

        this.welcomeView = new WelcomeView(this.parent.querySelector('#view-welcome') as HTMLElement);
        this.chatView = new ChatView(this.parent.querySelector('#view-chat') as HTMLElement);
        this.chatHistoryView = new ChatHistoryView(
            this.parent.querySelector('#view-history') as HTMLElement,
            this.navigateTo.bind(this)
        );
        this.promptManagerView = new PromptManagerView(this.parent.querySelector('#view-prompts') as HTMLElement);
        this.promptEditorView = new PromptEditorView(this.parent.querySelector('#view-prompt-editor') as HTMLElement);
        this.settingsView = new SettingsView(this.parent.querySelector('#view-settings') as HTMLElement);
    }

    public initialize() {
        this.setupEventListeners();
        // On initial load, determine if this is a focus editor or main view
        if (document.body.classList.contains('focus-editor-body')) {
            vscode.postMessage({ command: 'ready' });
        } else {
            this.navigateTo('chat');
            vscode.postMessage({ command: 'ready' });
        }
    }

    private setupEventListeners() {
        // Top toolbar navigation
        this.parent.querySelector('#nav-new-chat')?.addEventListener('click', () => this.chatView.clearChat());
        this.parent.querySelector('#nav-chat')?.addEventListener('click', () => this.navigateTo('chat'));
        this.parent.querySelector('#nav-history')?.addEventListener('click', () => this.navigateTo('history'));
        this.parent.querySelector('#nav-prompts')?.addEventListener('click', () => this.navigateTo('prompts'));
        this.parent.querySelector('#nav-settings')?.addEventListener('click', () => this.navigateTo('settings'));

        // Listen for messages from the extension host
        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.command) {
                case 'initialize':
                    this.chatView.setConversations(message.payload.conversations);
                    this.chatHistoryView.setConversations(message.payload.conversations);
                    this.promptManagerView.update(message.payload.prompts);
                    this.chatView.setPrompts(message.payload.prompts);
                    this.chatView.setModelConfigs(message.payload.modelConfigs);
                    this.settingsView.setModelConfigs(message.payload.modelConfigs);
                    break;
                case 'showPromptEditor':
                    this.navigateTo('prompt-editor', message.payload);
                    break;
                case 'showPromptManager':
                    this.navigateTo('prompts');
                    break;
                case 'updatePrompts':
                    this.promptManagerView.update(message.payload);
                    this.chatView.setPrompts(message.payload);
                    if (this.focusEditorView) {
                        this.focusEditorView.setPrompts(message.payload);
                    }
                    break;
                case 'setActiveConversation':
                    this.chatView.loadConversation(message.payload);
                    break;
                case 'updateModelConfigs':
                    this.chatView.setModelConfigs(message.payload);
                    this.settingsView.setModelConfigs(message.payload);
                    if (this.focusEditorView) {
                        this.focusEditorView.setModelConfigs(message.payload);
                    }
                    break;
                case 'updateHistory':
                    this.chatHistoryView.setConversations(message.payload);
                    break;
                case 'showFocusEditor':
                    this.navigateTo('focus-editor', message.payload);
                    break;
                case 'updateContent':
                    if (this.focusEditorView) {
                        this.focusEditorView.updateContent(message.payload.content);
                    }
                    const mainTextarea = this.chatView['bottomPanel'].querySelector('textarea');
                    if (mainTextarea && mainTextarea.value !== message.payload.content) {
                        mainTextarea.value = message.payload.content;
                        this.chatView['autoResizeInput'](mainTextarea);
                    }
                    break;
                case 'updateState':
                    if (this.focusEditorView) {
                        this.focusEditorView.updateState(message.payload);
                    }
                    if (message.payload.modelId) {
                        this.chatView['modelSelector'].value = message.payload.modelId;
                    }
                    if (message.payload.promptId) {
                        this.chatView['promptSelector'].value = message.payload.promptId;
                    }
                    break;
                case 'clearInput':
                    const textarea = this.chatView['bottomPanel'].querySelector('textarea');
                    if (textarea) {
                        textarea.value = '';
                        this.chatView['autoResizeInput'](textarea);
                    }
                    if (this.focusEditorView) {
                        this.focusEditorView.clearInput();
                    }
                    break;
                case 'focusEditorClosed':
                    this.navigateTo('chat');
                    const topToolbar = this.parent.querySelector('.top-toolbar') as HTMLElement;
                    if (topToolbar) topToolbar.style.display = 'flex';
                    this.chatView['toggleMaximizeButton'](false);
                    break;
            }
        });
    }

    public navigateTo(view: string, data?: any) {
        this.parent.querySelectorAll('.view').forEach(v => {
            (v as HTMLElement).style.display = 'none';
        });

        let activeNav = view;

        if (view === 'chat' && typeof data === 'string') {
            vscode.postMessage({ command: 'loadConversation', payload: { id: data } });
        } else if (view === 'prompt-editor') {
            activeNav = 'prompts';
            const editorContainer = this.parent.querySelector('#view-prompt-editor') as HTMLElement;
            if (editorContainer) {
                editorContainer.style.display = 'block';
            }
            this.promptEditorView.show(data?.prompt);
        } else if (view === 'focus-editor') {
            const container = this.parent.querySelector('#view-focus-editor') as HTMLElement;
            if (!this.focusEditorView) {
                this.focusEditorView = new FocusEditorView(container, data);
            }

            // 直接从 data payload 中获取数据并设置
            if (data.modelConfigs) {
                this.focusEditorView.setModelConfigs(data.modelConfigs);
            }
            if (data.prompts) {
                this.focusEditorView.setPrompts(data.prompts);
            }

            // 每次导航时都更新内容和状态
            this.focusEditorView.updateContent(data.content);
            this.focusEditorView.updateState(data);
            container.style.display = 'flex';
            const topToolbar = this.parent.querySelector('.top-toolbar') as HTMLElement;
            if (topToolbar) topToolbar.style.display = 'none';
            return; // Skip nav update for focus editor
        }

        if (view !== 'prompt-editor') {
            const targetView = this.parent.querySelector(`#view-${view}`);
            if (targetView) {
                (targetView as HTMLElement).style.display = 'flex';
            }
        }

        this.parent.querySelectorAll('.nav-icon').forEach(icon => icon.classList.remove('active'));
        this.parent.querySelector(`#nav-${activeNav}`)?.classList.add('active');
    }

    private render(): string {
        return `
            <div class="top-toolbar">
                <div id="nav-new-chat" class="nav-icon" title="New Chat"><i class="codicon codicon-add"></i></div>
                <div class="nav-separator"></div>
                <div id="nav-chat" class="nav-icon" title="Chat"><i class="codicon codicon-comment-discussion"></i></div>
                <div id="nav-history" class="nav-icon" title="History"><i class="codicon codicon-history"></i></div>
                <div id="nav-prompts" class="nav-icon" title="Prompts"><i class="codicon codicon-symbol-keyword"></i></div>
                <div id="nav-settings" class="nav-icon" title="Settings"><i class="codicon codicon-settings-gear"></i></div>
            </div>
            <div class="main-content">
                <div id="view-welcome" class="view"></div>
                <div id="view-chat" class="view"></div>
                <div id="view-history" class="view"></div>
                <div id="view-prompts" class="view"></div>
                <div id="view-prompt-editor" class="view"></div>
                <div id="view-settings" class="view"></div>
                <div id="view-focus-editor" class="view"></div>
            </div>
        `;
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/ChatHistoryView.ts ---
import { Conversation } from "../../common/types";
import { vscode } from "../vscode";

export class ChatHistoryView {
    private conversations: Conversation[] = [];
    private historyContainer: HTMLElement;

    constructor(
        private readonly parent: HTMLElement,
        private readonly navigate: (view: string, conversationId?: string) => void
    ) {
        this.parent.innerHTML = `<div class="history-container"><h2>Chat History</h2><ul class="history-list"></ul></div>`;
        this.historyContainer = this.parent.querySelector('.history-list') as HTMLElement;
    }

    public setConversations(conversations: Conversation[]) {
        // Sort conversations by date, newest first
        this.conversations = conversations.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
        this.render();
    }

    private render() {
        this.historyContainer.innerHTML = '';
        if (this.conversations.length === 0) {
            this.historyContainer.innerHTML = `<li class="history-empty">No chat history found.</li>`;
            return;
        }

        this.conversations.forEach(conv => {
            const li = document.createElement('li');
            li.className = 'history-item';
            li.dataset.id = conv.id;
            li.addEventListener('click', () => {
                this.navigate('chat', conv.id);
            });

            const content = document.createElement('div');
            content.className = 'history-item-content';

            const timestamp = document.createElement('div');
            timestamp.className = 'history-item-timestamp';
            timestamp.textContent = this.formatDate(conv.createdAt);

            const title = document.createElement('div');
            title.className = 'history-item-title';
            title.textContent = conv.title;

            content.appendChild(timestamp);
            content.appendChild(title);

            const actions = document.createElement('div');
            actions.className = 'history-item-actions';
            
            const deleteButton = document.createElement('button');
            deleteButton.className = 'icon-button';
            deleteButton.title = 'Delete';
            deleteButton.innerHTML = `<i class="codicon codicon-trash"></i>`;
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                vscode.postMessage({ command: 'deleteConversation', payload: { id: conv.id } });
            });

            const exportButton = document.createElement('button');
            exportButton.className = 'icon-button';
            exportButton.title = 'Export';
            exportButton.innerHTML = `<i class="codicon codicon-export"></i>`;
            exportButton.addEventListener('click', (e) => {
                e.stopPropagation();
                // Placeholder for export functionality
                vscode.postMessage({ command: 'info', payload: 'Export functionality is not yet implemented.' });
            });

            actions.appendChild(deleteButton);
            actions.appendChild(exportButton);

            li.appendChild(content);
            li.appendChild(actions);

            this.historyContainer.appendChild(li);
        });
    }

    private formatDate(dateString: string): string {
        const date = new Date(dateString);
        const options: Intl.DateTimeFormatOptions = {
            month: 'long',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric',
            hour12: true
        };
        return date.toLocaleString('en-US', options).replace(',', '');
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/ChatView.ts ---
import { Conversation, ChatMessage, ModelConfig, Prompt } from "../../common/types";
import { vscode } from "../vscode";
import { MessageBlock } from "../components/MessageBlock";

export class ChatView {
    private messages: ChatMessage[] = [];
    private modelConfigs: ModelConfig[] = [];
    private prompts: Prompt[] = [];
    private messageContainer: HTMLElement;
    private bottomPanel: HTMLElement;
    private modelSelector: HTMLSelectElement;
    private promptSelector: HTMLSelectElement;
    private isStreaming: boolean = false;
    private editingMessageIndex: number | null = null;
    private originalMessageContent: string | null = null;

    constructor(private readonly parent: HTMLElement) {
        this.parent.innerHTML = this.renderInitialLayout();
        this.messageContainer = this.parent.querySelector('.messages-list') as HTMLElement;
        this.bottomPanel = this.parent.querySelector('.chat-sticky-bottom') as HTMLElement;
        this.modelSelector = this.parent.querySelector('#model-selector') as HTMLSelectElement;
        this.promptSelector = this.parent.querySelector('#prompt-selector') as HTMLSelectElement;
        this.renderBottomInput();
        this.setupEventListeners();
    }

    public setConversations(conversations: Conversation[]) {
        if (conversations.length > 0) {
            this.messages = conversations[conversations.length - 1].messages;
        } else {
            this.messages = [];
        }
        this.renderMessages();
    }

    public clearChat() {
        this.messages = [];
        this.renderMessages();
        vscode.postMessage({ command: 'newChat' });
    }

    public loadConversation(conversation: Conversation) {
        this.messages = conversation.messages;
        this.handleCancelEdit(); // Ensure we exit any edit mode when loading a new conversation
        this.renderMessages();
    }

    public setModelConfigs(configs: ModelConfig[]) {
        this.modelConfigs = configs;
        this.renderModelSelector();
    }

    public setPrompts(prompts: Prompt[]) {
        this.prompts = prompts;
        this.renderPromptSelector();
    }

    private setupEventListeners() {
        // Listener for all clicks in the view
        this.parent.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            const button = target.closest('button');

            if (this.editingMessageIndex !== null) {
                const editingBlock = this.parent.querySelector('.message-block.editing');
                if (editingBlock && !editingBlock.contains(target) && !this.bottomPanel.contains(target)) {
                    this.handleCancelEdit();
                    return;
                }
            }

            if (!button) return;
            const action = button.dataset.action;
            if (!action) return;

            const messageBlock = target.closest('.message-block');
            const messageIndex = messageBlock ? parseInt((messageBlock as HTMLElement).dataset.index || '-1', 10) : -1;

            switch (action) {
                case 'send-or-save': this.handleSendOrSave(); break;
                case 'copy-content': if (messageIndex !== -1) this.handleCopy(messageIndex); break;
                case 'regenerate-response': if (messageIndex !== -1) this.handleRegenerate(messageIndex); break;
                case 'edit-message': if (messageIndex !== -1) this.handleEnterEditMode(messageIndex); break;
                case 'maximize-editor': this.handleMaximizeEditor(); break;
                case 'toggle-fold':
                    if (messageBlock) {
                        const icon = button.querySelector('i');
                        messageBlock.classList.toggle('folded');
                        if (messageBlock.classList.contains('folded')) {
                            button.title = 'Expand';
                            icon?.classList.remove('codicon-chevron-up');
                            icon?.classList.add('codicon-chevron-down');
                        } else {
                            button.title = 'Fold';
                            icon?.classList.remove('codicon-chevron-down');
                            icon?.classList.add('codicon-chevron-up');
                        }
                    }
                    break;

            }
        });

        window.addEventListener('resize', () => {

        });

        this.modelSelector.addEventListener('change', () => {
            vscode.postMessage({
                command: 'syncStateChange',
                payload: { modelId: this.modelSelector.value }
            });
        });

        this.promptSelector.addEventListener('change', () => {
            const selectedPromptId = this.promptSelector.value;
            vscode.postMessage({
                command: 'syncStateChange',
                payload: { promptId: selectedPromptId }
            });

            if (selectedPromptId) {
                const selectedPrompt = this.prompts.find(p => p.id === selectedPromptId);
                if (selectedPrompt) {
                    const inputBox = this.bottomPanel.querySelector('textarea');
                    if (inputBox) {
                        inputBox.value = selectedPrompt.content;
                        this.autoResizeInput(inputBox);
                        inputBox.focus();
                        vscode.postMessage({
                            command: 'updateWebviewContent',
                            payload: { content: inputBox.value }
                        });
                    }
                }
            }
        });

        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.command) {
                case 'startStreaming': this.beginStream(); break;
                case 'streamData': this.appendStreamData(message.payload); break;
                case 'streamEnd': this.finalizeStream(); break;
                case 'requestFailed': this.handleRequestFailed(message.payload.error); break;
                case 'setActiveConversation': this.loadConversation(message.payload); break;
                case 'updatePrompts': this.setPrompts(message.payload); break;
                case 'updateContent': {
                    const inputBox = this.bottomPanel.querySelector('textarea');
                    if (inputBox && inputBox.value !== message.payload.content) {
                        inputBox.value = message.payload.content;
                        this.autoResizeInput(inputBox);
                    }
                    break;
                }
                case 'clearInput': {
                    const inputBox = this.bottomPanel.querySelector('textarea');
                    if (inputBox) {
                        inputBox.value = '';
                        this.autoResizeInput(inputBox);
                    }
                    break;
                }
                case 'focusEditorClosed': this.toggleMaximizeButton(false); break;
                case 'updateState':
                    if (message.payload.modelId) {
                        this.modelSelector.value = message.payload.modelId;
                    }
                    if (message.payload.promptId) {
                        this.promptSelector.value = message.payload.promptId;
                    }
                    break;
            }
        });
    }

    private handleSendOrSave() {
        if (this.editingMessageIndex !== null) {
            this.handleSaveEdit(this.editingMessageIndex);
        } else {
            this.handleSendMessage();
        }
    }

    private handleSendMessage() {
        if (this.isStreaming) {
            vscode.postMessage({ command: 'stopMessage' });
            return;
        }

        const inputBox = this.bottomPanel.querySelector('textarea');
        if (!inputBox) return;

        const prompt = inputBox.value.trim();
        if (!prompt) return;

        // --- 临时的 Agent 触发器 ---
        if (prompt.startsWith('/agent')) {
            const selectedModelId = this.modelSelector.value;
            const selectedConfig = this.modelConfigs.find(c => c.id === selectedModelId);
            if (!selectedConfig) {
                 vscode.postMessage({ command: 'error', payload: 'Please select a valid model from settings.' });
                return;
            }

            const testYaml = `
title: "生成核心模块设计文档 (智能筛选版)"
description: "智能分析模块内的所有文件，找出核心文件，并基于它们生成技术文档。"
input_variables:
  - name: module_path
    description: "请输入或选择要分析的模块/文件夹路径。"
    type: "path"
    default: "src/extension"
  - name: task_description
    description: "简要描述你想分析的核心任务是什么？"
    type: "text"
    default: "这个模块的核心功能是处理大模型请求和管理插件状态。"
tool_chain:
  - tool: "get_file_summaries"
    # 修正: 将 input 从字符串改为对象格式，以匹配工具的 schema
    input: 
      path: "{module_path}"
    output_variable: all_file_summaries
  - tool: "file_selector_llm_tool"
    input: 
      file_summaries: "{all_file_summaries}"
      task_description: "{task_description}"
    output_variable: selected_files_list
  - tool: "get_files_content_by_list"
    # 修正: 将 input 从字符串改为对象格式
    input:
      file_paths: "{selected_files_list}"
    output_variable: selected_files_content
llm_prompt_template:
  system: |
    你是一个经验丰富的软件架构师，你的任务是基于提供的核心文件内容，为模块生成一份详细、专业的技术设计文档。文档需要包含以下部分：1. 模块概述 2. 核心职责 3. 主要组件分析（逐一分析每个文件） 4. 数据流和交互 5. 潜在改进点。请使用 Markdown 格式化你的回答。
  human: |
    请根据以下精心筛选出的核心文件，为模块生成一份详细设计文档。

    **核心文件内容如下：**
    {selected_files_content}
`;
            
            const userInputs = {
                module_path: "src/extension", // 可以硬编码或从 prompt 中解析
                task_description: "这个模块的核心功能是处理大模型请求、状态管理和视图提供。"
            };

            vscode.postMessage({ 
                command: 'executeActionPrompt', 
                payload: {
                    yamlContent: testYaml,
                    userInputs: userInputs,
                    modelConfig: selectedConfig
                }
            });
            inputBox.value = '';
            this.autoResizeInput(inputBox);
            return; // 结束执行
        }
        // --- 结束 Agent 触发器 ---


        const selectedModelId = this.modelSelector.value;
        const selectedConfig = this.modelConfigs.find(c => c.id === selectedModelId);

        if (!selectedConfig) {
            vscode.postMessage({ command: 'error', payload: 'Please select a valid model from settings.' });
            return;
        }

        const message: ChatMessage = { role: 'user', content: prompt };
        this.messages.push(message);
        this.renderMessages();

        inputBox.value = '';
        this.autoResizeInput(inputBox);
        vscode.postMessage({ command: 'sendMessage', payload: { prompt, config: selectedConfig } });
    }

    private handleCopy(index: number) {
        navigator.clipboard.writeText(this.messages[index].content);
        vscode.postMessage({ command: 'info', payload: 'Copied to clipboard!' });
    }

    private handleRegenerate(index: number) {
        vscode.postMessage({ command: 'regenerate', payload: { messageIndex: index } });
    }

    private handleEnterEditMode(index: number) {
        if (this.editingMessageIndex === index) return;

        if (this.editingMessageIndex !== null) {
            this.handleCancelEdit();
        }

        this.editingMessageIndex = index;
        this.originalMessageContent = this.messages[index].content;

        const mainTextarea = this.bottomPanel.querySelector('textarea');
        if (mainTextarea) {
            mainTextarea.value = this.originalMessageContent;
            this.autoResizeInput(mainTextarea);
            mainTextarea.focus();
        }

        this.renderMessages();
        this.updateSendButtonState();
    }

    private handleCancelEdit() {
        if (this.editingMessageIndex === null) return;

        if (this.originalMessageContent !== null) {
            this.messages[this.editingMessageIndex].content = this.originalMessageContent;
        }

        this.editingMessageIndex = null;
        this.originalMessageContent = null;

        const mainTextarea = this.bottomPanel.querySelector('textarea');
        if (mainTextarea) {
            mainTextarea.value = '';
            this.autoResizeInput(mainTextarea);
        }

        this.renderMessages();
        this.updateSendButtonState();
    }

    private handleSaveEdit(index: number) {
        const mainTextarea = this.bottomPanel.querySelector('textarea');
        if (!mainTextarea) return;

        const newContent = mainTextarea.value.trim();
        if (newContent) {
            this.messages[index].content = newContent;
            vscode.postMessage({ command: 'editMessage', payload: { messageIndex: index, content: newContent } });
        }

        this.editingMessageIndex = null;
        this.originalMessageContent = null;

        mainTextarea.value = '';
        this.autoResizeInput(mainTextarea);

        this.renderMessages();
        this.updateSendButtonState();
    }

    private beginStream() {
        this.isStreaming = true;
        const assistantMessage: ChatMessage = { role: 'assistant', content: '' };
        this.messages.push(assistantMessage);
        this.renderMessages();
        this.updateSendButtonState();
    }

    private appendStreamData(chunk: string) {
        const lastMessage = this.messages[this.messages.length - 1];
        if (lastMessage?.role === 'assistant') {
            lastMessage.content += chunk;
            this.renderMessages();
        }
    }

    private finalizeStream(stopped = false) {
        this.isStreaming = false;
        const lastMessage = this.messages[this.messages.length - 1];
        if (stopped && lastMessage?.role === 'assistant') {
            lastMessage.content += ' (Stopped)';
        }
        this.renderMessages();
        this.updateSendButtonState();
    }

    private handleRequestFailed(error: string) {
        this.finalizeStream();
        this.messages.pop();
        const lastUserMessage = this.messages.pop();

        this.renderMessages();

        if (lastUserMessage) {
            const inputBox = this.bottomPanel.querySelector('textarea');
            if (inputBox) inputBox.value = lastUserMessage.content;
        }

        const errorElement = document.createElement('div');
        errorElement.className = 'message-block assistant error';
        errorElement.textContent = `Error: ${error}`;
        this.messageContainer.appendChild(errorElement);
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
    }

    private handleMaximizeEditor() {
        const inputBox = this.bottomPanel.querySelector('textarea');
        if (inputBox) {
            vscode.postMessage({
                command: 'openFocusEditor',
                payload: {
                    content: inputBox.value,
                    modelId: this.modelSelector.value,
                    promptId: this.promptSelector.value
                }
            });
            this.toggleMaximizeButton(true);
        }
    }

    private toggleMaximizeButton(isMaximized: boolean) {
        const button = this.bottomPanel.querySelector('button[data-action="maximize-editor"]') as HTMLButtonElement;
        if (button) {
            if (isMaximized) {
                button.innerHTML = `<i class="codicon codicon-screen-normal"></i>`;
                button.title = '恢复至侧边栏';
            } else {
                button.innerHTML = `<i class="codicon codicon-screen-full"></i>`;
                button.title = '最大化编辑';
            }
        }
    }

    private renderMessages() {
        this.messageContainer.innerHTML = '';
        this.messages.forEach((msg, index) => {
            const element = new MessageBlock(msg, index).render();
            if (this.editingMessageIndex === index) {
                element.classList.add('editing');
            }
            this.messageContainer.appendChild(element);
        });
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
    }

    private renderBottomInput() {
        const container = this.bottomPanel.querySelector('.chat-input-box-container');
        if (!container) return;

        container.innerHTML = `<textarea placeholder="输入消息，或从下拉菜单选择提示词..."></textarea>`;
        const textarea = container.querySelector('textarea') as HTMLTextAreaElement;

        textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.handleSendOrSave();
            }
        });

        textarea.addEventListener('input', () => {
            this.autoResizeInput(textarea);
            vscode.postMessage({
                command: 'updateWebviewContent',
                payload: { content: textarea.value }
            });
        });

        this.updateSendButtonState();
    }

    private updateSendButtonState() {
        const sendButton = this.bottomPanel.querySelector('button[data-action="send-or-save"]');
        if (sendButton) {
            if (this.isStreaming) {
                sendButton.textContent = 'Stop';
                sendButton.classList.add('streaming');
            } else if (this.editingMessageIndex !== null) {
                sendButton.textContent = 'Save';
                sendButton.classList.remove('streaming');
            } else {
                sendButton.textContent = 'Send';
                sendButton.classList.remove('streaming');
            }
        }
    }

    private renderInitialLayout(): string {
        return `
            <div class="chat-container">
                <div class="messages-list"></div>
                <div class="chat-sticky-bottom">
                    <div class="chat-quick-actions">
                        <label for="model-selector">Model:</label>
                        <select id="model-selector"></select>
                        <label for="prompt-selector">Prompt:</label>
                        <select id="prompt-selector"></select>
                        <button data-action="maximize-editor" title="最大化编辑">
                            <i class="codicon codicon-screen-full"></i>
                        </button>
                        <button data-action="send-or-save">Send</button>
                    </div>
                    <div class="chat-input-box-container"></div>
                </div>
            </div>
        `;
    }

    private renderModelSelector() {
        this.modelSelector.innerHTML = '';
        const defaultModel = this.modelConfigs.find(c => c.isDefault);
        this.modelConfigs.forEach(config => {
            const option = document.createElement('option');
            option.value = config.id;
            option.textContent = config.name;
            if (defaultModel && config.id === defaultModel.id) {
                option.selected = true;
            }
            this.modelSelector.appendChild(option);
        });
    }

    private renderPromptSelector() {
        this.promptSelector.innerHTML = '<option value="">Select a prompt...</option>';
        this.prompts.forEach(prompt => {
            const option = document.createElement('option');
            option.value = prompt.id;
            option.textContent = prompt.title;
            this.promptSelector.appendChild(option);
        });
    }

    private autoResizeInput(textarea: HTMLTextAreaElement) {
        textarea.style.height = 'auto';
        const scrollHeight = textarea.scrollHeight;
        const maxHeight = 250; // Synced with main.css

        if (scrollHeight > maxHeight) {
            textarea.style.height = `${maxHeight}px`;
            textarea.style.overflowY = 'auto';
        } else {
            textarea.style.height = `${scrollHeight}px`;
            textarea.style.overflowY = 'hidden';
        }
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/FocusEditorView.ts ---
import { vscode } from "../vscode";
import { ModelConfig, Prompt } from "../../common/types";

export class FocusEditorView {
    private parent: HTMLElement;
    private modelConfigs: ModelConfig[] = [];
    private prompts: Prompt[] = [];
    private modelSelector: HTMLSelectElement;
    private promptSelector: HTMLSelectElement;
    private textarea: HTMLTextAreaElement;

    constructor(container: HTMLElement, initialData: { content: string, modelId?: string, promptId?: string }) {
        this.parent = container;
        this.parent.innerHTML = this.render();
        
        this.modelSelector = this.parent.querySelector('#model-selector') as HTMLSelectElement;
        this.promptSelector = this.parent.querySelector('#prompt-selector') as HTMLSelectElement;
        this.textarea = this.parent.querySelector('textarea') as HTMLTextAreaElement;

        this.textarea.value = initialData.content;
        if (initialData.modelId) {
            this.modelSelector.value = initialData.modelId;
        }
        if (initialData.promptId) {
            this.promptSelector.value = initialData.promptId;
        }

        this.setupEventListeners();
    }

    public render(): string {
        return `
            <div class="focus-editor-container">
                <div class="chat-quick-actions">
                    <label for="model-selector">Model:</label>
                    <select id="model-selector"></select>
                    <label for="prompt-selector">Prompt:</label>
                    <select id="prompt-selector"></select>
                    <button data-action="minimize-editor" title="恢复至侧边栏">
                        <i class="codicon codicon-screen-normal"></i>
                    </button>
                    <button data-action="send-message">Send</button>
                </div>
                <div class="chat-input-box-container">
                     <textarea placeholder="输入消息，或从下拉菜单选择提示词..."></textarea>
                </div>
            </div>
        `;
    }

    private setupEventListeners() {
        this.parent.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            const button = target.closest('button');
            if (!button) return;

            const action = button.dataset.action;
            switch (action) {
                case 'send-message':
                    this.handleSendMessage();
                    break;
                case 'minimize-editor':
                    vscode.postMessage({ command: 'closeFocusEditor' });
                    break;
            }
        });

        this.modelSelector.addEventListener('change', () => {
            vscode.postMessage({
                command: 'syncStateChange',
                payload: { modelId: this.modelSelector.value }
            });
        });

        this.promptSelector.addEventListener('change', () => {
            const selectedPromptId = this.promptSelector.value;
            vscode.postMessage({
                command: 'syncStateChange',
                payload: { promptId: selectedPromptId }
            });
        });

        this.textarea.addEventListener('input', () => {
            vscode.postMessage({
                command: 'updateWebviewContent',
                payload: { content: this.textarea.value }
            });
        });

        this.textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.handleSendMessage();
            }
        });

        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.command) {
                case 'updateState':
                    this.updateState(message.payload);
                    break;
                case 'updatePrompts':
                    this.setPrompts(message.payload);
                    break;
                case 'updateContent':
                    this.updateContent(message.payload.content);
                    break;
            }
        });
    }

    public setModelConfigs(configs: ModelConfig[]) {
        this.modelConfigs = configs;
        const currentVal = this.modelSelector.value;
        this.renderModelSelector();
        this.modelSelector.value = currentVal;
    }

    public setPrompts(prompts: Prompt[]) {
        this.prompts = prompts;
        const currentVal = this.promptSelector.value;
        this.renderPromptSelector();
        this.promptSelector.value = currentVal;
    }

    public updateContent(content: string) {
        if (this.textarea.value !== content) {
            this.textarea.value = content;
        }
    }

    public updateState(state: { modelId?: string, promptId?: string }) {
        if (state.modelId) {
            this.modelSelector.value = state.modelId;
        }
        if (state.promptId) {
            this.promptSelector.value = state.promptId;
        }
    }

    public clearInput() {
        this.textarea.value = '';
    }

    private handleSendMessage() {
        const prompt = this.textarea.value.trim();
        if (prompt) {
            const selectedModelId = this.modelSelector.value;
            const selectedConfig = this.modelConfigs.find(c => c.id === selectedModelId);

            if (!selectedConfig) {
                vscode.postMessage({ command: 'error', payload: 'Please select a valid model from settings.' });
                return;
            }
            
            vscode.postMessage({ command: 'sendMessage', payload: { prompt, config: selectedConfig } });
            this.clearInput();
        }
    }

    private renderModelSelector() {
        this.modelSelector.innerHTML = '';
        const defaultModel = this.modelConfigs.find(c => c.isDefault);
        this.modelConfigs.forEach(config => {
            const option = document.createElement('option');
            option.value = config.id;
            option.textContent = config.name;
            if (defaultModel && config.id === defaultModel.id) {
                option.selected = true;
            }
            this.modelSelector.appendChild(option);
        });
    }

    private renderPromptSelector() {
        this.promptSelector.innerHTML = '<option value="">Select a prompt...</option>';
        this.prompts.forEach(prompt => {
            const option = document.createElement('option');
            option.value = prompt.id;
            option.textContent = prompt.title;
            this.promptSelector.appendChild(option);
        });
    }

}


--------------------------------------------------------------------------------

--- file_path: webview/views/PromptEditorView.ts ---
import { Prompt } from '../../common/types';
import { vscode } from '../vscode';

export class PromptEditorView {
    private element: HTMLElement;
    private prompt: Prompt | null = null;
    private isDirty = false;

    constructor(private readonly parent: HTMLElement) {
        this.element = document.createElement('div');
        this.element.className = 'prompt-editor-view';
        this.parent.appendChild(this.element);
    }

    public show(prompt?: Prompt) {
        this.prompt = prompt ? { ...prompt } : null;
        this.isDirty = false;
        this.render();
        this.addEventListeners();
        this.element.style.display = 'flex';
    }

    public hide() {
        if (this.isDirty) {
            const confirmation = window.confirm('您有未保存的更改，确定要放弃吗？');
            if (!confirmation) {
                return;
            }
        }
        this.element.style.display = 'none';
        this.element.innerHTML = '';
        // Let the extension handle the navigation
        vscode.postMessage({ command: 'cancelPromptEdit' });
    }

    private render() {
        const title = this.prompt?.title ?? '';
        const content = this.prompt?.content ?? '';
        const headerTitle = this.prompt ? `编辑: ${title}` : '新建提示词';

        this.element.innerHTML = `
            <div class="view-header">
                <h3>${headerTitle}</h3>
                <div class="actions">
                    <button id="save-prompt-btn" class="codicon-btn">
                        <i class="codicon codicon-save"></i>
                        <span>保存</span>
                    </button>
                    <button id="cancel-prompt-edit-btn" class="codicon-btn secondary">
                        <i class="codicon codicon-close"></i>
                        <span>取消</span>
                    </button>
                </div>
            </div>
            <div class="prompt-editor-form">
                <div class="form-group">
                    <label for="prompt-title">标题</label>
                    <input type="text" id="prompt-title" value="${title}" required>
                </div>
                <div class="form-group">
                    <label for="prompt-content">内容</label>
                    <textarea id="prompt-content" rows="15">${content}</textarea>
                </div>
            </div>
        `;
    }

    private addEventListeners() {
        const saveBtn = this.element.querySelector('#save-prompt-btn');
        const cancelBtn = this.element.querySelector('#cancel-prompt-edit-btn');
        const titleInput = this.element.querySelector('#prompt-title') as HTMLInputElement;
        const contentTextArea = this.element.querySelector('#prompt-content') as HTMLTextAreaElement;

        const markDirty = () => { this.isDirty = true; };
        titleInput.addEventListener('input', markDirty);
        contentTextArea.addEventListener('input', markDirty);

        if (saveBtn) {
            saveBtn.addEventListener('click', () => {
                if (!titleInput.value.trim()) {
                    vscode.postMessage({ command: 'showError', payload: '标题不能为空。' });
                    return;
                }

                const now = new Date().toISOString();
                const promptToSave: Prompt = {
                    id: this.prompt?.id || `prompt_${Date.now()}`,
                    title: titleInput.value.trim(),
                    content: contentTextArea.value,
                    createdAt: this.prompt?.createdAt || now,
                    updatedAt: now,
                };

                vscode.postMessage({ command: 'savePrompt', payload: promptToSave });
                this.isDirty = false;
            });
        }

        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                this.hide();
            });
        }
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/PromptManagerView.ts ---
import { Prompt } from '../../common/types';
import { vscode } from '../vscode';

export class PromptManagerView {
    private prompts: Prompt[] = [];
    private filteredPrompts: Prompt[] = [];
    private element: HTMLElement;

    constructor(private readonly parent: HTMLElement) {
        this.element = document.createElement('div');
        this.element.className = 'prompt-manager-view';
        this.parent.appendChild(this.element);
        this.render();
        this.addEventListeners();
    }

    public update(prompts: Prompt[]) {
        this.prompts = prompts.sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
        this.filteredPrompts = [...this.prompts];
        this.render();
        this.addEventListeners();
    }

    public getPrompts(): Prompt[] {
        return this.prompts;
    }

    private render() {
        this.element.innerHTML = `
            <div class="view-header">
                <div class="search-bar">
                    <i class="codicon codicon-search"></i>
                    <input type="text" id="prompt-search-input" placeholder="搜索提示词...">
                </div>
                <button id="new-prompt-btn" class="codicon-btn">
                    <i class="codicon codicon-add"></i>
                    <span>新建提示词</span>
                </button>
            </div>
            <div class="prompt-list-container">
                ${this.filteredPrompts.length > 0 ? this.renderList() : this.renderEmptyState()}
            </div>
        `;
    }

    private renderList(): string {
        return `
            <ul class="prompt-list">
                ${this.filteredPrompts.map(prompt => this.renderListItem(prompt)).join('')}
            </ul>
        `;
    }

    private renderListItem(prompt: Prompt): string {
        const summary = prompt.content.substring(0, 100) + (prompt.content.length > 100 ? '...' : '');
        const lastUpdated = new Date(prompt.updatedAt).toLocaleString();

        return `
            <li class="prompt-list-item" data-id="${prompt.id}">
                <div class="prompt-item-main">
                    <div class="prompt-item-title">${prompt.title}</div>
                    <div class="prompt-item-summary">${summary}</div>
                </div>
                <div class="prompt-item-meta">
                    <div class="prompt-item-time">${lastUpdated}</div>
                    <div class="prompt-item-actions">
                        <button class="icon-btn edit-prompt-btn" data-id="${prompt.id}" title="编辑">
                            <i class="codicon codicon-edit"></i>
                        </button>
                        <button class="icon-btn delete-prompt-btn" data-id="${prompt.id}" title="删除">
                            <i class="codicon codicon-trash"></i>
                        </button>
                    </div>
                </div>
            </li>
        `;
    }

    private renderEmptyState(): string {
        return `
            <div class="empty-state">
                <p>您还没有任何提示词模板，点击“新建提示词”来创建第一个吧！</p>
                <button id="new-prompt-btn-empty" class="highlighted-btn">新建提示词</button>
            </div>
        `;
    }

    private addEventListeners() {
        // New prompt button
        const newPromptBtn = this.element.querySelector('#new-prompt-btn');
        if (newPromptBtn) {
            newPromptBtn.addEventListener('click', () => {
                vscode.postMessage({ command: 'newPrompt' });
            });
        }
        const newPromptBtnEmpty = this.element.querySelector('#new-prompt-btn-empty');
        if (newPromptBtnEmpty) {
            newPromptBtnEmpty.addEventListener('click', () => {
                vscode.postMessage({ command: 'newPrompt' });
            });
        }

        // Search input
        const searchInput = this.element.querySelector('#prompt-search-input') as HTMLInputElement;
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                const searchTerm = (e.target as HTMLInputElement).value.toLowerCase();
                this.filteredPrompts = this.prompts.filter(p => 
                    p.title.toLowerCase().includes(searchTerm) || 
                    p.content.toLowerCase().includes(searchTerm)
                );
                this.render();
                this.addEventListeners();
            });
        }

        // List item clicks
        this.element.querySelectorAll('.prompt-list-item').forEach(item => {
            item.addEventListener('click', (e) => {
                const target = e.target as HTMLElement;
                // Don't trigger edit if clicking on a button
                if (!target.closest('button')) {
                    const promptId = item.getAttribute('data-id');
                    if (promptId) {
                        vscode.postMessage({ command: 'editPrompt', payload: { id: promptId } });
                    }
                }
            });
        });

        // Edit buttons
        this.element.querySelectorAll('.edit-prompt-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const promptId = (btn as HTMLElement).dataset.id;
                if (promptId) {
                    vscode.postMessage({ command: 'editPrompt', payload: { id: promptId } });
                }
            });
        });

        // Delete buttons
        this.element.querySelectorAll('.delete-prompt-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const promptId = (btn as HTMLElement).dataset.id;
                if (promptId) {
                    vscode.postMessage({ command: 'deletePrompt', payload: { id: promptId } });
                }
            });
        });
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/SettingsView.ts ---
import { ModelConfig } from "../../common/types";
import { vscode } from "../vscode";

export class SettingsView {
    private configs: ModelConfig[] = [];

    constructor(private readonly parent: HTMLElement) {
        this.render();
        this.setupEventListeners();
    }

    public setModelConfigs(configs: ModelConfig[]) {
        this.configs = configs;
        this.render();
    }

    public getModelConfigs(): ModelConfig[] {
        return this.configs;
    }

    private setupEventListeners() {
        this.parent.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            const button = target.closest('button');
            if (!button) return;

            const id = button.dataset.id;
            if (button.matches('.btn-add-model')) {
                this.addEmptyConfigForm();
            } else if (button.matches('.btn-save-model')) {
                this.saveConfig(id);
            } else if (button.matches('.btn-delete-model')) {
                this.deleteConfig(id);
            } else if (button.matches('.btn-set-default')) {
                this.setDefault(id);
            }
        });
    }

    private addEmptyConfigForm() {
        const newConfig: ModelConfig = { 
            id: `new-${Date.now()}`, 
            name: '', 
            baseUrl: '', 
            apiKey: '', 
            modelId: '',
            isDefault: this.configs.length === 0 
        };
        this.configs.push(newConfig);
        this.render();
    }

    private saveAllConfigs() {
        vscode.postMessage({ command: 'saveModelConfigs', payload: this.configs });
    }

    private setDefault(id?: string) {
        if (!id) return;
        this.configs.forEach(c => c.isDefault = c.id === id);
        this.saveAllConfigs();
        this.render();
    }

    private saveConfig(id?: string) {
        if (!id) return;
        const form = this.parent.querySelector(`#config-form-${id}`) as HTMLFormElement;
        if (!form) return;

        const name = (form.querySelector('input[name="name"]') as HTMLInputElement).value;
        const baseUrl = (form.querySelector('input[name="baseUrl"]') as HTMLInputElement).value;
        const apiKey = (form.querySelector('input[name="apiKey"]') as HTMLInputElement).value;
        const modelId = (form.querySelector('input[name="modelId"]') as HTMLInputElement).value;

        const index = this.configs.findIndex(c => c.id === id);
        if (index === -1) return;

        const isNew = id.startsWith('new-');
        const newId = isNew ? `model-${Date.now()}` : id;
        
        this.configs[index] = { ...this.configs[index], id: newId, name, baseUrl, apiKey, modelId };
        
        this.saveAllConfigs();
    }

    private deleteConfig(id?: string) {
        if (!id) return;
        this.configs = this.configs.filter(c => c.id !== id);
        // If the deleted model was the default, make the first one default
        if (this.configs.length > 0 && !this.configs.some(c => c.isDefault)) {
            this.configs[0].isDefault = true;
        }
        this.saveAllConfigs();
    }

    private render() {
        this.parent.innerHTML = `
            <div class="settings-container">
                <div class="view-header">
                    <h2>Model Settings</h2>
                    <button class="btn-add-model add-btn" title="Add new model configuration">
                        <i class="codicon codicon-add"></i>
                    </button>
                </div>
                <div id="model-configs-list">
                    ${this.configs.map(config => this.renderConfigForm(config)).join('')}
                </div>
            </div>
        `;
    }

    private renderConfigForm(config: ModelConfig): string {
        return `
            <form class="config-form" id="config-form-${config.id}" data-id="${config.id}">
                <div class="form-header">
                    <strong class="form-title">${config.name || 'New Model'}</strong>
                    ${config.isDefault ? '<span class="default-badge">Default</span>' : ''}
                </div>
                <div class="form-group">
                    <label for="name-${config.id}">Model Name</label>
                    <input type="text" id="name-${config.id}" name="name" placeholder="e.g., GPT-4o" value="${config.name}">
                </div>
                <div class="form-group">
                    <label for="baseUrl-${config.id}">Base URL</label>
                    <input type="text" id="baseUrl-${config.id}" name="baseUrl" placeholder="https://api.openai.com/v1" value="${config.baseUrl}">
                </div>
                <div class="form-group">
                    <label for="apiKey-${config.id}">API Key</label>
                    <input type="password" id="apiKey-${config.id}" name="apiKey" placeholder="sk-..." value="${config.apiKey}">
                </div>
                <div class="form-group">
                    <label for="modelId-${config.id}">Model ID</label>
                    <input type="text" id="modelId-${config.id}" name="modelId" placeholder="gpt-4o" value="${config.modelId}">
                </div>
                <div class="form-actions">
                    <button type="button" class="btn-save-model" data-id="${config.id}">Save</button>
                    <button type="button" class="btn-delete-model" data-id="${config.id}">Delete</button>
                    ${!config.isDefault ? `<button type="button" class="btn-set-default" data-id="${config.id}">Set as Default</button>` : ''}
                </div>
            </form>
        `;
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/views/WelcomeView.ts ---
export class WelcomeView {
    constructor(private readonly parent: HTMLElement) {
        this.parent.innerHTML = this.render();
    }

    private render(): string {
        return `
            <div class="welcome-container">
                <h2>Welcome to CodeWiki</h2>
                <p>Your intelligent assistant for software design.</p>
                <button id="btn-new-chat">New Chat</button>
            </div>
        `;
    }
}


--------------------------------------------------------------------------------

--- file_path: webview/vscode.ts ---
import type { PostMessage } from '../common/types';

/**
 * A typed wrapper around the VS Code API that is exposed to the webview.
 */
interface VsCodeApi {
    postMessage(message: PostMessage): void;
    getState(): any;
    setState(newState: any): void;
}

declare const acquireVsCodeApi: () => VsCodeApi;

export const vscode = acquireVsCodeApi();


--------------------------------------------------------------------------------
