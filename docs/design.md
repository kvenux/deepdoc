# CodeWiki IDE 插件需求规格 (V1.5)

## 1. 工具概述

CodeWiki 是一个旨在将软件设计文档的生成和维护自动化的 IDE 插件。

**核心功能:**

1.  **自动生成文档**: 扫描代码库（分析依赖、调用链、类关系等），自动为服务或组件生成设计文档。
2.  **代码与设计的双向追溯**: 提供一个交互图，方便在代码和设计文档之间来回跳转和查看。
3.  **自然语言问答**: 支持用自然语言提问（例如，“哪个 API 修改了用户信息？”），插件会在图中高亮显示相关的代码或设计元素。

## 2. 插件界面与核心功能

### 2.1. 侧边栏布局与交互

插件在 IDE 侧边栏提供一个名为 “CodeWiki” 的主视图。设计目标是简洁、直观、响应迅速。

* **顶部图标栏**: 视图顶部设有一条水平的图标工具栏，包含四个核心功能入口：**对话窗口**、**对话管理**、**提示词管理** 和 **设置**。这些图标均采用 VS Code 的 Codicon 图标库以保证风格统一。
* **视图切换**: 点击任一图标，下方的主内容区会平滑地切换到对应的功能面板。当前激活的图标会高亮显示，为用户提供清晰的视觉焦点。
* **欢迎页面 (默认态)**:
    * 首次启动或未选择任何功能时，内容区会显示一个静态的欢迎页面。
    * 此页面会简要介绍 CodeWiki 的核心功能（如“开启您的第一个智能对话”、“管理您的提示词模板”），并提供快速开始的按钮（如“新建对话”），引导用户进行初次操作，提升上手体验。

### 2.2. 对话窗口

作为用户与大模型交互的核心界面，设计重点在于提供沉浸式、无干扰的交流体验。

* **消息布局与样式**:
    * **文档式流布局**: 每条消息均占满窗口宽度，消息之间由一条`1px`的、颜色较淡的分隔线（`--vscode-editorGroup-border`）区隔，营造出连贯的文档阅读感。
    * **呼吸空间**: 消息块上下保留适度的内边距（`padding`），确保文本易于阅读，不显拥挤。
* **消息悬浮工具栏 (Hover Toolbar)**:
    * 当鼠标悬停在任一消息块上时，其右上角会平滑浮现一个半透明的快捷工具栏。
    * **模型消息**: 工具栏显示“复制 (Copy)”和“重新生成 (Regenerate)”图标。
    * **用户消息**: 工具栏显示“复制 (Copy)”和“编辑 (Edit)”图标。点击“编辑”将使该消息块变为一个与底部功能一致的编辑区。
* **底部消息编辑区 (Sticky Input)**:
    * **固定布局**: 该区域固定在窗口最底部，无论聊天记录多长，用户都无需滚动即可随时输入。
    * **动态高度**: 输入框为多行文本域（Textarea），高度会随着用户输入内容的增多而自动增长（例如，从2行到最高10行），超出后则出现内部滚动条。
    * **智能提示**: 输入框内默认显示引导性提示文字（Hint），如：“输入消息，或从下拉菜单选择提示词...”。
    * **操作按钮**: 位于编辑区右下角，包含：
        * **发送按钮**: 用于提交请求。
        * **最大化编辑按钮**: 在“发送”按钮旁，设有一个“最大化”图标按钮（建议使用 `codicon-screen-full`）。其工具提示为“最大化编辑”。此功能旨在解决底部编辑区空间有限，不便于编辑长篇或复杂提示词的问题。
* **专注编辑模式 (全屏 Webview)**:
    * **触发与呈现**: 点击“最大化编辑”按钮后，会在 IDE 的主编辑区打开一个全屏的 Webview 视图。此视图是侧边栏底部输入区的 **“镜像”**，专为沉浸式编辑设计。
    * **双向同步**: 专注编辑视图与侧边栏底部输入区的内容 **必须时刻保持严格的双向同步**。在一个地方的任何修改（包括文本输入、选择提示词、切换模型），都应立即无延迟地反映在另一个视图上。
    * **保留完整功能**: 此视图内完整保留了下方的 **快捷功能栏（提示词、模型选择）** 和 **发送按钮**，功能与侧边栏完全一致。
    * **退出模式**: 在专注编辑视图中，原“最大化”按钮的位置会变为“最小化”图标按钮（建议使用 `codicon-screen-normal`），工具提示为“恢复至侧边栏”。点击后将关闭此 Webview 视图，焦点自动返回侧边栏。
    * **同步发送**: 无论从侧边栏还是专注编辑视图点击“发送”，两个视图的输入框内容都应被同时清空。
* **快捷功能栏**:
    * **提示词模板**: 提供一个下拉菜单。用户点击后，会展示所有可用的提示词模板列表。选择任一模板，其内容将立即加载到输入框中。
    * **模型选择**: 一个紧凑的下拉菜单，用以切换当前对话所使用的模型。
* **通用标签处理**:
    * **识别与渲染**: 插件能自动识别并处理输入内容中的任何 XML 风格的标签（如 `<context>`, `<code>`, `<file_content>` 等）。这些标签块默认会渲染为一个背景色略有不同的、可点击的“胶囊”(Pill)样式，以实现折叠效果。
    * **展开与编辑**: 用户可点击胶囊，它会“展开”为包含完整内容的、可编辑的纯文本块。这方便用户在发送前对上下文进行微调。
* **响应状态处理**:
    * **请求失败**: 如果 API 请求失败，原先显示加载动画的区域将变为一个醒目的错误提示块（如使用红色文字 `--vscode-errorForeground`）。提示信息需包含关键错误说明及错误码。同时，用户的原始消息会自动退回到底部编辑区，方便一键重试。
    * **用户中断**: 当用户在流式响应期间点击“停止”按钮，内容流将立即中止。已接收的部分内容会被保留在消息区，并在末尾自动附加一个清晰的标记，如 `(已停止)`，以表明该次响应并非完整。如果用户对此消息选择“重新生成”，这部分被中断的内容将被新的完整响应覆盖。

### 2.3. 对话管理

* **列表项设计**:
    * 采用 Flexbox 布局，左侧为对话首句摘要（主标题），占据大部分宽度；右侧为对话发起时间（如“昨天 15:30”或“5分钟前”），字体颜色更浅。
    * **悬浮与选中**: 鼠标悬停（Hover）时，列表项背景色会变为 VS Code 标准的悬浮高亮色（`--vscode-list-hoverBackground`）。当前打开的对话所对应的列表项，则拥有更醒目的选中背景色（`--vscode-list-activeSelectionBackground`）。
* **悬浮操作**:
    * 当鼠标悬停时，列表项右侧会平滑（fade in）显示“删除”和“导出”两个图标按钮，避免常驻显示造成的视觉干扰。

### 2.4. 提示词管理

此功能模块为用户提供一个强大、易用的界面，用于创建、组织和复用高质量的提示词模板。

* **主列表视图**:
    * **头部操作栏**: 列表顶端设有一个操作栏，包含一个醒目的 **“新建提示词”** 按钮和一个 **搜索框**，方便用户快速创建或在大量模板中进行筛选。
    * **列表项设计**: 列表项交互与“对话管理”保持一致，确保体验统一。
        * **布局**: 左侧为模板的 **标题（Title）** 和 **内容概要**，右侧为 **创建或最后修改时间**。
        * **悬浮操作**: 鼠标悬停时，右侧平滑浮现 **“编辑”** 和 **“删除”** 两个图标按钮。
    * **空状态引导**: 当列表中没有任何提示词时，将显示引导性文字，如：“您还没有任何提示词模板，点击‘新建提示词’来创建第一个吧！”，并高亮“新建提示词”按钮。

* **创建与编辑流程**:
    * **新建模板**: 点击“新建提示词”按钮后，IDE 的主编辑区会立即打开一个新标签页，标题为“无标题提示词”，并展现模板编辑界面。
    * **编辑模板**: 点击列表中任一模板的“编辑”按钮，或直接点击该列表项，都会在主编辑区打开一个以该模板标题命名的标签页，并加载其已有内容供用户修改。

* **模板编辑界面 (主编辑区标签页)**:
    * **结构化表单**:
        * **标题 (Title)**: 顶置一个单行输入框，用于定义模板的标题。此标题将作为在对话窗口 `@` 唤出时的匹配和显示名称，为 **必填项**。
        * **模板内容 (Content)**: 一个支持语法高亮（可选）的大尺寸文本域，用于编写和设计提示词的主体内容。
        * **通用标签支持**: 在此文本域中，用户输入的任何 XML 风格的标签（如 `<code>`）都将自动支持折叠和展开，方便处理和预览包含大量上下文的复杂提示词。
    * **操作按钮**: 编辑界面的右上角会固定显示 **“保存”** 和 **“取消”** 两个按钮。
        * **保存**: 点击后，将校验标题是否填写，然后保存或更新模板数据。保存成功后，侧边栏的提示词列表将 **自动刷新** 以同步最新内容。标签页保持打开状态，方便用户继续调整。
        * **取消**: 点击后，如果内容有未保存的更改，会弹出确认对话框（“您有未保存的更改，确定要放弃吗？”）防止误操作。确认后，将关闭此标签页。

### 2.5. 设置

* **模型配置字段**:
    * `模型名`: 用于在“对话窗口”的模型选择下拉菜单中显示的名称。
    * `Base URL`: 模型服务的 API 端点。
    * `API Key`: 用于请求验证的密钥。
    * `Model ID`: 模型在服务端的具体标识符。
* **存储方式**:
    * `API Key` 等配置信息将以 **明文形式** 存储在 VS Code 的全局状态（`globalState`）或插件的专属配置文件中。**注意：此方案不提供加密保护。**

## 3. 模型交互与非功能性需求

### 3.1. 模型对话交互

* **流式响应与中断**:
    * 点击“发送”按钮后，该按钮应立即变为“停止”按钮。
    * 模型返回的内容必须以流式（Streaming）方式逐字或逐句显示。
    * 用户主动点击“停止”按钮中断响应时，已接收的部分内容应予以保留，并附加一个明确的 `(已停止)` 标记。如果用户选择重新生成，此部分内容将被新的响应替换。
* **消息操作**:
    * 当鼠标悬停在模型返回的消息块上时，应显示“复制 (Copy)”按钮。
* **历史消息编辑**:
    * 用户发出的历史消息支持 **原地重新编辑**。
* **错误处理与重试**:
    * 当请求失败时，系统必须提供清晰的错误反馈（包括错误码），并自动将用户的输入内容退回至编辑区，方便用户修改并一键重试。

### 3.2. 非功能性需求

* **性能**: 界面操作响应迅速，无卡顿。调用大模型等耗时操作必须采用异步处理，不得阻塞 IDE 主线程。
* **易用性**: 界面设计直观简洁，确保新用户无需查阅文档即可快速上手。
* **稳定性**: 插件自身运行稳定，不能导致崩溃，也不能影响 IDE 的性能和稳定性。
* **一致性**: 插件的整体 UI 风格应与 VS Code 等主流 IDE 保持高度一致，使其看起来像原生功能。

---

## 4. 大模型对话功能详细设计 (V1.0)

本章节深入探讨 CodeWiki 插件的技术实现方案，确保与 V1.5 版本定义的丰富交互体验和健壮性要求完全对齐。

### 4.1. 技术选型

* **开发语言**: **TypeScript**。
* **核心框架**: **VS Code Extension API**。
* **UI 渲染**:
    * **主界面**: **单一的 WebviewView**。整个侧边栏的主体功能区（欢迎页、对话、历史、提示词、设置）将全部在一个 Webview 中通过前端路由逻辑进行渲染和切换，以实现最流畅的视图切换效果。
    * **UI 组件库**: **VS Code Webview UI Toolkit**，用于构建所有交互元素。
    * **CSS 框架**: 轻量级 CSS 或直接使用 Flexbox/Grid 结合 VS Code 主题变量（`--vscode-*`）进行精细布局。

### 4.2. 架构设计

插件采用 **Extension Host + 单一 WebviewView** 的高度集成架构。

* **Extension Host (扩展主机进程)**: 插件的后端逻辑核心。
    * **职责**:
        1.  注册一个 `WebviewViewProvider`，用于在侧边栏创建并管理唯一的 Webview 实例。
        2.  作为数据中心，通过 `globalState` 管理对话历史、提示词和配置信息。
        3.  作为服务代理，处理所有对大模型后端的 API 请求（包括流式响应和请求中断）。
        4.  监听并响应来自 Webview 的所有消息（如发送消息、切换页面、增删改查数据等）。
        5.  执行 VS Code 原生操作，如根据 Webview 请求打开新的编辑器标签（`vscode.workspace.openTextDocument`）。

* **WebviewView (前端 UI 核心)**:
    * **职责**:
        1.  实现一个小型的前端应用（类似 SPA）。内部包含一个简单的路由，根据从 Extension Host 接收到的指令或用户的点击操作，来渲染不同的“页面”（对话、历史、设置等）。
        2.  使用 HTML/CSS 精确实现 V1.5 中定义的所有 UI 布局和交互动效。
        3.  将所有用户操作（点击、输入）转换为消息，通过 `acquireVsCodeApi().postMessage()` 发送给 Extension Host 处理。

### 4.3. 核心模块实现

#### 4.3.1. 侧边栏视图实现

* 在 `package.json` 中，仅注册一个 `webviewView`，其 `id` 为 `codewiki.mainView`。
* 实现 `vscode.WebviewViewProvider` 接口，其核心是 `resolveWebviewView` 方法。此方法在插件启动时被调用，负责初始化 Webview 的 HTML 内容。
* Webview 的初始 HTML 将包含顶部图标栏和内容区的基本骨架。JavaScript 逻辑将负责根据初始状态（或用户操作）渲染“欢迎页面”。

#### 4.3.2. 前端 UI 交互实现 (Webview 内)

* **通用标签处理**:
    * **识别逻辑**: 在 Webview 的 JavaScript 中，使用正则表达式 `/<(\w+[\w-]*)[^>]*>([\s\S]*?)<\/\1>/g` 来匹配所有成对的 XML 风格标签。
    * **动态渲染**: 匹配到的内容将被替换为一个 `div` 元素（渲染为“胶囊”样式）。该 `div` 通过 `data-*` 属性存储原始的标签名和完整内容。
    * **交互实现**: 为该 `div` 绑定 `click` 事件。点击时，根据当前状态在“胶囊”视图和包含完整可编辑内容的 `<textarea>` 视图之间进行切换。
* **状态处理逻辑**:
    * **失败状态**: Webview 中需实现一个专门监听函数，用于处理来自 Extension Host 的 `requestFailed` 消息。收到消息后，移除加载动画，显示错误信息，并将原始消息恢复至编辑区。
    * **中断状态**: Webview 中需实现对 `streamStopped` 消息的监听。收到后，在当前正在接收内容的消息块末尾追加一个 `<span>(已停止)</span>` 元素，并将底部“停止”按钮恢复为“发送”。
    * **重新生成**: 用户点击“重新生成”后，Webview 会发送一个包含原始提示词的请求。当收到来自后端的**第一块新数据流**时，JavaScript 会先清空目标消息块的现有内容（无论是完整的还是中断的），然后再开始追加新内容。

#### 4.3.3. 模型服务交互与错误处理 (Extension Host 内)

* **请求封装**: 对大模型的 `fetch` 调用必须被封装在 `try...catch` 块中，并使用 `AbortController` 来管理请求生命周期。
* **异常捕获**: `catch (error)` 块需要区分不同类型的错误：
    * **用户中断**: 通过判断 `error.name === 'AbortError'` 来识别。若为真，则向 Webview 发送 `postMessage({ command: 'streamStopped' })`。
    * **其他失败**: 对于网络错误、服务器错误等，提取错误信息和状态码，并通过 `postMessage({ command: 'requestFailed', payload: {...} })` 将包含错误详情和原始消息的数据发往 Webview。
* **成功路径**: 在 `try` 块中，处理成功的流式响应，并通过 `postMessage` 逐块将数据发送到 Webview。

#### 4.3.4. 数据存储与状态管理

* **数据源**: **Extension Host 是唯一的数据源**。Webview 本身不存储任何持久化数据，它所需的所有数据（历史、配置等）都通过 `postMessage` 从 Extension Host 按需请求。
* **存储机制**:
    * 所有数据，包括对话、提示词以及包含 `API Key` 的模型配置，均使用 `context.globalState` 进行 **明文** 存储。
    * **示例**: 当 Webview 需要保存一个新模型配置时，它会 `postMessage({ command: 'saveModelConfig', payload: {...} })`。Extension Host 接收到后，调用 `context.globalState.update('codewiki_model_configs', newConfigs)` 来完成存储。

## 5. 代码实现规划与代码仓结构

本章节基于 V1.5 的需求和 V1.0 的技术选型，为 CodeWiki 插件的开发提供一个具体的、可执行的代码结构蓝图和开发路线图。

### 5.1. 开发顺序与里程碑

为了确保项目平稳、高效地推进，建议采用以下分阶段的开发顺序：

1.  **阶段一：项目骨架与后端核心搭建**
    * **目标**: 初始化 VS Code 插件项目，建立 Extension Host 与 Webview 之间的基本通信，并实现核心的数据管理。
    * **步骤**:
        1.  使用 `yo code` 脚手架创建 TypeScript 插件项目。
        2.  **定义通信契约**: 优先创建 `src/common/types.ts`，定义所有 `postMessage` 的消息类型和共享的数据结构（如 `Conversation`, `ModelConfig`）。这是后续所有开发的基础。
        3.  **实现 `CodeWikiViewProvider`**: 在 `src/extension/CodeWikiViewProvider.ts` 中实现 `resolveWebviewView` 方法，加载一个最简单的 "Hello World" HTML。
        4.  **实现 `StateManager`**: 在 `src/extension/StateManager.ts` 中实现对 `globalState` 的基本封装，提供增、删、改、查接口。
        5.  **建立双向通信**: 在 Provider 中设置消息监听器，并让 Webview 在启动时向 Extension Host 发送一条 `ready` 消息，Extension Host 收到后返回初始数据（如空对话列表）。

2.  **阶段二：UI 框架与核心视图实现**
    * **目标**: 搭建 Webview 内的前端应用框架，并优先完成最核心的“对话窗口”界面。
    * **步骤**:
        1.  **前端路由**: 在 `src/webview/main.ts` 中实现一个简单的路由，能够根据点击顶部图标栏的动作切换不同的视图（先用占位符 `div` 即可）。
        2.  **实现对话窗口 UI**: 重点开发 `src/webview/views/ChatView.ts`。静态实现消息布局、底部固定输入框、模型选择下拉菜单等。
        3.  **消息发送与接收**: 实现从输入框发送消息到 Extension Host，并能接收从 Host 发来的流式响应，逐字渲染到界面上。此时可先用 `setTimeout` 模拟流式数据。

3.  **阶段三：打通大模型服务**
    * **目标**: 对接真实的大模型 API，实现完整的对话、中断、重试和错误处理流程。
    * **步骤**:
        1.  **实现 `LLMService`**: 在 `src/extension/LLMService.ts` 中，使用 `fetch` 和 `AbortController` 实现对流式 API 的请求，并能正确处理中断和错误。
        2.  **集成到 Provider**: 在 `CodeWikiViewProvider` 中，将收到的 Webview 消息转发给 `LLMService` 处理，并将服务返回的数据流、错误或中断状态转发回 Webview。
        3.  **完善 Webview 状态处理**: 在 `ChatView.ts` 中，根据从 Host 收到的 `requestFailed` 和 `streamStopped` 消息，精确实现 V1.5 需求中定义的 UI 反馈。

4.  **阶段四：完善其余功能模块**
    * **目标**: 完成对话管理、提示词管理和设置功能的开发。
    * **步骤**:
        1.  **实现设置页面**: 开发 `SettingsView.ts` 和对应的 Host 端逻辑，实现模型配置的增删改查和持久化存储。
        2.  **实现对话/提示词管理**: 开发 `ChatHistoryView.ts` 和 `PromptManagerView.ts`。由于两者交互相似，可复用大量列表渲染和操作逻辑。实现加载、删除、导出（对话）和打开编辑器（提示词）功能。
        3.  **实现通用标签处理**: 在 Webview 中，使用正则表达式和事件委托实现 `<tag>` 的“胶囊”化渲染、点击展开/折叠以及内容编辑功能。

5.  **阶段五：优化与润色**
    * **目标**: 提升用户体验和插件稳定性。
    * **步骤**:
        1.  **UI/UX 优化**: 细调 CSS 动画（如悬浮工具栏的淡入淡出）、边距、颜色，确保与 VS Code 风格完美融合。
        2.  **性能测试**: 检查长对话列表下的性能，确保异步操作不会阻塞 UI。
        3.  **代码重构与文档**: 清理代码，添加必要的注释，完善 README 文档。

### 5.2. 代码仓结构详解

项目 `src` 目录将采用清晰的三层结构：`extension` (后端逻辑), `webview` (前端 UI), `common` (共享类型)，以实现关注点分离。

```plaintext
.
├── package.json              # 插件清单文件，定义入口、命令和视图
├── tsconfig.json             # TypeScript 编译配置
├── .vscodeignore             # 定义打包时忽略的文件
└── src/                      # 源代码根目录
    ├── common/               # 存放 Extension Host 和 Webview 共用的代码
    │   └── types.ts          # 核心：定义所有通信消息类型和数据模型 (Message, Config, etc.)
    │
    ├── extension/            # Extension Host (后端) 的所有代码
    │   ├── extension.ts      # 插件激活入口 (activate, deactivate 函数)
    │   ├── CodeWikiViewProvider.ts # 核心：实现 WebviewViewProvider，管理 Webview 生命周期和消息收发
    │   ├── StateManager.ts   # 数据状态管理器，封装 globalState 的所有读写操作
    │   └── LLMService.ts     # 大模型服务代理，负责 API 请求、流式处理和错误处理
    │
    └── webview/              # Webview (前端) 的所有代码，构成一个小型 SPA
        ├── main.ts           # 前端应用入口，负责初始化、路由和消息监听
        ├── router.ts         # 一个简单的客户端路由器，用于切换主视图
        ├── vscode.ts         # 封装 acquireVsCodeApi，提供类型安全的 postMessage 方法
        │
        ├── views/            # 存放各个主功能视图的组件
        │   ├── App.ts        # 根组件，包含顶部图标栏和主内容区
        │   ├── WelcomeView.ts # 欢迎页面组件
        │   ├── ChatView.ts   # 对话窗口组件，处理消息流、输入框、工具栏等复杂交互
        │   ├── ChatHistoryView.ts # 对话管理列表组件
        │   ├── PromptManagerView.ts # 提示词管理列表组件
        │   └── SettingsView.ts # 设置页面组件
        │
        ├── components/       # 存放可复用的 UI 小组件
        │   ├── MessageBlock.ts  # 单条消息块组件（用户或模型的）
        │   └── Pill.ts          # 可折叠的 XML 风格标签（“胶囊”）组件
        │
        └── css/              # 存放所有样式文件
            ├── main.css      # 全局样式，VS Code 主题变量定义
            └── components.css # 各组件的专属样式

```

### 5.3. 各文件核心职责描述

#### 5.3.1. 根目录

* `package.json`:
    * **职责**: 声明插件的元数据。
    * **关键配置**: 在 `contributes.viewsContainers.activitybar` 中定义 "CodeWiki" 图标，并在 `contributes.views` 中注册一个 `id` 为 `codewiki.mainView` 的 `webviewView`。`main` 字段指向 `dist/extension.js`。

#### 5.3.2. `src/common`

* `types.ts`:
    * **职责**: **项目中最关键的文件之一**。定义 Extension Host 与 Webview 之间所有通信的 TypeScript 接口和类型，确保类型安全。
    * **内容示例**: `interface PostMessage { command: string; payload: any; }`, `type ModelConfig = { ... }`, `type ChatMessage = { ... }`, `type Conversation = { ... }` 等。

#### 5.3.3. `src/extension` (后端)

* `extension.ts`:
    * **职责**: 插件的入口和出口。
    * `activate()`: 注册 `CodeWikiViewProvider`。
    * `deactivate()`: 执行清理工作。
* `CodeWikiViewProvider.ts`:
    * **职责**: **后端的核心枢纽**。
    * 管理 Webview 的创建、销毁和 HTML 内容设置。
    * 实现一个大型的 `switch (message.command)` 结构，作为消息路由器，处理所有来自 Webview 的请求（如发送消息、保存设置、删除历史等）。
    * 调用 `StateManager` 和 `LLMService` 来完成具体任务。
    * 通过 `webview.postMessage()` 将结果、数据流或错误状态发送回前端。
* `StateManager.ts`:
    * **职责**: **唯一的数据源**。作为 `globalState` 的抽象层。
    * 提供 `getConversations()`, `saveConversation(id, data)`, `deleteConversation(id)`, `getModelConfigs()`, `saveModelConfigs(configs)` 等方法。
    * 所有方法都是异步的，返回 `Promise`。
* `LLMService.ts`:
    * **职责**: 负责所有外部 API 通信。
    * 提供一个核心方法，如 `getCompletion(prompt, options)`，该方法接收一个 `AbortController.signal` 用于中断。
    * 内部处理 `fetch` 的流式响应 (`ReadableStream`)，并将数据块、完成信号或捕获到的错误通过回调或事件发射器传递出去。

#### 5.3.4. `src/webview` (前端)

* `main.ts`:
    * **职责**: 前端应用的启动器。
    * 获取 VS Code API 实例 (`acquireVsCodeApi`)。
    * 初始化根组件 `App`。
    * 设置一个全局的消息监听器 (`window.addEventListener('message', ...)`), 将收到的消息分发给相应的处理器或状态管理器。
* `router.ts`:
    * **职责**: 实现视图切换。
    * 提供 `MapsTo(viewName)` 方法，该方法通过隐藏/显示不同的视图 `div` 来模拟页面跳转，实现 V1.5 要求的“平滑切换”。
* `vscode.ts`:
    * **职责**: 提供一个类型安全的 `postMessage` 封装。
    * 导出一个 `vscodeApi` 对象，其上的 `postMessage` 方法的参数类型由 `common/types.ts` 定义，避免手写字符串 `command` 导致的错误。
* `views/*.ts`:
    * **职责**: 各个功能页面的 UI 和交互逻辑。例如，`ChatView.ts` 会包含渲染消息列表、处理 `@` 弹出菜单、监听输入框变化、点击发送/停止按钮等所有逻辑。
* `components/*.ts`:
    * **职责**: 可复用的 UI 元素。例如，`Pill.ts` 会封装创建“胶囊”`div`、存储原始数据以及处理点击后切换为 `<textarea>` 的全部逻辑。
* `css/*.css`:
    * **职责**: 定义插件的视觉表现。大量使用 `--vscode-*` 变量（如 `--vscode-sideBar-background`, `--vscode-editor-foreground`, `--vscode-list-hoverBackground`）来确保 UI 与 IDE 风格的统一性。

