目前我们已经有生成模块的能力了。
现在需要基于模块的详细设计，进行总体文档的生成。
总体文档的章节：

1. 概述
讲清楚本服务或组件在整个系统中的定位、核心职责与价值。描述其与上下游系统或组件的核心交互关系。

2. 功能清单
基于架构、系统设计拆解出的功能进行全量描述。
功能清单	功能说明	优先级
创建主机	基于网络与规格元数据，注入配置、下载镜像、配置网络、构建主机	高
删除主机	删除主机对应的资源与主机实例	高
关闭主机	关机	中
...	...	...


3. 实现模型
3.1 上下文视图
3.2 服务/组件总体架构
3.2.1 服务/组件架构视图
使用高层级的框图展示服务内部的核心模块构成，以及模块之间的依赖和交互关系。
3.2 模块详细设计
3.2.1 XXX模块详细设计（包括模块介绍、功能描述、代码结构、关键算法逻辑、设计模式、关键数据结构等）
这章节包含所有模块的详细设计
3.3 软件分层设计 (可选)

4. 接口设计
4.1 总体设计
4.2 接口清单
5. 数据模型
5.1 设计目标
5.2 模型实现（ER图）
6. 算法实现
6.1 设计目标
6.2 算法实现
7 交互模型
7.1 设计目标
7.2 模型实现

每个关键要素都需要，各个模块的详细设计，结合现有的tools，设计整体文档生成的agent

要在全量智能体先要进行规划，依据当前项目的结构，调用大模型分析当前项目语言是什么，项目有哪些模块要去分析；
文件树、文件清单等tools要考虑结合语言进行过滤，每个语言单独定一个过滤文件，包括include、exclude的列表，还有通用的exclude列表
相关的中间内容都要保存，保存文件名需要包括agent、model、时间
在分析模块详细设计文档的时候，根据最大能分析的token（给一个全局参数）去选择不同的策略，小于token max时候，采用runActionPrompt，如果大于这个值，就调用runMapReduceAgent


先生成设计文档，先不给代码；


好的，这个需求非常棒，是 `CodeWiki` 项目从“工具集”走向“解决方案”的关键一步。它要求我们构建一个更高层次的、有规划能力的“元智能体”（meta-agent），这个智能体能够编排现有的能力（如 `runMapReduceAgent` 和 `runActionPrompt`）来完成一个复杂的、多步骤的文档生成任务。

我将按照您的思路，分阶段实现这个功能。

### 核心设计思路

1.  **引入新的 Agent 类型**: 我们将在 `.codewiki` 目录中支持一种新的 YAML 文件格式，专门用于“总体设计文档生成”。这种 YAML 将定义三个核心阶段：`planning_prompt`（规划）, `module_analysis_prompt`（模块分析，这将是 `map-reduce` 类型的模板）, 和 `synthesis_prompt`（综合）。
2.  **创建新的顶层编排器 (`documentationAgent.ts`)**: 这个编排器将负责执行“规划 -> 逐一分析 -> 综合”的完整流程。
3.  **语言感知的项目分析**: 创建一个 `projectStructureAnalyzer.ts` 模块，用于：
    *   根据语言（如 TypeScript, Python 等）过滤文件。
    *   识别项目的主要语言。
    *   计算目录的 Token 数量，为后续的策略选择（`runActionPrompt` vs `runMapReduceAgent`）做准备。
4.  **改造现有模块以支持编排**:
    *   修改 `agentOrchestrator.ts` 中的 `runMapReduceAgent`，使其不仅能将结果写入文件，还能将结果作为字符串返回，以便上层编排器使用。
5.  **更新入口点 (`extension.ts`)**: 修改 `codewiki.runAgent` 命令，使其能识别并启动新的“总体设计文档”Agent。
6.  **文件和状态管理**: 所有中间产物（规划结果、各模块分析文档）和最终产物都将保存在一个以时间戳命名的独立目录中，方便追溯。

